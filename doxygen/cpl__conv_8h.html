<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: cpl_conv.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_651562d8bf6cfd3e81eff5b570d7df50.html">port</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cpl_conv.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Various convenience functions for CPL.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cpl__vsi_8h_source.html">cpl_vsi.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cpl__error_8h_source.html">cpl_error.h</a>&quot;</code><br />
</div>
<p><a href="cpl__conv_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCPLSharedFileInfo.html">CPLSharedFileInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information on a shared file.  <a href="structCPLSharedFileInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a21b7f312da39ddb0a12bdde06b153b48" id="r_a21b7f312da39ddb0a12bdde06b153b48"><td class="memItemLeft" align="right" valign="top"><a id="a21b7f312da39ddb0a12bdde06b153b48" name="a21b7f312da39ddb0a12bdde06b153b48"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPLFree</b>&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab">VSIFree</a></td></tr>
<tr class="memdesc:a21b7f312da39ddb0a12bdde06b153b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> <br /></td></tr>
<tr class="separator:a21b7f312da39ddb0a12bdde06b153b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a07d2ac5d9d871797a7712ed591cb85ee" id="r_a07d2ac5d9d871797a7712ed591cb85ee"><td class="memItemLeft" align="right" valign="top"><a id="a07d2ac5d9d871797a7712ed591cb85ee" name="a07d2ac5d9d871797a7712ed591cb85ee"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>CPLSetConfigOptionSubscriber</b>) (const char *pszKey, const char *pszValue, bool bThreadLocal, void *pUserData)</td></tr>
<tr class="memdesc:a07d2ac5d9d871797a7712ed591cb85ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="cpl__conv_8h.html#aad7e2cc46239801842dd0f697deb909f" title="Install a callback that will be notified of calls to CPLSetConfigOption()/ CPLSetThreadLocalConfigOpt...">CPLSubscribeToSetConfigOption()</a> <br /></td></tr>
<tr class="separator:a07d2ac5d9d871797a7712ed591cb85ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39388255b147dd110d3c10fcb852c5d8" id="r_a39388255b147dd110d3c10fcb852c5d8"><td class="memItemLeft" align="right" valign="top"><a id="a39388255b147dd110d3c10fcb852c5d8" name="a39388255b147dd110d3c10fcb852c5d8"></a>
typedef char const *(*&#160;</td><td class="memItemRight" valign="bottom"><b>CPLFileFinder</b>) (const char *, const char *)</td></tr>
<tr class="memdesc:a39388255b147dd110d3c10fcb852c5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for CPLPushFileFinder. <br /></td></tr>
<tr class="separator:a39388255b147dd110d3c10fcb852c5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abf7397078083b0a6a3f40c5394d18189" id="r_abf7397078083b0a6a3f40c5394d18189"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#abf7397078083b0a6a3f40c5394d18189">CPLGetConfigOption</a> (const char *, const char *)</td></tr>
<tr class="memdesc:abf7397078083b0a6a3f40c5394d18189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a configuration option.  <br /></td></tr>
<tr class="separator:abf7397078083b0a6a3f40c5394d18189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abc670974751347248f2e7897452649" id="r_a9abc670974751347248f2e7897452649"><td class="memItemLeft" align="right" valign="top"><a id="a9abc670974751347248f2e7897452649" name="a9abc670974751347248f2e7897452649"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>CPLGetThreadLocalConfigOption</b> (const char *, const char *)</td></tr>
<tr class="memdesc:a9abc670974751347248f2e7897452649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as CPLGetConfigOption() but only with options set with CPLSetThreadLocalConfigOption() <br /></td></tr>
<tr class="separator:a9abc670974751347248f2e7897452649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a343de18825ab7f159a3e666e62fa6" id="r_a86a343de18825ab7f159a3e666e62fa6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a86a343de18825ab7f159a3e666e62fa6">CPLGetGlobalConfigOption</a> (const char *, const char *)</td></tr>
<tr class="memdesc:a86a343de18825ab7f159a3e666e62fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as CPLGetConfigOption() but excludes environment variables and options set with CPLSetThreadLocalConfigOption().  <br /></td></tr>
<tr class="separator:a86a343de18825ab7f159a3e666e62fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cd1a68fe4f2fc7874cd2da605c36ce" id="r_aa0cd1a68fe4f2fc7874cd2da605c36ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce">CPLSetConfigOption</a> (const char *, const char *)</td></tr>
<tr class="memdesc:aa0cd1a68fe4f2fc7874cd2da605c36ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a configuration option for GDAL/OGR use.  <br /></td></tr>
<tr class="separator:aa0cd1a68fe4f2fc7874cd2da605c36ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f0d1de8f2b2069c6ea9352ca4442cd" id="r_ac8f0d1de8f2b2069c6ea9352ca4442cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ac8f0d1de8f2b2069c6ea9352ca4442cd">CPLSetThreadLocalConfigOption</a> (const char *pszKey, const char *pszValue)</td></tr>
<tr class="memdesc:ac8f0d1de8f2b2069c6ea9352ca4442cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a configuration option for GDAL/OGR use.  <br /></td></tr>
<tr class="separator:ac8f0d1de8f2b2069c6ea9352ca4442cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7e2cc46239801842dd0f697deb909f" id="r_aad7e2cc46239801842dd0f697deb909f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aad7e2cc46239801842dd0f697deb909f">CPLSubscribeToSetConfigOption</a> (<a class="el" href="cpl__conv_8h.html#a07d2ac5d9d871797a7712ed591cb85ee">CPLSetConfigOptionSubscriber</a> pfnCallback, void *pUserData)</td></tr>
<tr class="memdesc:aad7e2cc46239801842dd0f697deb909f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a callback that will be notified of calls to CPLSetConfigOption()/ CPLSetThreadLocalConfigOption()  <br /></td></tr>
<tr class="separator:aad7e2cc46239801842dd0f697deb909f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9636c2f46b1a174077c99be10287a078" id="r_a9636c2f46b1a174077c99be10287a078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a9636c2f46b1a174077c99be10287a078">CPLUnsubscribeToSetConfigOption</a> (int nSubscriberId)</td></tr>
<tr class="memdesc:a9636c2f46b1a174077c99be10287a078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a subscriber installed with CPLSubscribeToSetConfigOption()  <br /></td></tr>
<tr class="separator:a9636c2f46b1a174077c99be10287a078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0ef62eb12171502caf782ddf94068e" id="r_a7a0ef62eb12171502caf782ddf94068e"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a7a0ef62eb12171502caf782ddf94068e">CPLGetConfigOptions</a> (void)</td></tr>
<tr class="memdesc:a7a0ef62eb12171502caf782ddf94068e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of configuration options as KEY=VALUE pairs.  <br /></td></tr>
<tr class="separator:a7a0ef62eb12171502caf782ddf94068e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344c2f785aa2bc4ac853e8c4729b31a5" id="r_a344c2f785aa2bc4ac853e8c4729b31a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a344c2f785aa2bc4ac853e8c4729b31a5">CPLSetConfigOptions</a> (const char *const *papszConfigOptions)</td></tr>
<tr class="memdesc:a344c2f785aa2bc4ac853e8c4729b31a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the full list of configuration options with the passed list of KEY=VALUE pairs.  <br /></td></tr>
<tr class="separator:a344c2f785aa2bc4ac853e8c4729b31a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0940a292a3259ca6429dcc52b7eec7" id="r_a2e0940a292a3259ca6429dcc52b7eec7"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a2e0940a292a3259ca6429dcc52b7eec7">CPLGetThreadLocalConfigOptions</a> (void)</td></tr>
<tr class="memdesc:a2e0940a292a3259ca6429dcc52b7eec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of thread local configuration options as KEY=VALUE pairs.  <br /></td></tr>
<tr class="separator:a2e0940a292a3259ca6429dcc52b7eec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f7cb2472b60a21c7b019de160f88bb" id="r_af8f7cb2472b60a21c7b019de160f88bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#af8f7cb2472b60a21c7b019de160f88bb">CPLSetThreadLocalConfigOptions</a> (const char *const *papszConfigOptions)</td></tr>
<tr class="memdesc:af8f7cb2472b60a21c7b019de160f88bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the full list of thread local configuration options with the passed list of KEY=VALUE pairs.  <br /></td></tr>
<tr class="separator:af8f7cb2472b60a21c7b019de160f88bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274ec722cbcba36b84a6c69e72bdb8d1" id="r_a274ec722cbcba36b84a6c69e72bdb8d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a274ec722cbcba36b84a6c69e72bdb8d1">CPLLoadConfigOptionsFromFile</a> (const char *pszFilename, int bOverrideEnvVars)</td></tr>
<tr class="memdesc:a274ec722cbcba36b84a6c69e72bdb8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load configuration from a given configuration file.  <br /></td></tr>
<tr class="separator:a274ec722cbcba36b84a6c69e72bdb8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f793111568325fbee2cbd636275cfd" id="r_a79f793111568325fbee2cbd636275cfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a79f793111568325fbee2cbd636275cfd">CPLLoadConfigOptionsFromPredefinedFiles</a> (void)</td></tr>
<tr class="memdesc:a79f793111568325fbee2cbd636275cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load configuration from a set of predefined files.  <br /></td></tr>
<tr class="separator:a79f793111568325fbee2cbd636275cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a6745dd4349e841f6226316864b77f" id="r_a41a6745dd4349e841f6226316864b77f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a41a6745dd4349e841f6226316864b77f">CPLMalloc</a> (size_t)</td></tr>
<tr class="memdesc:a41a6745dd4349e841f6226316864b77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe version of malloc().  <br /></td></tr>
<tr class="separator:a41a6745dd4349e841f6226316864b77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615ef734360bf56561602f4e618e5d6d" id="r_a615ef734360bf56561602f4e618e5d6d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a615ef734360bf56561602f4e618e5d6d">CPLCalloc</a> (size_t, size_t)</td></tr>
<tr class="memdesc:a615ef734360bf56561602f4e618e5d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe version of calloc().  <br /></td></tr>
<tr class="separator:a615ef734360bf56561602f4e618e5d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3636f780de6227634b629f2675f0e53e" id="r_a3636f780de6227634b629f2675f0e53e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a3636f780de6227634b629f2675f0e53e">CPLRealloc</a> (void *, size_t)</td></tr>
<tr class="memdesc:a3636f780de6227634b629f2675f0e53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe version of realloc().  <br /></td></tr>
<tr class="separator:a3636f780de6227634b629f2675f0e53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714fff57a1304b926bf8c8a1f6e2d660" id="r_a714fff57a1304b926bf8c8a1f6e2d660"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a714fff57a1304b926bf8c8a1f6e2d660">CPLStrdup</a> (const char *)</td></tr>
<tr class="memdesc:a714fff57a1304b926bf8c8a1f6e2d660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe version of strdup() function.  <br /></td></tr>
<tr class="separator:a714fff57a1304b926bf8c8a1f6e2d660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad156021dc0ac7c8b76193bbed26c1c22" id="r_ad156021dc0ac7c8b76193bbed26c1c22"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ad156021dc0ac7c8b76193bbed26c1c22">CPLStrlwr</a> (char *)</td></tr>
<tr class="memdesc:ad156021dc0ac7c8b76193bbed26c1c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert each characters of the string to lower case.  <br /></td></tr>
<tr class="separator:ad156021dc0ac7c8b76193bbed26c1c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25077ce43ee5c167c082daf058efed9" id="r_aa25077ce43ee5c167c082daf058efed9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa25077ce43ee5c167c082daf058efed9">CPLFGets</a> (char *, int, FILE *)</td></tr>
<tr class="memdesc:aa25077ce43ee5c167c082daf058efed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in at most one less than nBufferSize characters from the fp stream and stores them into the buffer pointed to by pszBuffer.  <br /></td></tr>
<tr class="separator:aa25077ce43ee5c167c082daf058efed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e7715662844e90ce7ffef8f583c2a0" id="r_a81e7715662844e90ce7ffef8f583c2a0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a81e7715662844e90ce7ffef8f583c2a0">CPLReadLine</a> (FILE *)</td></tr>
<tr class="memdesc:a81e7715662844e90ce7ffef8f583c2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified line reading from text file.  <br /></td></tr>
<tr class="separator:a81e7715662844e90ce7ffef8f583c2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81662c4f48df1e6ae0c7ca9fb403401d" id="r_a81662c4f48df1e6ae0c7ca9fb403401d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a81662c4f48df1e6ae0c7ca9fb403401d">CPLReadLineL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a81662c4f48df1e6ae0c7ca9fb403401d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified line reading from text file.  <br /></td></tr>
<tr class="separator:a81662c4f48df1e6ae0c7ca9fb403401d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1120e4956b845683116e05db9c48ccaa" id="r_a1120e4956b845683116e05db9c48ccaa"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a1120e4956b845683116e05db9c48ccaa">CPLReadLine2L</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *, int, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>)</td></tr>
<tr class="memdesc:a1120e4956b845683116e05db9c48ccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified line reading from text file.  <br /></td></tr>
<tr class="separator:a1120e4956b845683116e05db9c48ccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210463648ec02bfee33cb804f499f7ca" id="r_a210463648ec02bfee33cb804f499f7ca"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a210463648ec02bfee33cb804f499f7ca">CPLReadLine3L</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *, int, int *, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>)</td></tr>
<tr class="memdesc:a210463648ec02bfee33cb804f499f7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified line reading from text file.  <br /></td></tr>
<tr class="separator:a210463648ec02bfee33cb804f499f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5bf88066f997b1ab3b3911f5e9b722" id="r_afb5bf88066f997b1ab3b3911f5e9b722"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722">CPLAtof</a> (const char *)</td></tr>
<tr class="memdesc:afb5bf88066f997b1ab3b3911f5e9b722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ASCII string to floating point number.  <br /></td></tr>
<tr class="separator:afb5bf88066f997b1ab3b3911f5e9b722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a01ca071035c36d4b4f85336e08c5d5" id="r_a0a01ca071035c36d4b4f85336e08c5d5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a0a01ca071035c36d4b4f85336e08c5d5">CPLAtofDelim</a> (const char *, char)</td></tr>
<tr class="memdesc:a0a01ca071035c36d4b4f85336e08c5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ASCII string to floating point number.  <br /></td></tr>
<tr class="separator:a0a01ca071035c36d4b4f85336e08c5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2388e43fb089a354eb3583016b2a3b00" id="r_a2388e43fb089a354eb3583016b2a3b00"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a2388e43fb089a354eb3583016b2a3b00">CPLStrtod</a> (const char *, char **)</td></tr>
<tr class="memdesc:a2388e43fb089a354eb3583016b2a3b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ASCII string to floating point number.  <br /></td></tr>
<tr class="separator:a2388e43fb089a354eb3583016b2a3b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e1feed3a71e84505a3e44749c003b" id="r_a7a9e1feed3a71e84505a3e44749c003b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a7a9e1feed3a71e84505a3e44749c003b">CPLStrtodM</a> (const char *, char **)</td></tr>
<tr class="memdesc:a7a9e1feed3a71e84505a3e44749c003b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ASCII string to floating point number.  <br /></td></tr>
<tr class="separator:a7a9e1feed3a71e84505a3e44749c003b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96c5f1823c54ef96b5783208c817817" id="r_ac96c5f1823c54ef96b5783208c817817"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ac96c5f1823c54ef96b5783208c817817">CPLStrtodDelim</a> (const char *, char **, char)</td></tr>
<tr class="memdesc:ac96c5f1823c54ef96b5783208c817817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ASCII string to floating point number using specified delimiter.  <br /></td></tr>
<tr class="separator:ac96c5f1823c54ef96b5783208c817817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccda187ed172fd6e33cd98223328531" id="r_a1ccda187ed172fd6e33cd98223328531"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a1ccda187ed172fd6e33cd98223328531">CPLStrtof</a> (const char *, char **)</td></tr>
<tr class="memdesc:a1ccda187ed172fd6e33cd98223328531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ASCII string to floating point number.  <br /></td></tr>
<tr class="separator:a1ccda187ed172fd6e33cd98223328531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a102a1417c98a242900fb8c0076fc1b" id="r_a3a102a1417c98a242900fb8c0076fc1b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a3a102a1417c98a242900fb8c0076fc1b">CPLStrtofDelim</a> (const char *, char **, char)</td></tr>
<tr class="memdesc:a3a102a1417c98a242900fb8c0076fc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ASCII string to floating point number using specified delimiter.  <br /></td></tr>
<tr class="separator:a3a102a1417c98a242900fb8c0076fc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07cd1b2aa5e76eb67ba952440198796" id="r_aa07cd1b2aa5e76eb67ba952440198796"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa07cd1b2aa5e76eb67ba952440198796">CPLAtofM</a> (const char *)</td></tr>
<tr class="memdesc:aa07cd1b2aa5e76eb67ba952440198796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ASCII string to floating point number using any numeric locale.  <br /></td></tr>
<tr class="separator:aa07cd1b2aa5e76eb67ba952440198796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a293942b532cc19bf3c251e02ad5d4" id="r_a55a293942b532cc19bf3c251e02ad5d4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a55a293942b532cc19bf3c251e02ad5d4">CPLScanString</a> (const char *, int, int, int)</td></tr>
<tr class="memdesc:a55a293942b532cc19bf3c251e02ad5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan up to a maximum number of characters from a given string, allocate a buffer for a new string and fill it with scanned characters.  <br /></td></tr>
<tr class="separator:a55a293942b532cc19bf3c251e02ad5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdeae39a61518c9c31ecc593eeff621" id="r_abcdeae39a61518c9c31ecc593eeff621"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#abcdeae39a61518c9c31ecc593eeff621">CPLScanDouble</a> (const char *, int)</td></tr>
<tr class="memdesc:abcdeae39a61518c9c31ecc593eeff621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract double from string.  <br /></td></tr>
<tr class="separator:abcdeae39a61518c9c31ecc593eeff621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338bbe67c148d2555861eb5563b17303" id="r_a338bbe67c148d2555861eb5563b17303"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a338bbe67c148d2555861eb5563b17303">CPLScanLong</a> (const char *, int)</td></tr>
<tr class="memdesc:a338bbe67c148d2555861eb5563b17303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan up to a maximum number of characters from a string and convert the result to a long.  <br /></td></tr>
<tr class="separator:a338bbe67c148d2555861eb5563b17303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e9643c26ab4ee22df95e3dd18c959a" id="r_ac6e9643c26ab4ee22df95e3dd18c959a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ac6e9643c26ab4ee22df95e3dd18c959a">CPLScanULong</a> (const char *, int)</td></tr>
<tr class="memdesc:ac6e9643c26ab4ee22df95e3dd18c959a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan up to a maximum number of characters from a string and convert the result to a unsigned long.  <br /></td></tr>
<tr class="separator:ac6e9643c26ab4ee22df95e3dd18c959a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a8e6cf7a0d0f662f6cd4555b074bb5" id="r_ab4a8e6cf7a0d0f662f6cd4555b074bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#a4f0794a0fb78d55ba284a414191dbc93">GUIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ab4a8e6cf7a0d0f662f6cd4555b074bb5">CPLScanUIntBig</a> (const char *, int)</td></tr>
<tr class="memdesc:ab4a8e6cf7a0d0f662f6cd4555b074bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract big integer from string.  <br /></td></tr>
<tr class="separator:ab4a8e6cf7a0d0f662f6cd4555b074bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35579a348f417a35965d6be69cde090" id="r_aa35579a348f417a35965d6be69cde090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa35579a348f417a35965d6be69cde090">CPLAtoGIntBig</a> (const char *pszString)</td></tr>
<tr class="memdesc:aa35579a348f417a35965d6be69cde090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a 64 bit signed integer.  <br /></td></tr>
<tr class="separator:aa35579a348f417a35965d6be69cde090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646aeb2044bf0ff4dace5793f17c11e8" id="r_a646aeb2044bf0ff4dace5793f17c11e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a646aeb2044bf0ff4dace5793f17c11e8">CPLAtoGIntBigEx</a> (const char *pszString, int bWarn, int *pbOverflow)</td></tr>
<tr class="memdesc:a646aeb2044bf0ff4dace5793f17c11e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a 64 bit signed integer.  <br /></td></tr>
<tr class="separator:a646aeb2044bf0ff4dace5793f17c11e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652e12b20dd8f5f05b401a3db9d4ca29" id="r_a652e12b20dd8f5f05b401a3db9d4ca29"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a652e12b20dd8f5f05b401a3db9d4ca29">CPLScanPointer</a> (const char *, int)</td></tr>
<tr class="memdesc:a652e12b20dd8f5f05b401a3db9d4ca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract pointer from string.  <br /></td></tr>
<tr class="separator:a652e12b20dd8f5f05b401a3db9d4ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae284b3e504edca3eb1eaf568469d61ba" id="r_ae284b3e504edca3eb1eaf568469d61ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ae284b3e504edca3eb1eaf568469d61ba">CPLPrintString</a> (char *, const char *, int)</td></tr>
<tr class="memdesc:ae284b3e504edca3eb1eaf568469d61ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string pointed to by pszSrc, NOT including the terminating &lsquo;\0&rsquo; character, to the array pointed to by pszDest.  <br /></td></tr>
<tr class="separator:ae284b3e504edca3eb1eaf568469d61ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdbcb209eb9b8e2e6be4fa6e0b750f6" id="r_a0bdbcb209eb9b8e2e6be4fa6e0b750f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a0bdbcb209eb9b8e2e6be4fa6e0b750f6">CPLPrintStringFill</a> (char *, const char *, int)</td></tr>
<tr class="memdesc:a0bdbcb209eb9b8e2e6be4fa6e0b750f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string pointed to by pszSrc, NOT including the terminating &lsquo;\0&rsquo; character, to the array pointed to by pszDest.  <br /></td></tr>
<tr class="separator:a0bdbcb209eb9b8e2e6be4fa6e0b750f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33618500e56ec12e6775b3ed9014b8fb" id="r_a33618500e56ec12e6775b3ed9014b8fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a33618500e56ec12e6775b3ed9014b8fb">CPLPrintInt32</a> (char *, <a class="el" href="cpl__port_8h.html#af19adaeb9a6dd7c664fc6f79e426854a">GInt32</a>, int)</td></tr>
<tr class="memdesc:a33618500e56ec12e6775b3ed9014b8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print GInt32 value into specified string buffer.  <br /></td></tr>
<tr class="separator:a33618500e56ec12e6775b3ed9014b8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ca1da1151489f1eee7770296f164aa" id="r_a13ca1da1151489f1eee7770296f164aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a13ca1da1151489f1eee7770296f164aa">CPLPrintUIntBig</a> (char *, <a class="el" href="cpl__port_8h.html#a4f0794a0fb78d55ba284a414191dbc93">GUIntBig</a>, int)</td></tr>
<tr class="memdesc:a13ca1da1151489f1eee7770296f164aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print GUIntBig value into specified string buffer.  <br /></td></tr>
<tr class="separator:a13ca1da1151489f1eee7770296f164aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e478b4f2e14cc03ae23a9c81434c9" id="r_ad77e478b4f2e14cc03ae23a9c81434c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ad77e478b4f2e14cc03ae23a9c81434c9">CPLPrintDouble</a> (char *, const char *, double, const char *)</td></tr>
<tr class="memdesc:ad77e478b4f2e14cc03ae23a9c81434c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print double value into specified string buffer.  <br /></td></tr>
<tr class="separator:ad77e478b4f2e14cc03ae23a9c81434c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be9cf1de05769139a77339ffb970ce4" id="r_a5be9cf1de05769139a77339ffb970ce4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a5be9cf1de05769139a77339ffb970ce4">CPLPrintTime</a> (char *, int, const char *, const struct tm *, const char *)</td></tr>
<tr class="memdesc:a5be9cf1de05769139a77339ffb970ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print specified time value accordingly to the format options and specified locale name.  <br /></td></tr>
<tr class="separator:a5be9cf1de05769139a77339ffb970ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af268becc479787ae48bb2607d0000886" id="r_af268becc479787ae48bb2607d0000886"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#af268becc479787ae48bb2607d0000886">CPLPrintPointer</a> (char *, void *, int)</td></tr>
<tr class="memdesc:af268becc479787ae48bb2607d0000886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print pointer value into specified string buffer.  <br /></td></tr>
<tr class="separator:af268becc479787ae48bb2607d0000886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8e54bbbdd75f6315fe2fafd3d5259f" id="r_a0c8e54bbbdd75f6315fe2fafd3d5259f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a0c8e54bbbdd75f6315fe2fafd3d5259f">CPLGetSymbol</a> (const char *, const char *)</td></tr>
<tr class="memdesc:a0c8e54bbbdd75f6315fe2fafd3d5259f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a function pointer from a shared library / DLL.  <br /></td></tr>
<tr class="separator:a0c8e54bbbdd75f6315fe2fafd3d5259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5325c900de0918020b747ed07d98da24" id="r_a5325c900de0918020b747ed07d98da24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a5325c900de0918020b747ed07d98da24">CPLGetExecPath</a> (char *pszPathBuf, int nMaxLength)</td></tr>
<tr class="memdesc:a5325c900de0918020b747ed07d98da24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch path of executable.  <br /></td></tr>
<tr class="separator:a5325c900de0918020b747ed07d98da24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69baba7d6823844a3b435e4095e7ea9c" id="r_a69baba7d6823844a3b435e4095e7ea9c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a69baba7d6823844a3b435e4095e7ea9c">CPLGetPath</a> (const char *)</td></tr>
<tr class="memdesc:a69baba7d6823844a3b435e4095e7ea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract directory path portion of filename.  <br /></td></tr>
<tr class="separator:a69baba7d6823844a3b435e4095e7ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d9a3d3b8262b907411a30119e4ba4b" id="r_a41d9a3d3b8262b907411a30119e4ba4b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a41d9a3d3b8262b907411a30119e4ba4b">CPLGetDirname</a> (const char *)</td></tr>
<tr class="memdesc:a41d9a3d3b8262b907411a30119e4ba4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract directory path portion of filename.  <br /></td></tr>
<tr class="separator:a41d9a3d3b8262b907411a30119e4ba4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe9c7c2a5d9ddc4854b2a54ab0884f9" id="r_acfe9c7c2a5d9ddc4854b2a54ab0884f9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#acfe9c7c2a5d9ddc4854b2a54ab0884f9">CPLGetFilename</a> (const char *)</td></tr>
<tr class="memdesc:acfe9c7c2a5d9ddc4854b2a54ab0884f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract non-directory portion of filename.  <br /></td></tr>
<tr class="separator:acfe9c7c2a5d9ddc4854b2a54ab0884f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f66be126835aed96d00fef83737d062" id="r_a3f66be126835aed96d00fef83737d062"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a3f66be126835aed96d00fef83737d062">CPLGetBasename</a> (const char *)</td></tr>
<tr class="memdesc:a3f66be126835aed96d00fef83737d062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract basename (non-directory, non-extension) portion of filename.  <br /></td></tr>
<tr class="separator:a3f66be126835aed96d00fef83737d062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25caa4bc87e8cd71cdf1833e5d57f36b" id="r_a25caa4bc87e8cd71cdf1833e5d57f36b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a25caa4bc87e8cd71cdf1833e5d57f36b">CPLGetExtension</a> (const char *)</td></tr>
<tr class="memdesc:a25caa4bc87e8cd71cdf1833e5d57f36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract filename extension from full filename.  <br /></td></tr>
<tr class="separator:a25caa4bc87e8cd71cdf1833e5d57f36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90300b2a945c160440bd173624f1ab93" id="r_a90300b2a945c160440bd173624f1ab93"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a90300b2a945c160440bd173624f1ab93">CPLGetCurrentDir</a> (void)</td></tr>
<tr class="memdesc:a90300b2a945c160440bd173624f1ab93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current working directory name.  <br /></td></tr>
<tr class="separator:a90300b2a945c160440bd173624f1ab93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad607f638b801165e4d095ab2241713f1" id="r_ad607f638b801165e4d095ab2241713f1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ad607f638b801165e4d095ab2241713f1">CPLFormFilename</a> (const char *pszPath, const char *pszBasename, const char *pszExtension)</td></tr>
<tr class="memdesc:ad607f638b801165e4d095ab2241713f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a full file path from a passed path, file basename and extension.  <br /></td></tr>
<tr class="separator:ad607f638b801165e4d095ab2241713f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fe427bdefcb71a82023259a5df4566" id="r_a54fe427bdefcb71a82023259a5df4566"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a54fe427bdefcb71a82023259a5df4566">CPLFormCIFilename</a> (const char *pszPath, const char *pszBasename, const char *pszExtension)</td></tr>
<tr class="memdesc:a54fe427bdefcb71a82023259a5df4566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case insensitive file searching, returning full path.  <br /></td></tr>
<tr class="separator:a54fe427bdefcb71a82023259a5df4566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b9a72cf558c7fbe98890584d926a5d" id="r_a86b9a72cf558c7fbe98890584d926a5d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a86b9a72cf558c7fbe98890584d926a5d">CPLResetExtension</a> (const char *, const char *)</td></tr>
<tr class="memdesc:a86b9a72cf558c7fbe98890584d926a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the extension with the provided one.  <br /></td></tr>
<tr class="separator:a86b9a72cf558c7fbe98890584d926a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20697f44daa7a35f22568f4621c94fd" id="r_ab20697f44daa7a35f22568f4621c94fd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ab20697f44daa7a35f22568f4621c94fd">CPLProjectRelativeFilename</a> (const char *pszProjectDir, const char *pszSecondaryFilename)</td></tr>
<tr class="memdesc:ab20697f44daa7a35f22568f4621c94fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a file relative to a project file.  <br /></td></tr>
<tr class="separator:ab20697f44daa7a35f22568f4621c94fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd8ae8d760125ec5b01958a776691ec" id="r_a0cd8ae8d760125ec5b01958a776691ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a0cd8ae8d760125ec5b01958a776691ec">CPLIsFilenameRelative</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a0cd8ae8d760125ec5b01958a776691ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is filename relative or absolute?  <br /></td></tr>
<tr class="separator:a0cd8ae8d760125ec5b01958a776691ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d87a1e45e214e11ca977e77431caaa" id="r_a97d87a1e45e214e11ca977e77431caaa"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a97d87a1e45e214e11ca977e77431caaa">CPLExtractRelativePath</a> (const char *, const char *, int *)</td></tr>
<tr class="memdesc:a97d87a1e45e214e11ca977e77431caaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get relative path from directory to target file.  <br /></td></tr>
<tr class="separator:a97d87a1e45e214e11ca977e77431caaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810d582548c7530c6b21894964e74618" id="r_a810d582548c7530c6b21894964e74618"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a810d582548c7530c6b21894964e74618">CPLCleanTrailingSlash</a> (const char *)</td></tr>
<tr class="memdesc:a810d582548c7530c6b21894964e74618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove trailing forward/backward slash from the path for UNIX/Windows resp.  <br /></td></tr>
<tr class="separator:a810d582548c7530c6b21894964e74618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0c8c75ac676b3f6efe8a0b14622a59" id="r_a6a0c8c75ac676b3f6efe8a0b14622a59"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a6a0c8c75ac676b3f6efe8a0b14622a59">CPLCorrespondingPaths</a> (const char *pszOldFilename, const char *pszNewFilename, char **papszFileList)</td></tr>
<tr class="memdesc:a6a0c8c75ac676b3f6efe8a0b14622a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify corresponding paths.  <br /></td></tr>
<tr class="separator:a6a0c8c75ac676b3f6efe8a0b14622a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9b8f28ae84d5d898b7a3afc6bb6a4b" id="r_afa9b8f28ae84d5d898b7a3afc6bb6a4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#afa9b8f28ae84d5d898b7a3afc6bb6a4b">CPLCheckForFile</a> (char *pszFilename, char **papszSiblingList)</td></tr>
<tr class="memdesc:afa9b8f28ae84d5d898b7a3afc6bb6a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for file existence.  <br /></td></tr>
<tr class="separator:afa9b8f28ae84d5d898b7a3afc6bb6a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675f0de81458be686a733915b04370ec" id="r_a675f0de81458be686a733915b04370ec"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a675f0de81458be686a733915b04370ec">CPLGenerateTempFilename</a> (const char *pszStem)</td></tr>
<tr class="memdesc:a675f0de81458be686a733915b04370ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate temporary file name.  <br /></td></tr>
<tr class="separator:a675f0de81458be686a733915b04370ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058f8e51ea0e81bf761ad87d89626cc6" id="r_a058f8e51ea0e81bf761ad87d89626cc6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a058f8e51ea0e81bf761ad87d89626cc6">CPLExpandTilde</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a058f8e51ea0e81bf761ad87d89626cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands ~/ at start of filename.  <br /></td></tr>
<tr class="separator:a058f8e51ea0e81bf761ad87d89626cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e35ea9017f4f7dbc818b52a287e082" id="r_a02e35ea9017f4f7dbc818b52a287e082"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a02e35ea9017f4f7dbc818b52a287e082">CPLGetHomeDir</a> (void)</td></tr>
<tr class="memdesc:a02e35ea9017f4f7dbc818b52a287e082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path to the home directory.  <br /></td></tr>
<tr class="separator:a02e35ea9017f4f7dbc818b52a287e082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412f3eb3eaaed0e51fa4f882a77d9833" id="r_a412f3eb3eaaed0e51fa4f882a77d9833"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a412f3eb3eaaed0e51fa4f882a77d9833">CPLLaunderForFilename</a> (const char *pszName, const char *pszOutputPath)</td></tr>
<tr class="memdesc:a412f3eb3eaaed0e51fa4f882a77d9833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launder a string to be compatible of a filename.  <br /></td></tr>
<tr class="separator:a412f3eb3eaaed0e51fa4f882a77d9833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0e1cc554494504bceb28424fe842e5" id="r_abb0e1cc554494504bceb28424fe842e5"><td class="memItemLeft" align="right" valign="top"><a id="abb0e1cc554494504bceb28424fe842e5" name="abb0e1cc554494504bceb28424fe842e5"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>CPLFindFile</b> (const char *pszClass, const char *pszBasename)</td></tr>
<tr class="memdesc:abb0e1cc554494504bceb28424fe842e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPLFindFile. <br /></td></tr>
<tr class="separator:abb0e1cc554494504bceb28424fe842e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb589c0e5b7bbdd4ea95ce2b3b88e2a8" id="r_aeb589c0e5b7bbdd4ea95ce2b3b88e2a8"><td class="memItemLeft" align="right" valign="top"><a id="aeb589c0e5b7bbdd4ea95ce2b3b88e2a8" name="aeb589c0e5b7bbdd4ea95ce2b3b88e2a8"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>CPLDefaultFindFile</b> (const char *pszClass, const char *pszBasename)</td></tr>
<tr class="memdesc:aeb589c0e5b7bbdd4ea95ce2b3b88e2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPLDefaultFindFile. <br /></td></tr>
<tr class="separator:aeb589c0e5b7bbdd4ea95ce2b3b88e2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9205b5a0266e9ff0130324016cfe2743" id="r_a9205b5a0266e9ff0130324016cfe2743"><td class="memItemLeft" align="right" valign="top"><a id="a9205b5a0266e9ff0130324016cfe2743" name="a9205b5a0266e9ff0130324016cfe2743"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CPLPushFileFinder</b> (<a class="el" href="cpl__conv_8h.html#a39388255b147dd110d3c10fcb852c5d8">CPLFileFinder</a> pfnFinder)</td></tr>
<tr class="memdesc:a9205b5a0266e9ff0130324016cfe2743"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPLPushFileFinder. <br /></td></tr>
<tr class="separator:a9205b5a0266e9ff0130324016cfe2743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09a216ab0d69b57b528628ef2f9ee51" id="r_af09a216ab0d69b57b528628ef2f9ee51"><td class="memItemLeft" align="right" valign="top"><a id="af09a216ab0d69b57b528628ef2f9ee51" name="af09a216ab0d69b57b528628ef2f9ee51"></a>
<a class="el" href="cpl__conv_8h.html#a39388255b147dd110d3c10fcb852c5d8">CPLFileFinder</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CPLPopFileFinder</b> (void)</td></tr>
<tr class="memdesc:af09a216ab0d69b57b528628ef2f9ee51"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPLPopFileFinder. <br /></td></tr>
<tr class="separator:af09a216ab0d69b57b528628ef2f9ee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb38a901b889d3b0d8a28ede5f97ef5" id="r_a8fb38a901b889d3b0d8a28ede5f97ef5"><td class="memItemLeft" align="right" valign="top"><a id="a8fb38a901b889d3b0d8a28ede5f97ef5" name="a8fb38a901b889d3b0d8a28ede5f97ef5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CPLPushFinderLocation</b> (const char *)</td></tr>
<tr class="memdesc:a8fb38a901b889d3b0d8a28ede5f97ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPLPushFinderLocation. <br /></td></tr>
<tr class="separator:a8fb38a901b889d3b0d8a28ede5f97ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbfaacc8fd61bcff6c06d5b8061dff4" id="r_a9dbfaacc8fd61bcff6c06d5b8061dff4"><td class="memItemLeft" align="right" valign="top"><a id="a9dbfaacc8fd61bcff6c06d5b8061dff4" name="a9dbfaacc8fd61bcff6c06d5b8061dff4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CPLPopFinderLocation</b> (void)</td></tr>
<tr class="memdesc:a9dbfaacc8fd61bcff6c06d5b8061dff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPLPopFinderLocation. <br /></td></tr>
<tr class="separator:a9dbfaacc8fd61bcff6c06d5b8061dff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1735b5f7aeeed289c5dd699da9acb1" id="r_a5d1735b5f7aeeed289c5dd699da9acb1"><td class="memItemLeft" align="right" valign="top"><a id="a5d1735b5f7aeeed289c5dd699da9acb1" name="a5d1735b5f7aeeed289c5dd699da9acb1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CPLFinderClean</b> (void)</td></tr>
<tr class="memdesc:a5d1735b5f7aeeed289c5dd699da9acb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPLFinderClean. <br /></td></tr>
<tr class="separator:a5d1735b5f7aeeed289c5dd699da9acb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95889f0027c30ed79b3a544a6eacf161" id="r_a95889f0027c30ed79b3a544a6eacf161"><td class="memItemLeft" align="right" valign="top"><a id="a95889f0027c30ed79b3a544a6eacf161" name="a95889f0027c30ed79b3a544a6eacf161"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CPLStat</b> (const char *, VSIStatBuf *)</td></tr>
<tr class="memdesc:a95889f0027c30ed79b3a544a6eacf161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as VSIStat() except it works on "C:" as if it were "C:\". <br /></td></tr>
<tr class="separator:a95889f0027c30ed79b3a544a6eacf161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e97efa26bbe4ff3a7b8a0bdf3cd5f6f" id="r_a8e97efa26bbe4ff3a7b8a0bdf3cd5f6f"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a8e97efa26bbe4ff3a7b8a0bdf3cd5f6f">CPLOpenShared</a> (const char *, const char *, int)</td></tr>
<tr class="memdesc:a8e97efa26bbe4ff3a7b8a0bdf3cd5f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a shared file handle.  <br /></td></tr>
<tr class="separator:a8e97efa26bbe4ff3a7b8a0bdf3cd5f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afd2c936bbf27a74b02ae6dcadf25a7" id="r_a1afd2c936bbf27a74b02ae6dcadf25a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a1afd2c936bbf27a74b02ae6dcadf25a7">CPLCloseShared</a> (FILE *)</td></tr>
<tr class="memdesc:a1afd2c936bbf27a74b02ae6dcadf25a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close shared file.  <br /></td></tr>
<tr class="separator:a1afd2c936bbf27a74b02ae6dcadf25a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacced4f4d48b4442b2bdbe08db4d3c0" id="r_afacced4f4d48b4442b2bdbe08db4d3c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLSharedFileInfo.html">CPLSharedFileInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#afacced4f4d48b4442b2bdbe08db4d3c0">CPLGetSharedList</a> (int *)</td></tr>
<tr class="memdesc:afacced4f4d48b4442b2bdbe08db4d3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch list of open shared files.  <br /></td></tr>
<tr class="separator:afacced4f4d48b4442b2bdbe08db4d3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7709a32d13e10f2c6c28a176b5a8784" id="r_aa7709a32d13e10f2c6c28a176b5a8784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa7709a32d13e10f2c6c28a176b5a8784">CPLDumpSharedList</a> (FILE *)</td></tr>
<tr class="memdesc:aa7709a32d13e10f2c6c28a176b5a8784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report open shared files.  <br /></td></tr>
<tr class="separator:aa7709a32d13e10f2c6c28a176b5a8784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f693923cfd3d171adb34420f09f7891" id="r_a7f693923cfd3d171adb34420f09f7891"><td class="memItemLeft" align="right" valign="top"><a id="a7f693923cfd3d171adb34420f09f7891" name="a7f693923cfd3d171adb34420f09f7891"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>CPLDMSToDec</b> (const char *is)</td></tr>
<tr class="memdesc:a7f693923cfd3d171adb34420f09f7891"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPLDMSToDec. <br /></td></tr>
<tr class="separator:a7f693923cfd3d171adb34420f09f7891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa66c1fc0afb6cdfe3d613d7189a6d0" id="r_abaa66c1fc0afb6cdfe3d613d7189a6d0"><td class="memItemLeft" align="right" valign="top"><a id="abaa66c1fc0afb6cdfe3d613d7189a6d0" name="abaa66c1fc0afb6cdfe3d613d7189a6d0"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>CPLDecToDMS</b> (double dfAngle, const char *pszAxis, int nPrecision)</td></tr>
<tr class="memdesc:abaa66c1fc0afb6cdfe3d613d7189a6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a decimal degrees value to a DMS string with hemisphere. <br /></td></tr>
<tr class="separator:abaa66c1fc0afb6cdfe3d613d7189a6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ffc8fd25881635e18d1a53e177a8e1" id="r_aa4ffc8fd25881635e18d1a53e177a8e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa4ffc8fd25881635e18d1a53e177a8e1">CPLPackedDMSToDec</a> (double)</td></tr>
<tr class="memdesc:aa4ffc8fd25881635e18d1a53e177a8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a packed DMS value (DDDMMMSSS.SS) into decimal degrees.  <br /></td></tr>
<tr class="separator:aa4ffc8fd25881635e18d1a53e177a8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b69cc886a1a5c9618612d8205600e4" id="r_a97b69cc886a1a5c9618612d8205600e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a97b69cc886a1a5c9618612d8205600e4">CPLDecToPackedDMS</a> (double dfDec)</td></tr>
<tr class="memdesc:a97b69cc886a1a5c9618612d8205600e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert decimal degrees into packed DMS value (DDDMMMSSS.SS).  <br /></td></tr>
<tr class="separator:a97b69cc886a1a5c9618612d8205600e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d09dcf679de60fdc2262a3a864fae7" id="r_af4d09dcf679de60fdc2262a3a864fae7"><td class="memItemLeft" align="right" valign="top"><a id="af4d09dcf679de60fdc2262a3a864fae7" name="af4d09dcf679de60fdc2262a3a864fae7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CPLStringToComplex</b> (const char *pszString, double *pdfReal, double *pdfImag)</td></tr>
<tr class="memdesc:af4d09dcf679de60fdc2262a3a864fae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the real and imaginary part of a serialized complex number. <br /></td></tr>
<tr class="separator:af4d09dcf679de60fdc2262a3a864fae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa786ff8dd95ea5b2b641de9ed53cb277" id="r_aa786ff8dd95ea5b2b641de9ed53cb277"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa786ff8dd95ea5b2b641de9ed53cb277">CPLUnlinkTree</a> (const char *)</td></tr>
<tr class="memdesc:aa786ff8dd95ea5b2b641de9ed53cb277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively unlink a directory.  <br /></td></tr>
<tr class="separator:aa786ff8dd95ea5b2b641de9ed53cb277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad357816a8e3713a7070e299764b236f7" id="r_ad357816a8e3713a7070e299764b236f7"><td class="memItemLeft" align="right" valign="top"><a id="ad357816a8e3713a7070e299764b236f7" name="ad357816a8e3713a7070e299764b236f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CPLCopyFile</b> (const char *pszNewPath, const char *pszOldPath)</td></tr>
<tr class="memdesc:ad357816a8e3713a7070e299764b236f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a file. <br /></td></tr>
<tr class="separator:ad357816a8e3713a7070e299764b236f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a1cab8e3bdd45d27016a162e5237ce" id="r_a16a1cab8e3bdd45d27016a162e5237ce"><td class="memItemLeft" align="right" valign="top"><a id="a16a1cab8e3bdd45d27016a162e5237ce" name="a16a1cab8e3bdd45d27016a162e5237ce"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CPLCopyTree</b> (const char *pszNewPath, const char *pszOldPath)</td></tr>
<tr class="memdesc:a16a1cab8e3bdd45d27016a162e5237ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively copy a tree. <br /></td></tr>
<tr class="separator:a16a1cab8e3bdd45d27016a162e5237ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2802d9321457b38b3318955c4042f3b9" id="r_a2802d9321457b38b3318955c4042f3b9"><td class="memItemLeft" align="right" valign="top"><a id="a2802d9321457b38b3318955c4042f3b9" name="a2802d9321457b38b3318955c4042f3b9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CPLMoveFile</b> (const char *pszNewPath, const char *pszOldPath)</td></tr>
<tr class="memdesc:a2802d9321457b38b3318955c4042f3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a file. <br /></td></tr>
<tr class="separator:a2802d9321457b38b3318955c4042f3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eed238c33fd3d88831750bdfa3c972f" id="r_a3eed238c33fd3d88831750bdfa3c972f"><td class="memItemLeft" align="right" valign="top"><a id="a3eed238c33fd3d88831750bdfa3c972f" name="a3eed238c33fd3d88831750bdfa3c972f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>CPLSymlink</b> (const char *pszOldPath, const char *pszNewPath, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a3eed238c33fd3d88831750bdfa3c972f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbolic link. <br /></td></tr>
<tr class="separator:a3eed238c33fd3d88831750bdfa3c972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cfec2c26b4fd5856aa52b0a8440b68" id="r_a09cfec2c26b4fd5856aa52b0a8440b68"><td class="memItemLeft" align="right" valign="top"><a id="a09cfec2c26b4fd5856aa52b0a8440b68" name="a09cfec2c26b4fd5856aa52b0a8440b68"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>CPLCreateZip</b> (const char *pszZipFilename, char **papszOptions)</td></tr>
<tr class="memdesc:a09cfec2c26b4fd5856aa52b0a8440b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create ZIP file. <br /></td></tr>
<tr class="separator:a09cfec2c26b4fd5856aa52b0a8440b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a598d868cd731429e0bbd829e901b2" id="r_a71a598d868cd731429e0bbd829e901b2"><td class="memItemLeft" align="right" valign="top"><a id="a71a598d868cd731429e0bbd829e901b2" name="a71a598d868cd731429e0bbd829e901b2"></a>
<a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CPLCreateFileInZip</b> (void *hZip, const char *pszFilename, char **papszOptions)</td></tr>
<tr class="memdesc:a71a598d868cd731429e0bbd829e901b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a file in a ZIP file. <br /></td></tr>
<tr class="separator:a71a598d868cd731429e0bbd829e901b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2172d84e3d7b71191935cc8b3a50c6" id="r_aed2172d84e3d7b71191935cc8b3a50c6"><td class="memItemLeft" align="right" valign="top"><a id="aed2172d84e3d7b71191935cc8b3a50c6" name="aed2172d84e3d7b71191935cc8b3a50c6"></a>
<a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CPLWriteFileInZip</b> (void *hZip, const void *pBuffer, int nBufferSize)</td></tr>
<tr class="memdesc:aed2172d84e3d7b71191935cc8b3a50c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write in current file inside a ZIP file. <br /></td></tr>
<tr class="separator:aed2172d84e3d7b71191935cc8b3a50c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c084e52d88f873c2a070c51941ce19" id="r_ae2c084e52d88f873c2a070c51941ce19"><td class="memItemLeft" align="right" valign="top"><a id="ae2c084e52d88f873c2a070c51941ce19" name="ae2c084e52d88f873c2a070c51941ce19"></a>
<a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CPLCloseFileInZip</b> (void *hZip)</td></tr>
<tr class="memdesc:ae2c084e52d88f873c2a070c51941ce19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close current file inside ZIP file. <br /></td></tr>
<tr class="separator:ae2c084e52d88f873c2a070c51941ce19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a6fd38f14a41bd51f6ca7f80aa78b2" id="r_a42a6fd38f14a41bd51f6ca7f80aa78b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a42a6fd38f14a41bd51f6ca7f80aa78b2">CPLAddFileInZip</a> (void *hZip, const char *pszArchiveFilename, const char *pszInputFilename, <a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *fpInput, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions, GDALProgressFunc pProgressFunc, void *pProgressData)</td></tr>
<tr class="memdesc:a42a6fd38f14a41bd51f6ca7f80aa78b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a file inside a ZIP file opened/created with CPLCreateZip().  <br /></td></tr>
<tr class="separator:a42a6fd38f14a41bd51f6ca7f80aa78b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f8b89602f661237a45545b25b25a05" id="r_a84f8b89602f661237a45545b25b25a05"><td class="memItemLeft" align="right" valign="top"><a id="a84f8b89602f661237a45545b25b25a05" name="a84f8b89602f661237a45545b25b25a05"></a>
<a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CPLCloseZip</b> (void *hZip)</td></tr>
<tr class="memdesc:a84f8b89602f661237a45545b25b25a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close ZIP file. <br /></td></tr>
<tr class="separator:a84f8b89602f661237a45545b25b25a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc32ba31ff1dc92b797b501ebba38f3d" id="r_adc32ba31ff1dc92b797b501ebba38f3d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#adc32ba31ff1dc92b797b501ebba38f3d">CPLZLibDeflate</a> (const void *ptr, size_t nBytes, int nLevel, void *outptr, size_t nOutAvailableBytes, size_t *pnOutBytes)</td></tr>
<tr class="memdesc:adc32ba31ff1dc92b797b501ebba38f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress a buffer with ZLib compression.  <br /></td></tr>
<tr class="separator:adc32ba31ff1dc92b797b501ebba38f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d30bfb414397cf1d848f66a35f302a0" id="r_a3d30bfb414397cf1d848f66a35f302a0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a3d30bfb414397cf1d848f66a35f302a0">CPLZLibInflate</a> (const void *ptr, size_t nBytes, void *outptr, size_t nOutAvailableBytes, size_t *pnOutBytes)</td></tr>
<tr class="memdesc:a3d30bfb414397cf1d848f66a35f302a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress a buffer compressed with ZLib compression.  <br /></td></tr>
<tr class="separator:a3d30bfb414397cf1d848f66a35f302a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3bdf47e48bec2af069ef6fad851ab0" id="r_afa3bdf47e48bec2af069ef6fad851ab0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#afa3bdf47e48bec2af069ef6fad851ab0">CPLZLibInflateEx</a> (const void *ptr, size_t nBytes, void *outptr, size_t nOutAvailableBytes, bool bAllowResizeOutptr, size_t *pnOutBytes)</td></tr>
<tr class="memdesc:afa3bdf47e48bec2af069ef6fad851ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress a buffer compressed with ZLib compression.  <br /></td></tr>
<tr class="separator:afa3bdf47e48bec2af069ef6fad851ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8468c798dfe1396f5ff6da798e1f7091" id="r_a8468c798dfe1396f5ff6da798e1f7091"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a8468c798dfe1396f5ff6da798e1f7091">CPLValidateXML</a> (const char *pszXMLFilename, const char *pszXSDFilename, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a8468c798dfe1396f5ff6da798e1f7091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a XML file against a XML schema.  <br /></td></tr>
<tr class="separator:a8468c798dfe1396f5ff6da798e1f7091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb928a33df2ec9f8dc0e4253c70bf09" id="r_a1eb928a33df2ec9f8dc0e4253c70bf09"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a1eb928a33df2ec9f8dc0e4253c70bf09">CPLsetlocale</a> (int category, const char *locale)</td></tr>
<tr class="memdesc:a1eb928a33df2ec9f8dc0e4253c70bf09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents parallel executions of setlocale().  <br /></td></tr>
<tr class="separator:a1eb928a33df2ec9f8dc0e4253c70bf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abced14d191c873be24e9d365cbf26cd9" id="r_abced14d191c873be24e9d365cbf26cd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#abced14d191c873be24e9d365cbf26cd9">CPLIsPowerOfTwo</a> (unsigned int i)</td></tr>
<tr class="separator:abced14d191c873be24e9d365cbf26cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf57353cbad5314c2be7e25e766bd570" id="r_acf57353cbad5314c2be7e25e766bd570"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:acf57353cbad5314c2be7e25e766bd570"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#acf57353cbad5314c2be7e25e766bd570">cpl::down_cast</a> (From *f)</td></tr>
<tr class="memdesc:acf57353cbad5314c2be7e25e766bd570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use cpl::down_cast&lt;Derived*&gt;(pointer_to_base) as equivalent of static_cast&lt;Derived*&gt;(pointer_to_base) with safe checking in debug mode.  <br /></td></tr>
<tr class="separator:acf57353cbad5314c2be7e25e766bd570"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Various convenience functions for CPL. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a42a6fd38f14a41bd51f6ca7f80aa78b2" name="a42a6fd38f14a41bd51f6ca7f80aa78b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a6fd38f14a41bd51f6ca7f80aa78b2">&#9670;&#160;</a></span>CPLAddFileInZip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> CPLAddFileInZip </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hZip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszArchiveFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszInputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fpInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pProgressFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a file inside a ZIP file opened/created with CPLCreateZip(). </p>
<p>This combines calls sto CPLCreateFileInZip(), CPLWriteFileInZip(), and CPLCloseFileInZip() in a more convenient and powerful way.</p>
<p>In particular, this enables to add a compressed file using the seek optimization extension.</p>
<p>Supported options are: </p><ul>
<li>
SOZIP_ENABLED=AUTO/YES/NO: whether to generate a SOZip index for the file. The default can be changed with the CPL_SOZIP_ENABLED configuration option. </li>
<li>
SOZIP_CHUNK_SIZE: chunk size to use for SOZip generation. Defaults to 32768.  </li>
<li>
SOZIP_MIN_FILE_SIZE: minimum file size to consider to enable SOZip index generation in SOZIP_ENABLED=AUTO mode. Defaults to 1 MB.  </li>
<li>
NUM_THREADS: number of threads used for SOZip generation. Defaults to ALL_CPUS. </li>
<li>
TIMESTAMP=AUTO/NOW/timestamp_as_epoch_since_jan_1_1970: in AUTO mode, the timestamp of pszInputFilename will be used (if available), otherwise it will fallback to NOW. </li>
<li>
CONTENT_TYPE=string: Content-Type value for the file. This is stored as a key-value pair in the extra field extension 'KV' (0x564b) dedicated to storing key-value pair metadata. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hZip</td><td>ZIP file handle </td></tr>
    <tr><td class="paramname">pszArchiveFilename</td><td>Filename (in UTF-8) stored in the archive. </td></tr>
    <tr><td class="paramname">pszInputFilename</td><td>Filename of the file to add. If NULL, fpInput must not be NULL </td></tr>
    <tr><td class="paramname">fpInput</td><td>File handle opened on the file to add. May be NULL if pszInputFilename is provided. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Options. </td></tr>
    <tr><td class="paramname">pProgressFunc</td><td>Progress callback, or NULL. </td></tr>
    <tr><td class="paramname">pProgressData</td><td>User data of progress callback, or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="afb5bf88066f997b1ab3b3911f5e9b722" name="afb5bf88066f997b1ab3b3911f5e9b722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5bf88066f997b1ab3b3911f5e9b722">&#9670;&#160;</a></span>CPLAtof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLAtof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. The behavior is the same as</p>
<p>CPLStrtod(nptr, (char **)NULL);</p>
<p>This function does the same as standard atof(3), but does not take locale in account. That means, the decimal delimiter is always '.' (decimal point). Use CPLAtofDelim() function if you want to specify custom delimiter.</p>
<p>IMPORTANT NOTE:</p>
<p>Existence of this function does not mean you should always use it. Sometimes you should use standard locale aware atof(3) and its family. When you need to process the user's input (for example, command line parameters) use atof(3), because the user works in a localized environment and the user's input will be done according to the locale set. In particular that means we should not make assumptions about character used as decimal delimiter, it can be either "." or ",".</p>
<p>But when you are parsing some ASCII file in predefined format, you most likely need CPLAtof(), because such files distributed across the systems with different locales and floating point representation should be considered as a part of file format. If the format uses "." as a delimiter the same character must be used when parsing number regardless of actual locale setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Pointer to string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a id="a0a01ca071035c36d4b4f85336e08c5d5" name="a0a01ca071035c36d4b4f85336e08c5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a01ca071035c36d4b4f85336e08c5d5">&#9670;&#160;</a></span>CPLAtofDelim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLAtofDelim </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. The behavior is the same as</p>
<p>CPLStrtodDelim(nptr, (char **)NULL, point);</p>
<p>This function does the same as standard atof(3), but does not take locale in account. Instead of locale defined decimal delimiter you can specify your own one. Also see notes for CPLAtof() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Pointer to string to convert. </td></tr>
    <tr><td class="paramname">point</td><td>Decimal delimiter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a id="aa07cd1b2aa5e76eb67ba952440198796" name="aa07cd1b2aa5e76eb67ba952440198796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07cd1b2aa5e76eb67ba952440198796">&#9670;&#160;</a></span>CPLAtofM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLAtofM </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts ASCII string to floating point number using any numeric locale. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard atof(), but it allows a variety of locale representations. That is it supports numeric values with either a comma or a period for the decimal delimiter.</p>
<p>PS. The M stands for Multi-lingual.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>The string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, if any. Zero on failure. </dd></dl>

</div>
</div>
<a id="aa35579a348f417a35965d6be69cde090" name="aa35579a348f417a35965d6be69cde090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35579a348f417a35965d6be69cde090">&#9670;&#160;</a></span>CPLAtoGIntBig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> CPLAtoGIntBig </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a 64 bit signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>String containing 64 bit signed integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64 bit signed integer. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a646aeb2044bf0ff4dace5793f17c11e8" name="a646aeb2044bf0ff4dace5793f17c11e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646aeb2044bf0ff4dace5793f17c11e8">&#9670;&#160;</a></span>CPLAtoGIntBigEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> CPLAtoGIntBigEx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bWarn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pbOverflow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a 64 bit signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>String containing 64 bit signed integer. </td></tr>
    <tr><td class="paramname">bWarn</td><td>Issue a warning if an overflow occurs during conversion </td></tr>
    <tr><td class="paramname">pbOverflow</td><td>Pointer to an integer to store if an overflow occurred, or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64 bit signed integer. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a615ef734360bf56561602f4e618e5d6d" name="a615ef734360bf56561602f4e618e5d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615ef734360bf56561602f4e618e5d6d">&#9670;&#160;</a></span>CPLCalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CPLCalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe version of calloc(). </p>
<p>This function is like the C library calloc(), but raises a CE_Fatal error with CPLError() if it fails to allocate the desired memory. It should be used for small memory allocations that are unlikely to fail and for which the application is unwilling to test for out of memory conditions. It uses <a class="el" href="cpl__vsi_8h.html#a3379ee2af145e6db40029afb7fa33fe5" title="Analog of calloc().">VSICalloc()</a> to get the memory, so any hooking of <a class="el" href="cpl__vsi_8h.html#a3379ee2af145e6db40029afb7fa33fe5" title="Analog of calloc().">VSICalloc()</a> will apply to CPLCalloc() as well. <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> or <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> can be used free memory allocated by CPLCalloc().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCount</td><td>number of objects to allocate. </td></tr>
    <tr><td class="paramname">nSize</td><td>size (in bytes) of object to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to newly allocated memory, only NULL if nSize * nCount is NULL. </dd></dl>

</div>
</div>
<a id="afa9b8f28ae84d5d898b7a3afc6bb6a4b" name="afa9b8f28ae84d5d898b7a3afc6bb6a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9b8f28ae84d5d898b7a3afc6bb6a4b">&#9670;&#160;</a></span>CPLCheckForFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLCheckForFile </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszSiblingFiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for file existence. </p>
<p>The function checks if a named file exists in the filesystem, hopefully in an efficient fashion if a sibling file list is available. It exists primarily to do faster file checking for functions like GDAL open methods that get a list of files from the target directory.</p>
<p>If the sibling file list exists (is not NULL) it is assumed to be a list of files in the same directory as the target file, and it will be checked (case insensitively) for a match. If a match is found, pszFilename is updated with the correct case and TRUE is returned.</p>
<p>If papszSiblingFiles is NULL, a <a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1" title="Get filesystem object info.">VSIStatL()</a> is used to test for the files existence, and no case insensitive testing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>name of file to check for - filename case updated in some cases. </td></tr>
    <tr><td class="paramname">papszSiblingFiles</td><td>a list of files in the same directory as pszFilename if available, or NULL. This list should have no path components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a match is found, or FALSE if not. </dd></dl>

</div>
</div>
<a id="a810d582548c7530c6b21894964e74618" name="a810d582548c7530c6b21894964e74618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810d582548c7530c6b21894964e74618">&#9670;&#160;</a></span>CPLCleanTrailingSlash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLCleanTrailingSlash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove trailing forward/backward slash from the path for UNIX/Windows resp. </p>
<p>Returns a string containing the portion of the passed path string with trailing slash removed. If there is no path in the passed filename an empty string will be returned (not NULL).</p>
<pre>
CPLCleanTrailingSlash( "abc/def/" ) == "abc/def"
CPLCleanTrailingSlash( "abc/def" ) == "abc/def"
CPLCleanTrailingSlash( "c:\\abc\\def\\" ) == "c:\abc\def"
CPLCleanTrailingSlash( "c:\abc\def" ) == "c:\abc\def"
CPLCleanTrailingSlash( "abc" ) == "abc"
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the path to be cleaned up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. </dd></dl>

</div>
</div>
<a id="a1afd2c936bbf27a74b02ae6dcadf25a7" name="a1afd2c936bbf27a74b02ae6dcadf25a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afd2c936bbf27a74b02ae6dcadf25a7">&#9670;&#160;</a></span>CPLCloseShared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLCloseShared </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close shared file. </p>
<p>Dereferences the indicated file handle, and closes it if the reference count has dropped to zero. A CPLError() is issued if the file is not in the shared file list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle from CPLOpenShared() to deaccess. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a0c8c75ac676b3f6efe8a0b14622a59" name="a6a0c8c75ac676b3f6efe8a0b14622a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0c8c75ac676b3f6efe8a0b14622a59">&#9670;&#160;</a></span>CPLCorrespondingPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CPLCorrespondingPaths </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszOldFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszFileList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify corresponding paths. </p>
<p>Given a prototype old and new filename this function will attempt to determine corresponding names for a set of other old filenames that will rename them in a similar manner. This correspondence assumes there are two possibly kinds of renaming going on. A change of path, and a change of filename stem.</p>
<p>If a consistent renaming cannot be established for all the files this function will return indicating an error.</p>
<p>The returned file list becomes owned by the caller and should be destroyed with CSLDestroy().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszOldFilename</td><td>path to old prototype file. </td></tr>
    <tr><td class="paramname">pszNewFilename</td><td>path to new prototype file. </td></tr>
    <tr><td class="paramname">papszFileList</td><td>list of other files associated with pszOldFilename to rename similarly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of files corresponding to papszFileList but renamed to correspond to pszNewFilename. </dd></dl>

</div>
</div>
<a id="a97b69cc886a1a5c9618612d8205600e4" name="a97b69cc886a1a5c9618612d8205600e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b69cc886a1a5c9618612d8205600e4">&#9670;&#160;</a></span>CPLDecToPackedDMS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLDecToPackedDMS </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert decimal degrees into packed DMS value (DDDMMMSSS.SS). </p>
<p>This function converts a value, specified in decimal degrees into packed DMS angle. The standard packed DMS format is:</p>
<p>degrees * 1000000 + minutes * 1000 + seconds</p>
<p>See also CPLPackedDMSToDec().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfDec</td><td>Angle in decimal degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle in packed DMS format. </dd></dl>

</div>
</div>
<a id="aa7709a32d13e10f2c6c28a176b5a8784" name="aa7709a32d13e10f2c6c28a176b5a8784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7709a32d13e10f2c6c28a176b5a8784">&#9670;&#160;</a></span>CPLDumpSharedList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLDumpSharedList </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report open shared files. </p>
<p>Dumps all open shared files to the indicated file handle. If the file handle is NULL information is sent via the CPLDebug() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>File handle to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a058f8e51ea0e81bf761ad87d89626cc6" name="a058f8e51ea0e81bf761ad87d89626cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058f8e51ea0e81bf761ad87d89626cc6">&#9670;&#160;</a></span>CPLExpandTilde()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLExpandTilde </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands ~/ at start of filename. </p>
<p>Assumes that the HOME configuration option is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>filename potentially starting with ~/</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an expanded filename.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a97d87a1e45e214e11ca977e77431caaa" name="a97d87a1e45e214e11ca977e77431caaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d87a1e45e214e11ca977e77431caaa">&#9670;&#160;</a></span>CPLExtractRelativePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLExtractRelativePath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszBaseDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pbGotRelative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get relative path from directory to target file. </p>
<p>Computes a relative path for pszTarget relative to pszBaseDir. Currently this only works if they share a common base path. The returned path is normally into the pszTarget string. It should only be considered valid as long as pszTarget is valid or till the next call to this function, whichever comes first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszBaseDir</td><td>the name of the directory relative to which the path should be computed. pszBaseDir may be NULL in which case the original target is returned without relativizing.</td></tr>
    <tr><td class="paramname">pszTarget</td><td>the filename to be changed to be relative to pszBaseDir.</td></tr>
    <tr><td class="paramname">pbGotRelative</td><td>Pointer to location in which a flag is placed indicating that the returned path is relative to the basename (TRUE) or not (FALSE). This pointer may be NULL if flag is not desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an adjusted path or the original if it could not be made relative to the pszBaseFile's path. </dd></dl>

</div>
</div>
<a id="aa25077ce43ee5c167c082daf058efed9" name="aa25077ce43ee5c167c082daf058efed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25077ce43ee5c167c082daf058efed9">&#9670;&#160;</a></span>CPLFGets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLFGets </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads in at most one less than nBufferSize characters from the fp stream and stores them into the buffer pointed to by pszBuffer. </p>
<p>Reading stops after an EOF or a newline. If a newline is read, it is <em>not</em> stored into the buffer. A '\0' is stored after the last character in the buffer. All three types of newline terminators recognized by the CPLFGets(): single '\r' and '\n' and '\r\n' combination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszBuffer</td><td>pointer to the targeting character buffer. </td></tr>
    <tr><td class="paramname">nBufferSize</td><td>maximum size of the string to read (not including terminating '\0'). </td></tr>
    <tr><td class="paramname">fp</td><td>file pointer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the pszBuffer containing a string read from the file or NULL if the error or end of file was encountered. </dd></dl>

</div>
</div>
<a id="a54fe427bdefcb71a82023259a5df4566" name="a54fe427bdefcb71a82023259a5df4566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fe427bdefcb71a82023259a5df4566">&#9670;&#160;</a></span>CPLFormCIFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLFormCIFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszBasename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszExtension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Case insensitive file searching, returning full path. </p>
<p>This function tries to return the path to a file regardless of whether the file exactly matches the basename, and extension case, or is all upper case, or all lower case. The path is treated as case sensitive. This function is equivalent to CPLFormFilename() on case insensitive file systems (like Windows).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>directory path to the directory containing the file. This may be relative or absolute, and may have a trailing path separator or not. May be NULL.</td></tr>
    <tr><td class="paramname">pszBasename</td><td>file basename. May optionally have path and/or extension. May not be NULL.</td></tr>
    <tr><td class="paramname">pszExtension</td><td>file extension, optionally including the period. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a fully formed filename in an internal static string. Do not modify or free the returned string. The string may be destroyed by the next CPL call. </dd></dl>

</div>
</div>
<a id="ad607f638b801165e4d095ab2241713f1" name="ad607f638b801165e4d095ab2241713f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad607f638b801165e4d095ab2241713f1">&#9670;&#160;</a></span>CPLFormFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLFormFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszBasename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszExtension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a full file path from a passed path, file basename and extension. </p>
<p>The path, and extension are optional. The basename may in fact contain an extension if desired.</p>
<pre>
CPLFormFilename("abc/xyz", "def", ".dat" ) == "abc/xyz/def.dat"
CPLFormFilename(NULL,"def", NULL ) == "def"
CPLFormFilename(NULL, "abc/def.dat", NULL ) == "abc/def.dat"
CPLFormFilename("/abc/xyz/", "def.dat", NULL ) == "/abc/xyz/def.dat"
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>directory path to the directory containing the file. This may be relative or absolute, and may have a trailing path separator or not. May be NULL.</td></tr>
    <tr><td class="paramname">pszBasename</td><td>file basename. May optionally have path and/or extension. Must <em>NOT</em> be NULL.</td></tr>
    <tr><td class="paramname">pszExtension</td><td>file extension, optionally including the period. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a fully formed filename in an internal static string. Do not modify or free the returned string. The string may be destroyed by the next CPL call. </dd></dl>

</div>
</div>
<a id="a675f0de81458be686a733915b04370ec" name="a675f0de81458be686a733915b04370ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675f0de81458be686a733915b04370ec">&#9670;&#160;</a></span>CPLGenerateTempFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLGenerateTempFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate temporary file name. </p>
<p>Returns a filename that may be used for a temporary file. The location of the file tries to follow operating system semantics but may be forced via the CPL_TMPDIR configuration option.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszStem</td><td>if non-NULL this will be part of the filename.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a filename which is valid till the next CPL call in this thread. </dd></dl>

</div>
</div>
<a id="a3f66be126835aed96d00fef83737d062" name="a3f66be126835aed96d00fef83737d062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f66be126835aed96d00fef83737d062">&#9670;&#160;</a></span>CPLGetBasename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLGetBasename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFullFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract basename (non-directory, non-extension) portion of filename. </p>
<p>Returns a string containing the file basename portion of the passed name. If there is no basename (passed value ends in trailing directory separator, or filename starts with a dot) an empty string is returned.</p>
<pre>
CPLGetBasename( "abc/def.xyz" ) == "def"
CPLGetBasename( "abc/def" ) == "def"
CPLGetBasename( "abc/def/" ) == ""
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFullFilename</td><td>the full filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>just the non-directory, non-extension portion of the path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. </dd></dl>

</div>
</div>
<a id="abf7397078083b0a6a3f40c5394d18189" name="abf7397078083b0a6a3f40c5394d18189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7397078083b0a6a3f40c5394d18189">&#9670;&#160;</a></span>CPLGetConfigOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLGetConfigOption </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a configuration option. </p>
<p>The value is the value of a (key, value) option set with CPLSetConfigOption(), or CPLSetThreadLocalConfigOption() of the same thread. If the given option was no defined with CPLSetConfigOption(), it tries to find it in environment variables.</p>
<p>Note: the string returned by CPLGetConfigOption() might be short-lived, and in particular it will become invalid after a call to CPLSetConfigOption() with the same key.</p>
<p>To override temporary a potentially existing option with a new value, you can use the following snippet : </p><pre>
    // backup old value
    const char* pszOldValTmp = CPLGetConfigOption(pszKey, NULL);
    char* pszOldVal = pszOldValTmp ? CPLStrdup(pszOldValTmp) : NULL;
    // override with new value
    CPLSetConfigOption(pszKey, pszNewVal);
    // do something useful
    // restore old value
    CPLSetConfigOption(pszKey, pszOldVal);
    <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree(pszOldVal)</a>;
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszKey</td><td>the key of the option to retrieve </td></tr>
    <tr><td class="paramname">pszDefault</td><td>a default value if the key does not match existing defined options (may be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value associated to the key, or the default value if not found</dd></dl>
<dl class="section see"><dt>See also</dt><dd>CPLSetConfigOption(), <a href="http://trac.osgeo.org/gdal/wiki/ConfigOptions">http://trac.osgeo.org/gdal/wiki/ConfigOptions</a> </dd></dl>

</div>
</div>
<a id="a7a0ef62eb12171502caf782ddf94068e" name="a7a0ef62eb12171502caf782ddf94068e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0ef62eb12171502caf782ddf94068e">&#9670;&#160;</a></span>CPLGetConfigOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CPLGetConfigOptions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of configuration options as KEY=VALUE pairs. </p>
<p>The list is the one set through the CPLSetConfigOption() API.</p>
<p>Options that through environment variables or with CPLSetThreadLocalConfigOption() will <em>not</em> be listed.</p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the list, to be freed with CSLDestroy(). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a90300b2a945c160440bd173624f1ab93" name="a90300b2a945c160440bd173624f1ab93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90300b2a945c160440bd173624f1ab93">&#9670;&#160;</a></span>CPLGetCurrentDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLGetCurrentDir </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current working directory name. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to buffer, containing current working directory path or NULL in case of error. User is responsible to free that buffer after usage with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> function. If HAVE_GETCWD macro is not defined, the function returns NULL. </dd></dl>

</div>
</div>
<a id="a41d9a3d3b8262b907411a30119e4ba4b" name="a41d9a3d3b8262b907411a30119e4ba4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d9a3d3b8262b907411a30119e4ba4b">&#9670;&#160;</a></span>CPLGetDirname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLGetDirname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract directory path portion of filename. </p>
<p>Returns a string containing the directory path portion of the passed filename. If there is no path in the passed filename the dot will be returned. It is the only difference from CPLGetPath().</p>
<pre>
CPLGetDirname( "abc/def.xyz" ) == "abc"
CPLGetDirname( "/abc/def/" ) == "/abc/def"
CPLGetDirname( "/" ) == "/"
CPLGetDirname( "/abc/def" ) == "/abc"
CPLGetDirname( "abc" ) == "."
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. The returned will generally not contain a trailing path separator. </dd></dl>

</div>
</div>
<a id="a5325c900de0918020b747ed07d98da24" name="a5325c900de0918020b747ed07d98da24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5325c900de0918020b747ed07d98da24">&#9670;&#160;</a></span>CPLGetExecPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLGetExecPath </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszPathBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch path of executable. </p>
<p>The path to the executable currently running is returned. This path includes the name of the executable. Currently this only works on Windows, Linux, MacOS and FreeBSD platforms. The returned path is UTF-8 encoded, and will be nul-terminated if success is reported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPathBuf</td><td>the buffer into which the path is placed. </td></tr>
    <tr><td class="paramname">nMaxLength</td><td>the buffer size (including the nul-terminating character). MAX_PATH+1 is suggested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE on failure or TRUE on success. </dd></dl>

</div>
</div>
<a id="a25caa4bc87e8cd71cdf1833e5d57f36b" name="a25caa4bc87e8cd71cdf1833e5d57f36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25caa4bc87e8cd71cdf1833e5d57f36b">&#9670;&#160;</a></span>CPLGetExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLGetExtension </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFullFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract filename extension from full filename. </p>
<p>Returns a string containing the extension portion of the passed name. If there is no extension (the filename has no dot) an empty string is returned. The returned extension will not include the period.</p>
<pre>
CPLGetExtension( "abc/def.xyz" ) == "xyz"
CPLGetExtension( "abc/def" ) == ""
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFullFilename</td><td>the full filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>just the extension portion of the path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. </dd></dl>

</div>
</div>
<a id="acfe9c7c2a5d9ddc4854b2a54ab0884f9" name="acfe9c7c2a5d9ddc4854b2a54ab0884f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe9c7c2a5d9ddc4854b2a54ab0884f9">&#9670;&#160;</a></span>CPLGetFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLGetFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFullFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract non-directory portion of filename. </p>
<p>Returns a string containing the bare filename portion of the passed filename. If there is no filename (passed value ends in trailing directory separator) an empty string is returned.</p>
<pre>
CPLGetFilename( "abc/def.xyz" ) == "def.xyz"
CPLGetFilename( "/abc/def/" ) == ""
CPLGetFilename( "abc/def" ) == "def"
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFullFilename</td><td>the full filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>just the non-directory portion of the path (points back into original string). </dd></dl>

</div>
</div>
<a id="a86a343de18825ab7f159a3e666e62fa6" name="a86a343de18825ab7f159a3e666e62fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a343de18825ab7f159a3e666e62fa6">&#9670;&#160;</a></span>CPLGetGlobalConfigOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLGetGlobalConfigOption </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as CPLGetConfigOption() but excludes environment variables and options set with CPLSetThreadLocalConfigOption(). </p>
<p>This function should generally not be used by applications, which should use CPLGetConfigOption() instead. </p><dl class="section since"><dt>Since</dt><dd>3.8 </dd></dl>

</div>
</div>
<a id="a02e35ea9017f4f7dbc818b52a287e082" name="a02e35ea9017f4f7dbc818b52a287e082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e35ea9017f4f7dbc818b52a287e082">&#9670;&#160;</a></span>CPLGetHomeDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLGetHomeDir </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the path to the home directory. </p>
<p>That is the value of the USERPROFILE environment variable on Windows, or HOME on other platforms.</p>
<dl class="section return"><dt>Returns</dt><dd>the home directory, or NULL.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a69baba7d6823844a3b435e4095e7ea9c" name="a69baba7d6823844a3b435e4095e7ea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69baba7d6823844a3b435e4095e7ea9c">&#9670;&#160;</a></span>CPLGetPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLGetPath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract directory path portion of filename. </p>
<p>Returns a string containing the directory path portion of the passed filename. If there is no path in the passed filename an empty string will be returned (not NULL).</p>
<pre>
CPLGetPath( "abc/def.xyz" ) == "abc"
CPLGetPath( "/abc/def/" ) == "/abc/def"
CPLGetPath( "/" ) == "/"
CPLGetPath( "/abc/def" ) == "/abc"
CPLGetPath( "abc" ) == ""
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. The returned will generally not contain a trailing path separator. </dd></dl>

</div>
</div>
<a id="afacced4f4d48b4442b2bdbe08db4d3c0" name="afacced4f4d48b4442b2bdbe08db4d3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacced4f4d48b4442b2bdbe08db4d3c0">&#9670;&#160;</a></span>CPLGetSharedList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLSharedFileInfo.html">CPLSharedFileInfo</a> * CPLGetSharedList </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch list of open shared files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnCount</td><td>place to put the count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the first in the array of shared file info structures. </dd></dl>

</div>
</div>
<a id="a0c8e54bbbdd75f6315fe2fafd3d5259f" name="a0c8e54bbbdd75f6315fe2fafd3d5259f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8e54bbbdd75f6315fe2fafd3d5259f">&#9670;&#160;</a></span>CPLGetSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CPLGetSymbol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSymbolName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a function pointer from a shared library / DLL. </p>
<p>This function is meant to abstract access to shared libraries and DLLs and performs functions similar to dlopen()/dlsym() on Unix and LoadLibrary() / GetProcAddress() on Windows.</p>
<p>If no support for loading entry points from a shared library is available this function will always return NULL. Rules on when this function issues a CPLError() or not are not currently well defined, and will have to be resolved in the future.</p>
<p>Currently CPLGetSymbol() doesn't try to: </p><ul>
<li>
prevent the reference count on the library from going up for every request, or given any opportunity to unload the library. </li>
<li>
Attempt to look for the library in non-standard locations. </li>
<li>
Attempt to try variations on the symbol name, like pre-pending or post-pending an underscore. </li>
</ul>
<p>Some of these issues may be worked on in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszLibrary</td><td>the name of the shared library or DLL containing the function. May contain path to file. If not system supplies search paths will be used. </td></tr>
    <tr><td class="paramname">pszSymbolName</td><td>the name of the function to fetch a pointer to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the function if found, or NULL if the function isn't found, or the shared library can't be loaded. </dd></dl>

</div>
</div>
<a id="a2e0940a292a3259ca6429dcc52b7eec7" name="a2e0940a292a3259ca6429dcc52b7eec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0940a292a3259ca6429dcc52b7eec7">&#9670;&#160;</a></span>CPLGetThreadLocalConfigOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CPLGetThreadLocalConfigOptions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of thread local configuration options as KEY=VALUE pairs. </p>
<p>Options that through environment variables or with CPLSetConfigOption() will <em>not</em> be listed.</p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the list, to be freed with CSLDestroy(). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a0cd8ae8d760125ec5b01958a776691ec" name="a0cd8ae8d760125ec5b01958a776691ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd8ae8d760125ec5b01958a776691ec">&#9670;&#160;</a></span>CPLIsFilenameRelative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLIsFilenameRelative </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is filename relative or absolute? </p>
<p>The test is filesystem convention agnostic. That is it will test for Unix style and windows style path conventions regardless of the actual system in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the filename with path to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the filename is relative or FALSE if it is absolute. </dd></dl>

</div>
</div>
<a id="abced14d191c873be24e9d365cbf26cd9" name="abced14d191c873be24e9d365cbf26cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abced14d191c873be24e9d365cbf26cd9">&#9670;&#160;</a></span>CPLIsPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLIsPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="cpl__conv_8h.html#abced14d191c873be24e9d365cbf26cd9">CPLIsPowerOfTwo()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>- tested number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if i is power of two otherwise return FALSE </dd></dl>

</div>
</div>
<a id="a412f3eb3eaaed0e51fa4f882a77d9833" name="a412f3eb3eaaed0e51fa4f882a77d9833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412f3eb3eaaed0e51fa4f882a77d9833">&#9670;&#160;</a></span>CPLLaunderForFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLLaunderForFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszOutputPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launder a string to be compatible of a filename. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>The input string to launder. </td></tr>
    <tr><td class="paramname">pszOutputPath</td><td>The directory where the file would be created. Unused for now. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the laundered name.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
<a id="a274ec722cbcba36b84a6c69e72bdb8d1" name="a274ec722cbcba36b84a6c69e72bdb8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274ec722cbcba36b84a6c69e72bdb8d1">&#9670;&#160;</a></span>CPLLoadConfigOptionsFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLLoadConfigOptionsFromFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bOverrideEnvVars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load configuration from a given configuration file. </p>
<p>A configuration file is a text file in a .ini style format, that lists configuration options and their values. Lines starting with # are comment lines.</p>
<p>Example: </p><pre class="fragment">[configoptions]
# set BAR as the value of configuration option FOO
FOO=BAR
</pre><p>Starting with GDAL 3.5, a configuration file can also contain credentials (or more generally options related to a virtual file system) for a given path prefix, that can also be set with <a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f" title="Set a path specific option for a given path prefix.">VSISetPathSpecificOption()</a>. Credentials should be put under a [credentials] section, and for each path prefix, under a relative subsection whose name starts with "[." (e.g. "[.some_arbitrary_name]"), and whose first key is "path".</p>
<p>Example: </p><pre class="fragment">[credentials]

[.private_bucket]
path=/vsis3/my_private_bucket
AWS_SECRET_ACCESS_KEY=...
AWS_ACCESS_KEY_ID=...

[.sentinel_s2_l1c]
path=/vsis3/sentinel-s2-l1c
AWS_REQUEST_PAYER=requester
</pre><p>Starting with GDAL 3.6, a leading [directives] section might be added with a "ignore-env-vars=yes" setting to indicate that, starting with that point, all environment variables should be ignored, and only configuration options defined in the [configoptions] sections or through the CPLSetConfigOption() / CPLSetThreadLocalConfigOption() functions should be taken into account.</p>
<p>This function is typically called by CPLLoadConfigOptionsFromPredefinedFiles()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>File where to load configuration from. </td></tr>
    <tr><td class="paramname">bOverrideEnvVars</td><td>Whether configuration options from the configuration file should override environment variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a79f793111568325fbee2cbd636275cfd" name="a79f793111568325fbee2cbd636275cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f793111568325fbee2cbd636275cfd">&#9670;&#160;</a></span>CPLLoadConfigOptionsFromPredefinedFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLLoadConfigOptionsFromPredefinedFiles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load configuration from a set of predefined files. </p>
<p>If the environment variable (or configuration option) GDAL_CONFIG_FILE is set, then CPLLoadConfigOptionsFromFile() will be called with the value of this configuration option as the file location.</p>
<p>Otherwise, for Unix builds, CPLLoadConfigOptionsFromFile() will be called with ${sysconfdir}/gdal/gdalrc first where ${sysconfdir} evaluates to ${prefix}/etc, unless the &ndash;sysconfdir switch of configure has been invoked.</p>
<p>Then CPLLoadConfigOptionsFromFile() will be called with /github/home/.gdal/gdalrc on Unix builds (potentially overriding what was loaded with the sysconfdir) or /.gdal/gdalrc on Windows builds.</p>
<p>CPLLoadConfigOptionsFromFile() will be called with bOverrideEnvVars = false, that is the value of environment variables previously set will be used instead of the value set in the configuration files (unless the configuration file contains a leading [directives] section with a "ignore-env-vars=yes" setting).</p>
<p>This function is automatically called by <a class="el" href="classGDALDriverManager.html" title="Class for managing the registration of file format drivers.">GDALDriverManager()</a> constructor</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a41a6745dd4349e841f6226316864b77f" name="a41a6745dd4349e841f6226316864b77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a6745dd4349e841f6226316864b77f">&#9670;&#160;</a></span>CPLMalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CPLMalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe version of malloc(). </p>
<p>This function is like the C library malloc(), but raises a CE_Fatal error with CPLError() if it fails to allocate the desired memory. It should be used for small memory allocations that are unlikely to fail and for which the application is unwilling to test for out of memory conditions. It uses <a class="el" href="cpl__vsi_8h.html#ae9a82ea30d463c41a2f9ac4b116547d6" title="Analog of malloc().">VSIMalloc()</a> to get the memory, so any hooking of <a class="el" href="cpl__vsi_8h.html#ae9a82ea30d463c41a2f9ac4b116547d6" title="Analog of malloc().">VSIMalloc()</a> will apply to CPLMalloc() as well. <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> or <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> can be used free memory allocated by CPLMalloc().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSize</td><td>size (in bytes) of memory block to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to newly allocated memory, only NULL if nSize is zero. </dd></dl>

</div>
</div>
<a id="a8e97efa26bbe4ff3a7b8a0bdf3cd5f6f" name="a8e97efa26bbe4ff3a7b8a0bdf3cd5f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e97efa26bbe4ff3a7b8a0bdf3cd5f6f">&#9670;&#160;</a></span>CPLOpenShared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE * CPLOpenShared </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bLargeIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a shared file handle. </p>
<p>Some operating systems have limits on the number of file handles that can be open at one time. This function attempts to maintain a registry of already open file handles, and reuse existing ones if the same file is requested by another part of the application.</p>
<p>Note that access is only shared for access types "r", "rb", "r+" and "rb+". All others will just result in direct VSIOpen() calls. Keep in mind that a file is only reused if the file name is exactly the same. Different names referring to the same file will result in different handles.</p>
<p>The VSIFOpen() or <a class="el" href="cpl__vsi_8h.html#ab39f3147cdfa16848ed5b81d5293e27f" title="Open file.">VSIFOpenL()</a> function is used to actually open the file, when an existing file handle can't be shared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the name of the file to open. </td></tr>
    <tr><td class="paramname">pszAccess</td><td>the normal fopen()/VSIFOpen() style access string. </td></tr>
    <tr><td class="paramname">bLargeIn</td><td>If TRUE <a class="el" href="cpl__vsi_8h.html#ab39f3147cdfa16848ed5b81d5293e27f" title="Open file.">VSIFOpenL()</a> (for large files) will be used instead of VSIFOpen().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a file handle or NULL if opening fails. </dd></dl>

</div>
</div>
<a id="aa4ffc8fd25881635e18d1a53e177a8e1" name="aa4ffc8fd25881635e18d1a53e177a8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ffc8fd25881635e18d1a53e177a8e1">&#9670;&#160;</a></span>CPLPackedDMSToDec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLPackedDMSToDec </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfPacked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a packed DMS value (DDDMMMSSS.SS) into decimal degrees. </p>
<p>This function converts a packed DMS angle to seconds. The standard packed DMS format is:</p>
<p>degrees * 1000000 + minutes * 1000 + seconds</p>
<p>Example: angle = 120025045.25 yields deg = 120 min = 25 sec = 45.25</p>
<p>The algorithm used for the conversion is as follows:</p>
<ol type="1">
<li>The absolute value of the angle is used.</li>
<li>The degrees are separated out: deg = angle/1000000 (fractional portion truncated)</li>
<li>The minutes are separated out: min = (angle - deg * 1000000) / 1000 (fractional portion truncated)</li>
<li>The seconds are then computed: sec = angle - deg * 1000000 - min * 1000</li>
<li>The total angle in seconds is computed: sec = deg * 3600.0 + min * 60.0 + sec</li>
<li>The sign of sec is set to that of the input angle.</li>
</ol>
<p>Packed DMS values used by the USGS GCTP package and probably by other software.</p>
<p>NOTE: This code does not validate input value. If you give the wrong value, you will get the wrong result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfPacked</td><td>Angle in packed DMS format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle in decimal degrees. </dd></dl>

</div>
</div>
<a id="ad77e478b4f2e14cc03ae23a9c81434c9" name="ad77e478b4f2e14cc03ae23a9c81434c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77e478b4f2e14cc03ae23a9c81434c9">&#9670;&#160;</a></span>CPLPrintDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintDouble </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszLocale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print double value into specified string buffer. </p>
<p>Exponential character flag 'E' (or 'e') will be replaced with 'D', as in Fortran. Resulting string will not to be NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszBuffer</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td class="paramname">pszFormat</td><td>Format specifier (for example, "%16.9E").</td></tr>
    <tr><td class="paramname">dfValue</td><td>Numerical value to print.</td></tr>
    <tr><td class="paramname">pszLocale</td><td>Unused.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a id="a33618500e56ec12e6775b3ed9014b8fb" name="a33618500e56ec12e6775b3ed9014b8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33618500e56ec12e6775b3ed9014b8fb">&#9670;&#160;</a></span>CPLPrintInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintInt32 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af19adaeb9a6dd7c664fc6f79e426854a">GInt32</a>&#160;</td>
          <td class="paramname"><em>iValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print GInt32 value into specified string buffer. </p>
<p>This string will not be NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszBuffer</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td class="paramname">iValue</td><td>Numerical value to print.</td></tr>
    <tr><td class="paramname">nMaxLen</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a id="af268becc479787ae48bb2607d0000886" name="af268becc479787ae48bb2607d0000886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af268becc479787ae48bb2607d0000886">&#9670;&#160;</a></span>CPLPrintPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintPointer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print pointer value into specified string buffer. </p>
<p>This string will not be NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszBuffer</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td class="paramname">pValue</td><td>Pointer to ASCII encode.</td></tr>
    <tr><td class="paramname">nMaxLen</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a id="ae284b3e504edca3eb1eaf568469d61ba" name="ae284b3e504edca3eb1eaf568469d61ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae284b3e504edca3eb1eaf568469d61ba">&#9670;&#160;</a></span>CPLPrintString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the string pointed to by pszSrc, NOT including the terminating &lsquo;\0&rsquo; character, to the array pointed to by pszDest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDest</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string.</td></tr>
    <tr><td class="paramname">pszSrc</td><td>Pointer to the source buffer.</td></tr>
    <tr><td class="paramname">nMaxLen</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a id="a0bdbcb209eb9b8e2e6be4fa6e0b750f6" name="a0bdbcb209eb9b8e2e6be4fa6e0b750f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdbcb209eb9b8e2e6be4fa6e0b750f6">&#9670;&#160;</a></span>CPLPrintStringFill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintStringFill </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the string pointed to by pszSrc, NOT including the terminating &lsquo;\0&rsquo; character, to the array pointed to by pszDest. </p>
<p>Remainder of the destination string will be filled with space characters. This is only difference from the PrintString().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDest</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string.</td></tr>
    <tr><td class="paramname">pszSrc</td><td>Pointer to the source buffer.</td></tr>
    <tr><td class="paramname">nMaxLen</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a id="a5be9cf1de05769139a77339ffb970ce4" name="a5be9cf1de05769139a77339ffb970ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be9cf1de05769139a77339ffb970ce4">&#9670;&#160;</a></span>CPLPrintTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintTime </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>poBrokenTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszLocale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print specified time value accordingly to the format options and specified locale name. </p>
<p>This function does following:</p>
<ul>
<li>if locale parameter is not NULL, the current locale setting will be stored and replaced with the specified one;</li>
<li>format time value with the strftime(3) function;</li>
<li>restore back current locale, if was saved.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszBuffer</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td class="paramname">nMaxLen</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
    <tr><td class="paramname">pszFormat</td><td>Controls the output format. Options are the same as for strftime(3) function.</td></tr>
    <tr><td class="paramname">poBrokenTime</td><td>Pointer to the broken-down time structure. May be requested with the VSIGMTime() and VSILocalTime() functions.</td></tr>
    <tr><td class="paramname">pszLocale</td><td>Pointer to a character string containing locale name ("C", "POSIX", "us_US", "ru_RU.KOI8-R" etc.). If NULL we will not manipulate with locale settings and current process locale will be used for printing. Be aware that it may be unsuitable to use current locale for printing time, because all names will be printed in your native language, as well as time format settings also may be adjusted differently from the C/POSIX defaults. To solve these problems this option was introduced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a id="a13ca1da1151489f1eee7770296f164aa" name="a13ca1da1151489f1eee7770296f164aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ca1da1151489f1eee7770296f164aa">&#9670;&#160;</a></span>CPLPrintUIntBig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintUIntBig </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#a4f0794a0fb78d55ba284a414191dbc93">GUIntBig</a>&#160;</td>
          <td class="paramname"><em>iValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print GUIntBig value into specified string buffer. </p>
<p>This string will not be NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszBuffer</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td class="paramname">iValue</td><td>Numerical value to print.</td></tr>
    <tr><td class="paramname">nMaxLen</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a id="ab20697f44daa7a35f22568f4621c94fd" name="ab20697f44daa7a35f22568f4621c94fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20697f44daa7a35f22568f4621c94fd">&#9670;&#160;</a></span>CPLProjectRelativeFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLProjectRelativeFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszProjectDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSecondaryFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a file relative to a project file. </p>
<p>Given the path to a "project" directory, and a path to a secondary file referenced from that project, build a path to the secondary file that the current application can use. If the secondary path is already absolute, rather than relative, then it will be returned unaltered.</p>
<p>Examples: </p><pre>
CPLProjectRelativeFilename("abc/def", "tmp/abc.gif") == "abc/def/tmp/abc.gif"
CPLProjectRelativeFilename("abc/def", "/tmp/abc.gif") == "/tmp/abc.gif"
CPLProjectRelativeFilename("/xy", "abc.gif") == "/xy/abc.gif"
CPLProjectRelativeFilename("/abc/def", "../abc.gif") == "/abc/def/../abc.gif"
CPLProjectRelativeFilename("C:\WIN", "abc.gif") == "C:\WIN\abc.gif"
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszProjectDir</td><td>the directory relative to which the secondary files path should be interpreted. </td></tr>
    <tr><td class="paramname">pszSecondaryFilename</td><td>the filename (potentially with path) that is to be interpreted relative to the project directory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a composed path to the secondary file. The returned string is internal and should not be altered, freed, or depending on past the next CPL call. </dd></dl>

</div>
</div>
<a id="a81e7715662844e90ce7ffef8f583c2a0" name="a81e7715662844e90ce7ffef8f583c2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e7715662844e90ce7ffef8f583c2a0">&#9670;&#160;</a></span>CPLReadLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLReadLine </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplified line reading from text file. </p>
<p>Read a line of text from the given file handle, taking care to capture CR and/or LF and strip off ... equivalent of DKReadLine(). Pointer to an internal buffer is returned. The application shouldn't free it, or depend on its value past the next call to CPLReadLine().</p>
<p>Note that CPLReadLine() uses VSIFGets(), so any hooking of VSI file services should apply to CPLReadLine() as well.</p>
<p>CPLReadLine() maintains an internal buffer, which will appear as a single block memory leak in some circumstances. CPLReadLine() may be called with a NULL FILE * at any time to free this working buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file pointer opened with VSIFOpen().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered. </dd></dl>

</div>
</div>
<a id="a1120e4956b845683116e05db9c48ccaa" name="a1120e4956b845683116e05db9c48ccaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1120e4956b845683116e05db9c48ccaa">&#9670;&#160;</a></span>CPLReadLine2L()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLReadLine2L </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxCars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplified line reading from text file. </p>
<p>Similar to CPLReadLine(), but reading from a large file API handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file pointer opened with <a class="el" href="cpl__vsi_8h.html#ab39f3147cdfa16848ed5b81d5293e27f" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">nMaxCars</td><td>maximum number of characters allowed, or -1 for no limit. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated array of options. Unused for now.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered or the maximum number of characters allowed reached.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a id="a210463648ec02bfee33cb804f499f7ca" name="a210463648ec02bfee33cb804f499f7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210463648ec02bfee33cb804f499f7ca">&#9670;&#160;</a></span>CPLReadLine3L()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLReadLine3L </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxCars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBufLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplified line reading from text file. </p>
<p>Similar to CPLReadLine(), but reading from a large file API handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fp</td><td>file pointer opened with <a class="el" href="cpl__vsi_8h.html#ab39f3147cdfa16848ed5b81d5293e27f" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nMaxCars</td><td>maximum number of characters allowed, or -1 for no limit. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">papszOptions</td><td>NULL-terminated array of options. Unused for now. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pnBufLength</td><td>size of output string (must be non-NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered or the maximum number of characters allowed reached.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3.0 </dd></dl>

</div>
</div>
<a id="a81662c4f48df1e6ae0c7ca9fb403401d" name="a81662c4f48df1e6ae0c7ca9fb403401d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81662c4f48df1e6ae0c7ca9fb403401d">&#9670;&#160;</a></span>CPLReadLineL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLReadLineL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplified line reading from text file. </p>
<p>Similar to CPLReadLine(), but reading from a large file API handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file pointer opened with <a class="el" href="cpl__vsi_8h.html#ab39f3147cdfa16848ed5b81d5293e27f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered. </dd></dl>

</div>
</div>
<a id="a3636f780de6227634b629f2675f0e53e" name="a3636f780de6227634b629f2675f0e53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3636f780de6227634b629f2675f0e53e">&#9670;&#160;</a></span>CPLRealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CPLRealloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nNewSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe version of realloc(). </p>
<p>This function is like the C library realloc(), but raises a CE_Fatal error with CPLError() if it fails to allocate the desired memory. It should be used for small memory allocations that are unlikely to fail and for which the application is unwilling to test for out of memory conditions. It uses <a class="el" href="cpl__vsi_8h.html#a6f63bee2a22994ea8a800628b4a0bfa1" title="Analog of realloc().">VSIRealloc()</a> to get the memory, so any hooking of <a class="el" href="cpl__vsi_8h.html#a6f63bee2a22994ea8a800628b4a0bfa1" title="Analog of realloc().">VSIRealloc()</a> will apply to CPLRealloc() as well. <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> or <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> can be used free memory allocated by CPLRealloc().</p>
<p>It is also safe to pass NULL in as the existing memory block for CPLRealloc(), in which case it uses <a class="el" href="cpl__vsi_8h.html#ae9a82ea30d463c41a2f9ac4b116547d6" title="Analog of malloc().">VSIMalloc()</a> to allocate a new block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>existing memory block which should be copied to the new block. </td></tr>
    <tr><td class="paramname">nNewSize</td><td>new size (in bytes) of memory block to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated memory, only NULL if nNewSize is zero. </dd></dl>

</div>
</div>
<a id="a86b9a72cf558c7fbe98890584d926a5d" name="a86b9a72cf558c7fbe98890584d926a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b9a72cf558c7fbe98890584d926a5d">&#9670;&#160;</a></span>CPLResetExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLResetExtension </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszExt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the extension with the provided one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the input path, this string is not altered. </td></tr>
    <tr><td class="paramname">pszExt</td><td>the new extension to apply to the given path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an altered filename with the new extension. Do not modify or free the returned string. The string may be destroyed by the next CPL call. </dd></dl>

</div>
</div>
<a id="abcdeae39a61518c9c31ecc593eeff621" name="abcdeae39a61518c9c31ecc593eeff621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdeae39a61518c9c31ecc593eeff621">&#9670;&#160;</a></span>CPLScanDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLScanDouble </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract double from string. </p>
<p>Scan up to a maximum number of characters from a string and convert the result to a double. This function uses <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a> to convert string to double value, so it uses a comma as a decimal delimiter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td class="paramname">nMaxLength</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Double value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a id="a338bbe67c148d2555861eb5563b17303" name="a338bbe67c148d2555861eb5563b17303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338bbe67c148d2555861eb5563b17303">&#9670;&#160;</a></span>CPLScanLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CPLScanLong </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan up to a maximum number of characters from a string and convert the result to a long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td class="paramname">nMaxLength</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Long value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a id="a652e12b20dd8f5f05b401a3db9d4ca29" name="a652e12b20dd8f5f05b401a3db9d4ca29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652e12b20dd8f5f05b401a3db9d4ca29">&#9670;&#160;</a></span>CPLScanPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CPLScanPointer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract pointer from string. </p>
<p>Scan up to a maximum number of characters from a string and convert the result to a pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td class="paramname">nMaxLength</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a id="a55a293942b532cc19bf3c251e02ad5d4" name="a55a293942b532cc19bf3c251e02ad5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a293942b532cc19bf3c251e02ad5d4">&#9670;&#160;</a></span>CPLScanString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLScanString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bTrimSpaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bNormalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan up to a maximum number of characters from a given string, allocate a buffer for a new string and fill it with scanned characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td class="paramname">nMaxLength</td><td>The maximum number of character to read. Less characters will be read if a null character is encountered.</td></tr>
    <tr><td class="paramname">bTrimSpaces</td><td>If TRUE, trim ending spaces from the input string. Character considered as empty using isspace(3) function.</td></tr>
    <tr><td class="paramname">bNormalize</td><td>If TRUE, replace ':' symbol with the '_'. It is needed if resulting string will be used in CPL dictionaries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the resulting string buffer. Caller responsible to free this buffer with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>. </dd></dl>

</div>
</div>
<a id="ab4a8e6cf7a0d0f662f6cd4555b074bb5" name="ab4a8e6cf7a0d0f662f6cd4555b074bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a8e6cf7a0d0f662f6cd4555b074bb5">&#9670;&#160;</a></span>CPLScanUIntBig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#a4f0794a0fb78d55ba284a414191dbc93">GUIntBig</a> CPLScanUIntBig </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract big integer from string. </p>
<p>Scan up to a maximum number of characters from a string and convert the result to a GUIntBig.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td class="paramname">nMaxLength</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GUIntBig value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a id="ac6e9643c26ab4ee22df95e3dd18c959a" name="ac6e9643c26ab4ee22df95e3dd18c959a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e9643c26ab4ee22df95e3dd18c959a">&#9670;&#160;</a></span>CPLScanULong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long CPLScanULong </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan up to a maximum number of characters from a string and convert the result to a unsigned long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td class="paramname">nMaxLength</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unsigned long value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a id="aa0cd1a68fe4f2fc7874cd2da605c36ce" name="aa0cd1a68fe4f2fc7874cd2da605c36ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cd1a68fe4f2fc7874cd2da605c36ce">&#9670;&#160;</a></span>CPLSetConfigOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLSetConfigOption </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a configuration option for GDAL/OGR use. </p>
<p>Those options are defined as a (key, value) couple. The value corresponding to a key can be got later with the CPLGetConfigOption() method.</p>
<p>This mechanism is similar to environment variables, but options set with CPLSetConfigOption() overrides, for CPLGetConfigOption() point of view, values defined in the environment.</p>
<p>If CPLSetConfigOption() is called several times with the same key, the value provided during the last call will be used.</p>
<p>Options can also be passed on the command line of most GDAL utilities with the with '&ndash;config KEY VALUE'. For example, ogrinfo &ndash;config CPL_DEBUG ON ~/data/test/point.shp</p>
<p>This function can also be used to clear a setting by passing NULL as the value (note: passing NULL will not unset an existing environment variable; it will just unset a value previously set by CPLSetConfigOption()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszKey</td><td>the key of the option </td></tr>
    <tr><td class="paramname">pszValue</td><td>the value of the option, or NULL to clear a setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://trac.osgeo.org/gdal/wiki/ConfigOptions">http://trac.osgeo.org/gdal/wiki/ConfigOptions</a> </dd></dl>

</div>
</div>
<a id="a344c2f785aa2bc4ac853e8c4729b31a5" name="a344c2f785aa2bc4ac853e8c4729b31a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344c2f785aa2bc4ac853e8c4729b31a5">&#9670;&#160;</a></span>CPLSetConfigOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLSetConfigOptions </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszConfigOptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the full list of configuration options with the passed list of KEY=VALUE pairs. </p>
<p>This has the same effect of clearing the existing list, and setting individually each pair with the CPLSetConfigOption() API.</p>
<p>This does not affect options set through environment variables or with CPLSetThreadLocalConfigOption().</p>
<p>The passed list is copied by the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszConfigOptions</td><td>the new list (or NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a1eb928a33df2ec9f8dc0e4253c70bf09" name="a1eb928a33df2ec9f8dc0e4253c70bf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb928a33df2ec9f8dc0e4253c70bf09">&#9670;&#160;</a></span>CPLsetlocale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLsetlocale </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>locale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents parallel executions of setlocale(). </p>
<p>Calling setlocale() concurrently from two or more threads is a potential data race. A mutex is used to provide a critical region so that only one thread at a time can be executing setlocale().</p>
<p>The return should not be freed, and copied quickly as it may be invalidated by a following next call to CPLsetlocale().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">category</td><td>See your compiler's documentation on setlocale. </td></tr>
    <tr><td class="paramname">locale</td><td>See your compiler's documentation on setlocale.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See your compiler's documentation on setlocale. </dd></dl>

</div>
</div>
<a id="ac8f0d1de8f2b2069c6ea9352ca4442cd" name="ac8f0d1de8f2b2069c6ea9352ca4442cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f0d1de8f2b2069c6ea9352ca4442cd">&#9670;&#160;</a></span>CPLSetThreadLocalConfigOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLSetThreadLocalConfigOption </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a configuration option for GDAL/OGR use. </p>
<p>Those options are defined as a (key, value) couple. The value corresponding to a key can be got later with the CPLGetConfigOption() method.</p>
<p>This function sets the configuration option that only applies in the current thread, as opposed to CPLSetConfigOption() which sets an option that applies on all threads. CPLSetThreadLocalConfigOption() will override the effect of CPLSetConfigOption) for the current thread.</p>
<p>This function can also be used to clear a setting by passing NULL as the value (note: passing NULL will not unset an existing environment variable or a value set through CPLSetConfigOption(); it will just unset a value previously set by CPLSetThreadLocalConfigOption()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszKey</td><td>the key of the option </td></tr>
    <tr><td class="paramname">pszValue</td><td>the value of the option, or NULL to clear a setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8f7cb2472b60a21c7b019de160f88bb" name="af8f7cb2472b60a21c7b019de160f88bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f7cb2472b60a21c7b019de160f88bb">&#9670;&#160;</a></span>CPLSetThreadLocalConfigOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLSetThreadLocalConfigOptions </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszConfigOptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the full list of thread local configuration options with the passed list of KEY=VALUE pairs. </p>
<p>This has the same effect of clearing the existing list, and setting individually each pair with the CPLSetThreadLocalConfigOption() API.</p>
<p>This does not affect options set through environment variables or with CPLSetConfigOption().</p>
<p>The passed list is copied by the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszConfigOptions</td><td>the new list (or NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a714fff57a1304b926bf8c8a1f6e2d660" name="a714fff57a1304b926bf8c8a1f6e2d660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714fff57a1304b926bf8c8a1f6e2d660">&#9670;&#160;</a></span>CPLStrdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLStrdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe version of strdup() function. </p>
<p>This function is similar to the C library strdup() function, but if the memory allocation fails it will issue a CE_Fatal error with CPLError() instead of returning NULL. Memory allocated with CPLStrdup() can be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> or <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a>.</p>
<p>It is also safe to pass a NULL string into CPLStrdup(). CPLStrdup() will allocate and return a zero length string (as opposed to a NULL string).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>input string to be duplicated. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a newly allocated copy of the string. Free with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> or <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a>. </dd></dl>

</div>
</div>
<a id="ad156021dc0ac7c8b76193bbed26c1c22" name="ad156021dc0ac7c8b76193bbed26c1c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad156021dc0ac7c8b76193bbed26c1c22">&#9670;&#160;</a></span>CPLStrlwr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLStrlwr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert each characters of the string to lower case. </p>
<p>For example, "ABcdE" will be converted to "abcde". Starting with GDAL 3.9, this function is no longer locale dependent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>input string to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the same string, pszString. </dd></dl>

</div>
</div>
<a id="a2388e43fb089a354eb3583016b2a3b00" name="a2388e43fb089a354eb3583016b2a3b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2388e43fb089a354eb3583016b2a3b00">&#9670;&#160;</a></span>CPLStrtod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLStrtod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard strtod(3), but does not take locale in account. That means, the decimal delimiter is always '.' (decimal point). Use CPLStrtodDelim() function if you want to specify custom delimiter. Also see notes for CPLAtof() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Pointer to string to convert. </td></tr>
    <tr><td class="paramname">endptr</td><td>If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a id="ac96c5f1823c54ef96b5783208c817817" name="ac96c5f1823c54ef96b5783208c817817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96c5f1823c54ef96b5783208c817817">&#9670;&#160;</a></span>CPLStrtodDelim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLStrtodDelim </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts ASCII string to floating point number using specified delimiter. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard strtod(3), but does not take locale in account. Instead of locale defined decimal delimiter you can specify your own one. Also see notes for CPLAtof() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Pointer to string to convert. </td></tr>
    <tr><td class="paramname">endptr</td><td>If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr. </td></tr>
    <tr><td class="paramname">point</td><td>Decimal delimiter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a id="a7a9e1feed3a71e84505a3e44749c003b" name="a7a9e1feed3a71e84505a3e44749c003b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9e1feed3a71e84505a3e44749c003b">&#9670;&#160;</a></span>CPLStrtodM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLStrtodM </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard strtod(3), but does not take locale in account.</p>
<p>That function accepts '.' (decimal point) or ',' (comma) as decimal delimiter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Pointer to string to convert. </td></tr>
    <tr><td class="paramname">endptr</td><td>If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, if any. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a1ccda187ed172fd6e33cd98223328531" name="a1ccda187ed172fd6e33cd98223328531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccda187ed172fd6e33cd98223328531">&#9670;&#160;</a></span>CPLStrtof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CPLStrtof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to single floating point representation. This function does the same as standard strtof(3), but does not take locale in account. That means, the decimal delimiter is always '.' (decimal point). Use CPLStrtofDelim() function if you want to specify custom delimiter. Also see notes for CPLAtof() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Pointer to string to convert. </td></tr>
    <tr><td class="paramname">endptr</td><td>If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a id="a3a102a1417c98a242900fb8c0076fc1b" name="a3a102a1417c98a242900fb8c0076fc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a102a1417c98a242900fb8c0076fc1b">&#9670;&#160;</a></span>CPLStrtofDelim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CPLStrtofDelim </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts ASCII string to floating point number using specified delimiter. </p>
<p>This function converts the initial portion of the string pointed to by nptr to single floating point representation. This function does the same as standard strtof(3), but does not take locale in account. Instead of locale defined decimal delimiter you can specify your own one. Also see notes for CPLAtof() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Pointer to string to convert. </td></tr>
    <tr><td class="paramname">endptr</td><td>If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr. </td></tr>
    <tr><td class="paramname">point</td><td>Decimal delimiter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a id="aad7e2cc46239801842dd0f697deb909f" name="aad7e2cc46239801842dd0f697deb909f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7e2cc46239801842dd0f697deb909f">&#9670;&#160;</a></span>CPLSubscribeToSetConfigOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLSubscribeToSetConfigOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__conv_8h.html#a07d2ac5d9d871797a7712ed591cb85ee">CPLSetConfigOptionSubscriber</a>&#160;</td>
          <td class="paramname"><em>pfnCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a callback that will be notified of calls to CPLSetConfigOption()/ CPLSetThreadLocalConfigOption() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfnCallback</td><td>Callback. Must not be NULL </td></tr>
    <tr><td class="paramname">pUserData</td><td>Callback user data. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>subscriber ID that can be used with CPLUnsubscribeToSetConfigOption() </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="aa786ff8dd95ea5b2b641de9ed53cb277" name="aa786ff8dd95ea5b2b641de9ed53cb277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa786ff8dd95ea5b2b641de9ed53cb277">&#9670;&#160;</a></span>CPLUnlinkTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLUnlinkTree </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively unlink a directory. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on successful completion, -1 if function fails. </dd></dl>

</div>
</div>
<a id="a9636c2f46b1a174077c99be10287a078" name="a9636c2f46b1a174077c99be10287a078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9636c2f46b1a174077c99be10287a078">&#9670;&#160;</a></span>CPLUnsubscribeToSetConfigOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLUnsubscribeToSetConfigOption </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a subscriber installed with CPLSubscribeToSetConfigOption() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nId</td><td>Subscriber id returned by CPLSubscribeToSetConfigOption() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a8468c798dfe1396f5ff6da798e1f7091" name="a8468c798dfe1396f5ff6da798e1f7091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8468c798dfe1396f5ff6da798e1f7091">&#9670;&#160;</a></span>CPLValidateXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLValidateXML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszXMLFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszXSDFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate a XML file against a XML schema. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszXMLFilename</td><td>the filename of the XML file to validate. </td></tr>
    <tr><td class="paramname">pszXSDFilename</td><td>the filename of the XSD schema. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>unused for now. Set to NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the XML file validates against the XML schema.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.10.0 </dd></dl>

</div>
</div>
<a id="adc32ba31ff1dc92b797b501ebba38f3d" name="adc32ba31ff1dc92b797b501ebba38f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc32ba31ff1dc92b797b501ebba38f3d">&#9670;&#160;</a></span>CPLZLibDeflate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CPLZLibDeflate </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nOutAvailableBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pnOutBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress a buffer with ZLib compression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>input buffer. </td></tr>
    <tr><td class="paramname">nBytes</td><td>size of input buffer in bytes. </td></tr>
    <tr><td class="paramname">nLevel</td><td>ZLib compression level (-1 for default). </td></tr>
    <tr><td class="paramname">outptr</td><td>output buffer, or NULL to let the function allocate it. </td></tr>
    <tr><td class="paramname">nOutAvailableBytes</td><td>size of output buffer if provided, or ignored. </td></tr>
    <tr><td class="paramname">pnOutBytes</td><td>pointer to a size_t, where to store the size of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output buffer (to be freed with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> if not provided) or NULL in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.10.0 </dd></dl>

</div>
</div>
<a id="a3d30bfb414397cf1d848f66a35f302a0" name="a3d30bfb414397cf1d848f66a35f302a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d30bfb414397cf1d848f66a35f302a0">&#9670;&#160;</a></span>CPLZLibInflate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CPLZLibInflate </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nOutAvailableBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pnOutBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncompress a buffer compressed with ZLib compression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>input buffer. </td></tr>
    <tr><td class="paramname">nBytes</td><td>size of input buffer in bytes. </td></tr>
    <tr><td class="paramname">outptr</td><td>output buffer, or NULL to let the function allocate it. </td></tr>
    <tr><td class="paramname">nOutAvailableBytes</td><td>size of output buffer if provided, or ignored. </td></tr>
    <tr><td class="paramname">pnOutBytes</td><td>pointer to a size_t, where to store the size of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output buffer (to be freed with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> if not provided) or NULL in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.10.0 </dd></dl>

</div>
</div>
<a id="afa3bdf47e48bec2af069ef6fad851ab0" name="afa3bdf47e48bec2af069ef6fad851ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3bdf47e48bec2af069ef6fad851ab0">&#9670;&#160;</a></span>CPLZLibInflateEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CPLZLibInflateEx </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nOutAvailableBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowResizeOutptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pnOutBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncompress a buffer compressed with ZLib compression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>input buffer. </td></tr>
    <tr><td class="paramname">nBytes</td><td>size of input buffer in bytes. </td></tr>
    <tr><td class="paramname">outptr</td><td>output buffer, or NULL to let the function allocate it. </td></tr>
    <tr><td class="paramname">nOutAvailableBytes</td><td>size of output buffer if provided, or ignored. </td></tr>
    <tr><td class="paramname">bAllowResizeOutptr</td><td>whether the function is allowed to grow outptr (using VSIRealloc) if its initial capacity provided by nOutAvailableBytes is not large enough. Ignored if outptr is NULL. </td></tr>
    <tr><td class="paramname">pnOutBytes</td><td>pointer to a size_t, where to store the size of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output buffer (to be freed with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> if not provided) or NULL in case of error. If bAllowResizeOutptr is set to true, only the returned pointer should be freed by the caller, as outptr might have been reallocated or freed.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9.0 </dd></dl>

</div>
</div>
<a id="acf57353cbad5314c2be7e25e766bd570" name="acf57353cbad5314c2be7e25e766bd570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf57353cbad5314c2be7e25e766bd570">&#9670;&#160;</a></span>down_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To cpl::down_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use cpl::down_cast&lt;Derived*&gt;(pointer_to_base) as equivalent of static_cast&lt;Derived*&gt;(pointer_to_base) with safe checking in debug mode. </p>
<p>Only works if no virtual inheritance is involved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>pointer to a base class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a derived class </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
