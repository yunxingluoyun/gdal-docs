<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: OGRCurvePolygon Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classOGRCurvePolygon-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">OGRCurvePolygon Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Concrete class representing curve polygons.  
 <a href="classOGRCurvePolygon.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OGRCurvePolygon:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOGRCurvePolygon.png" usemap="#OGRCurvePolygon_map" alt=""/>
  <map id="OGRCurvePolygon_map" name="OGRCurvePolygon_map">
<area href="classOGRSurface.html" title="Abstract base class for 2 dimensional objects like polygons or curve polygons." alt="OGRSurface" shape="rect" coords="0,56,120,80"/>
<area href="classOGRGeometry.html" title="Abstract base class for all geometry classes." alt="OGRGeometry" shape="rect" coords="0,0,120,24"/>
<area href="classOGRPolygon.html" title="Concrete class representing polygons." alt="OGRPolygon" shape="rect" coords="0,168,120,192"/>
<area href="classOGRTriangle.html" title="Triangle class." alt="OGRTriangle" shape="rect" coords="0,224,120,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa63bd732e83f02b4d03d71f2d5d0c36b" id="r_aa63bd732e83f02b4d03d71f2d5d0c36b"><td class="memItemLeft" align="right" valign="top"><a id="aa63bd732e83f02b4d03d71f2d5d0c36b" name="aa63bd732e83f02b4d03d71f2d5d0c36b"></a>
typedef <a class="el" href="classOGRCurve.html">OGRCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ChildType</b></td></tr>
<tr class="memdesc:aa63bd732e83f02b4d03d71f2d5d0c36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of child elements. <br /></td></tr>
<tr class="separator:aa63bd732e83f02b4d03d71f2d5d0c36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa7abf62163f075f1d6219f041ce1669e" id="r_aa7abf62163f075f1d6219f041ce1669e"><td class="memItemLeft" align="right" valign="top"><a id="aa7abf62163f075f1d6219f041ce1669e" name="aa7abf62163f075f1d6219f041ce1669e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OGRCurvePolygon</b> ()</td></tr>
<tr class="memdesc:aa7abf62163f075f1d6219f041ce1669e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty curve polygon. <br /></td></tr>
<tr class="separator:aa7abf62163f075f1d6219f041ce1669e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cf10bb3af3893e47b8506813aa2694" id="r_af8cf10bb3af3893e47b8506813aa2694"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#af8cf10bb3af3893e47b8506813aa2694">OGRCurvePolygon</a> (const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> &amp;)</td></tr>
<tr class="memdesc:af8cf10bb3af3893e47b8506813aa2694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:af8cf10bb3af3893e47b8506813aa2694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fbcada309b9562536aad08fe0da73a" id="r_ad5fbcada309b9562536aad08fe0da73a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#ad5fbcada309b9562536aad08fe0da73a">operator=</a> (const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> &amp;other)</td></tr>
<tr class="memdesc:ad5fbcada309b9562536aad08fe0da73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:ad5fbcada309b9562536aad08fe0da73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade25a38fd8b97333cf6df3446433bf93" id="r_ade25a38fd8b97333cf6df3446433bf93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurvePolygon.html#aa63bd732e83f02b4d03d71f2d5d0c36b">ChildType</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#ade25a38fd8b97333cf6df3446433bf93">begin</a> ()</td></tr>
<tr class="memdesc:ade25a38fd8b97333cf6df3446433bf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin of curve iterator.  <br /></td></tr>
<tr class="separator:ade25a38fd8b97333cf6df3446433bf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32aaf918598a7e4f9cba07696a77871" id="r_af32aaf918598a7e4f9cba07696a77871"><td class="memItemLeft" align="right" valign="top"><a id="af32aaf918598a7e4f9cba07696a77871" name="af32aaf918598a7e4f9cba07696a77871"></a>
<a class="el" href="classOGRCurvePolygon.html#aa63bd732e83f02b4d03d71f2d5d0c36b">ChildType</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="memdesc:af32aaf918598a7e4f9cba07696a77871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end of curve iterator. <br /></td></tr>
<tr class="separator:af32aaf918598a7e4f9cba07696a77871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dd668a46c2b405b1a6dedf26c8b24e" id="r_ad4dd668a46c2b405b1a6dedf26c8b24e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCurvePolygon.html#aa63bd732e83f02b4d03d71f2d5d0c36b">ChildType</a> *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#ad4dd668a46c2b405b1a6dedf26c8b24e">begin</a> () const</td></tr>
<tr class="memdesc:ad4dd668a46c2b405b1a6dedf26c8b24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin of curve iterator.  <br /></td></tr>
<tr class="separator:ad4dd668a46c2b405b1a6dedf26c8b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc03c2ee93e5cf5ed854523246241069" id="r_acc03c2ee93e5cf5ed854523246241069"><td class="memItemLeft" align="right" valign="top"><a id="acc03c2ee93e5cf5ed854523246241069" name="acc03c2ee93e5cf5ed854523246241069"></a>
const <a class="el" href="classOGRCurvePolygon.html#aa63bd732e83f02b4d03d71f2d5d0c36b">ChildType</a> *const *&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="memdesc:acc03c2ee93e5cf5ed854523246241069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end of curve iterator. <br /></td></tr>
<tr class="separator:acc03c2ee93e5cf5ed854523246241069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657a572a4c14c429f6729b22f813a0b8" id="r_a657a572a4c14c429f6729b22f813a0b8"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a657a572a4c14c429f6729b22f813a0b8">getGeometryName</a> () const override</td></tr>
<tr class="memdesc:a657a572a4c14c429f6729b22f813a0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch WKT name for geometry type.  <br /></td></tr>
<tr class="separator:a657a572a4c14c429f6729b22f813a0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1a2d708cdf852785a66417f9889bfc" id="r_a9a1a2d708cdf852785a66417f9889bfc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a9a1a2d708cdf852785a66417f9889bfc">getGeometryType</a> () const override</td></tr>
<tr class="memdesc:a9a1a2d708cdf852785a66417f9889bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry type.  <br /></td></tr>
<tr class="separator:a9a1a2d708cdf852785a66417f9889bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f4a0d3345503d5d62f29cb94eb2897" id="r_a42f4a0d3345503d5d62f29cb94eb2897"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a42f4a0d3345503d5d62f29cb94eb2897">clone</a> () const override</td></tr>
<tr class="memdesc:a42f4a0d3345503d5d62f29cb94eb2897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of this object.  <br /></td></tr>
<tr class="separator:a42f4a0d3345503d5d62f29cb94eb2897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8b6b73430f36513a65d27f556e796d" id="r_a4f8b6b73430f36513a65d27f556e796d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a4f8b6b73430f36513a65d27f556e796d">empty</a> () override</td></tr>
<tr class="memdesc:a4f8b6b73430f36513a65d27f556e796d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear geometry information.  <br /></td></tr>
<tr class="separator:a4f8b6b73430f36513a65d27f556e796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c14e71640ee125335023f2f0124aecc" id="r_a6c14e71640ee125335023f2f0124aecc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a6c14e71640ee125335023f2f0124aecc">transform</a> (<a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *poCT) override</td></tr>
<tr class="memdesc:a6c14e71640ee125335023f2f0124aecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply arbitrary coordinate transformation to geometry.  <br /></td></tr>
<tr class="separator:a6c14e71640ee125335023f2f0124aecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e2b4087c482df97a2cb8ba6d9eb7c1" id="r_a42e2b4087c482df97a2cb8ba6d9eb7c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a42e2b4087c482df97a2cb8ba6d9eb7c1">flattenTo2D</a> () override</td></tr>
<tr class="memdesc:a42e2b4087c482df97a2cb8ba6d9eb7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geometry to strictly 2D.  <br /></td></tr>
<tr class="separator:a42e2b4087c482df97a2cb8ba6d9eb7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa659e9d7d87da1ae552a69a7fc5508f9" id="r_aa659e9d7d87da1ae552a69a7fc5508f9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#aa659e9d7d87da1ae552a69a7fc5508f9">IsEmpty</a> () const override</td></tr>
<tr class="memdesc:aa659e9d7d87da1ae552a69a7fc5508f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE (non-zero) if the object has no points.  <br /></td></tr>
<tr class="separator:aa659e9d7d87da1ae552a69a7fc5508f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922d66445e62efa2199595821dfc3d44" id="r_a922d66445e62efa2199595821dfc3d44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a922d66445e62efa2199595821dfc3d44">segmentize</a> (double dfMaxLength) override</td></tr>
<tr class="memdesc:a922d66445e62efa2199595821dfc3d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the geometry such it has no segment longer then the given distance.  <br /></td></tr>
<tr class="separator:a922d66445e62efa2199595821dfc3d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e3b31c4b80544151852e825f3f555c" id="r_af3e3b31c4b80544151852e825f3f555c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#af3e3b31c4b80544151852e825f3f555c">hasCurveGeometry</a> (int bLookForNonLinear=FALSE) const override</td></tr>
<tr class="memdesc:af3e3b31c4b80544151852e825f3f555c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this geometry is or has curve geometry.  <br /></td></tr>
<tr class="separator:af3e3b31c4b80544151852e825f3f555c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c3cdd9accf2547e975ddb78558e9b4" id="r_a10c3cdd9accf2547e975ddb78558e9b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a10c3cdd9accf2547e975ddb78558e9b4">getLinearGeometry</a> (double dfMaxAngleStepSizeDegrees=0, const char *const *papszOptions=nullptr) const override</td></tr>
<tr class="memdesc:a10c3cdd9accf2547e975ddb78558e9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return, possibly approximate, non-curve version of this geometry.  <br /></td></tr>
<tr class="separator:a10c3cdd9accf2547e975ddb78558e9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d872967b12ec5cf55846555fe32c983" id="r_a7d872967b12ec5cf55846555fe32c983"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a7d872967b12ec5cf55846555fe32c983">get_GeodesicArea</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSRSOverride=nullptr) const override</td></tr>
<tr class="memdesc:a7d872967b12ec5cf55846555fe32c983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the area of the surface object, considered as a surface on the underlying ellipsoid of the SRS attached to the geometry.  <br /></td></tr>
<tr class="separator:a7d872967b12ec5cf55846555fe32c983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6159cf2c28cd236ad2aa593c005c473a" id="r_a6159cf2c28cd236ad2aa593c005c473a"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a6159cf2c28cd236ad2aa593c005c473a">get_Area</a> () const override</td></tr>
<tr class="memdesc:a6159cf2c28cd236ad2aa593c005c473a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the area of the surface object.  <br /></td></tr>
<tr class="separator:a6159cf2c28cd236ad2aa593c005c473a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae402b4ce557a98b5f2871d5de9852a5b" id="r_ae402b4ce557a98b5f2871d5de9852a5b"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#ae402b4ce557a98b5f2871d5de9852a5b">WkbSize</a> () const override</td></tr>
<tr class="memdesc:ae402b4ce557a98b5f2871d5de9852a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of related binary representation.  <br /></td></tr>
<tr class="separator:ae402b4ce557a98b5f2871d5de9852a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b22999d7055ac9f2d9d92728213e33f" id="r_a7b22999d7055ac9f2d9d92728213e33f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a7b22999d7055ac9f2d9d92728213e33f">importFromWkb</a> (const unsigned char *, size_t, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>, size_t &amp;nBytesConsumedOut) override</td></tr>
<tr class="memdesc:a7b22999d7055ac9f2d9d92728213e33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known binary data.  <br /></td></tr>
<tr class="separator:a7b22999d7055ac9f2d9d92728213e33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce34b5497984619d0fb14f831856313" id="r_acce34b5497984619d0fb14f831856313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#acce34b5497984619d0fb14f831856313">exportToWkb</a> (unsigned char *, const <a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *=nullptr) const override</td></tr>
<tr class="memdesc:acce34b5497984619d0fb14f831856313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known binary format.  <br /></td></tr>
<tr class="separator:acce34b5497984619d0fb14f831856313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154a45e780861e77d1a17520c08a527d" id="r_a154a45e780861e77d1a17520c08a527d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a154a45e780861e77d1a17520c08a527d">importFromWkt</a> (const char **) override</td></tr>
<tr class="memdesc:a154a45e780861e77d1a17520c08a527d"><td class="mdescLeft">&#160;</td><td class="mdescRight">deprecated  <br /></td></tr>
<tr class="separator:a154a45e780861e77d1a17520c08a527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09338292b7382ade8d59a5fa40867f4b" id="r_a09338292b7382ade8d59a5fa40867f4b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a09338292b7382ade8d59a5fa40867f4b">exportToWkt</a> (const <a class="el" href="structOGRWktOptions.html">OGRWktOptions</a> &amp;opts=<a class="el" href="structOGRWktOptions.html">OGRWktOptions</a>(), <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *err=nullptr) const override</td></tr>
<tr class="memdesc:a09338292b7382ade8d59a5fa40867f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a curve polygon to WKT.  <br /></td></tr>
<tr class="separator:a09338292b7382ade8d59a5fa40867f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfab51e053c687ad39244c08ea298a7" id="r_a6cfab51e053c687ad39244c08ea298a7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a6cfab51e053c687ad39244c08ea298a7">getDimension</a> () const override</td></tr>
<tr class="memdesc:a6cfab51e053c687ad39244c08ea298a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of this object.  <br /></td></tr>
<tr class="separator:a6cfab51e053c687ad39244c08ea298a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c37b416860a3fd2b2aaf471ffd9ad69" id="r_a5c37b416860a3fd2b2aaf471ffd9ad69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a5c37b416860a3fd2b2aaf471ffd9ad69">getEnvelope</a> (<a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psEnvelope) const override</td></tr>
<tr class="memdesc:a5c37b416860a3fd2b2aaf471ffd9ad69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.  <br /></td></tr>
<tr class="separator:a5c37b416860a3fd2b2aaf471ffd9ad69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fa4514aead52995de7aee70a6b8bb3" id="r_a46fa4514aead52995de7aee70a6b8bb3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a46fa4514aead52995de7aee70a6b8bb3">getEnvelope</a> (<a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *psEnvelope) const override</td></tr>
<tr class="memdesc:a46fa4514aead52995de7aee70a6b8bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.  <br /></td></tr>
<tr class="separator:a46fa4514aead52995de7aee70a6b8bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0a7361f3b88736fa98145f8770bc0a" id="r_a4c0a7361f3b88736fa98145f8770bc0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRPolygon.html">OGRPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a4c0a7361f3b88736fa98145f8770bc0a">CurvePolyToPoly</a> (double dfMaxAngleStepSizeDegrees=0, const char *const *papszOptions=nullptr) const</td></tr>
<tr class="memdesc:a4c0a7361f3b88736fa98145f8770bc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a polygon from a curve polygon.  <br /></td></tr>
<tr class="separator:a4c0a7361f3b88736fa98145f8770bc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866bf18d2c0a73d1ced4ff982aee6c25" id="r_a866bf18d2c0a73d1ced4ff982aee6c25"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a866bf18d2c0a73d1ced4ff982aee6c25">Equals</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const override</td></tr>
<tr class="memdesc:a866bf18d2c0a73d1ced4ff982aee6c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if two geometries are equivalent.  <br /></td></tr>
<tr class="separator:a866bf18d2c0a73d1ced4ff982aee6c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ec798e8a8918c0bf71edceff9765da" id="r_a78ec798e8a8918c0bf71edceff9765da"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a78ec798e8a8918c0bf71edceff9765da">Intersects</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const override</td></tr>
<tr class="memdesc:a78ec798e8a8918c0bf71edceff9765da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do these features intersect?  <br /></td></tr>
<tr class="separator:a78ec798e8a8918c0bf71edceff9765da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e60f2ed59b940cf72746a2b9c4dfe18" id="r_a3e60f2ed59b940cf72746a2b9c4dfe18"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a3e60f2ed59b940cf72746a2b9c4dfe18">Contains</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const override</td></tr>
<tr class="memdesc:a3e60f2ed59b940cf72746a2b9c4dfe18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <br /></td></tr>
<tr class="separator:a3e60f2ed59b940cf72746a2b9c4dfe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf41d14265fdabd4b4ceb3d8c22341fa" id="r_adf41d14265fdabd4b4ceb3d8c22341fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#adf41d14265fdabd4b4ceb3d8c22341fa">setCoordinateDimension</a> (int nDimension) override</td></tr>
<tr class="memdesc:adf41d14265fdabd4b4ceb3d8c22341fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coordinate dimension.  <br /></td></tr>
<tr class="separator:adf41d14265fdabd4b4ceb3d8c22341fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4e059b5d4965304f795044910c8769" id="r_afb4e059b5d4965304f795044910c8769"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#afb4e059b5d4965304f795044910c8769">set3D</a> (<a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> bIs3D) override</td></tr>
<tr class="memdesc:afb4e059b5d4965304f795044910c8769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the Z coordinate dimension.  <br /></td></tr>
<tr class="separator:afb4e059b5d4965304f795044910c8769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf784aaad99c0878b5bc8f8e5a65c3b0" id="r_adf784aaad99c0878b5bc8f8e5a65c3b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#adf784aaad99c0878b5bc8f8e5a65c3b0">setMeasured</a> (<a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> bIsMeasured) override</td></tr>
<tr class="memdesc:adf784aaad99c0878b5bc8f8e5a65c3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the M coordinate dimension.  <br /></td></tr>
<tr class="separator:adf784aaad99c0878b5bc8f8e5a65c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ebc5b56476b8fba1c18357c5bc71d2" id="r_a10ebc5b56476b8fba1c18357c5bc71d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a10ebc5b56476b8fba1c18357c5bc71d2">assignSpatialReference</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSR) override</td></tr>
<tr class="memdesc:a10ebc5b56476b8fba1c18357c5bc71d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign spatial reference to this object.  <br /></td></tr>
<tr class="separator:a10ebc5b56476b8fba1c18357c5bc71d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e97ce0148e216dc292de5bdec9ad04" id="r_ad3e97ce0148e216dc292de5bdec9ad04"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#ad3e97ce0148e216dc292de5bdec9ad04">addRing</a> (<a class="el" href="classOGRCurve.html">OGRCurve</a> *)</td></tr>
<tr class="memdesc:ad3e97ce0148e216dc292de5bdec9ad04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a ring to a polygon.  <br /></td></tr>
<tr class="separator:ad3e97ce0148e216dc292de5bdec9ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b5dfcc342e2fde2bda9965fe4ac084" id="r_aa2b5dfcc342e2fde2bda9965fe4ac084"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#aa2b5dfcc342e2fde2bda9965fe4ac084">addRingDirectly</a> (<a class="el" href="classOGRCurve.html">OGRCurve</a> *)</td></tr>
<tr class="memdesc:aa2b5dfcc342e2fde2bda9965fe4ac084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a ring to a polygon.  <br /></td></tr>
<tr class="separator:aa2b5dfcc342e2fde2bda9965fe4ac084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018e1aad6353a1f10a38639b51ae549e" id="r_a018e1aad6353a1f10a38639b51ae549e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a018e1aad6353a1f10a38639b51ae549e">addRing</a> (std::unique_ptr&lt; <a class="el" href="classOGRCurve.html">OGRCurve</a> &gt;)</td></tr>
<tr class="memdesc:a018e1aad6353a1f10a38639b51ae549e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a ring to a polygon.  <br /></td></tr>
<tr class="separator:a018e1aad6353a1f10a38639b51ae549e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2880929fb3d5d80e8f023364da38f5f1" id="r_a2880929fb3d5d80e8f023364da38f5f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a2880929fb3d5d80e8f023364da38f5f1">getExteriorRingCurve</a> ()</td></tr>
<tr class="memdesc:a2880929fb3d5d80e8f023364da38f5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch reference to external polygon ring.  <br /></td></tr>
<tr class="separator:a2880929fb3d5d80e8f023364da38f5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae081de82d00671e1cf400b19fe402298" id="r_ae081de82d00671e1cf400b19fe402298"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#ae081de82d00671e1cf400b19fe402298">getExteriorRingCurve</a> () const</td></tr>
<tr class="memdesc:ae081de82d00671e1cf400b19fe402298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch reference to external polygon ring.  <br /></td></tr>
<tr class="separator:ae081de82d00671e1cf400b19fe402298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d6071dbbce259c8a19bbf75c7d44ef" id="r_af3d6071dbbce259c8a19bbf75c7d44ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#af3d6071dbbce259c8a19bbf75c7d44ef">getNumInteriorRings</a> () const</td></tr>
<tr class="memdesc:af3d6071dbbce259c8a19bbf75c7d44ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the number of internal rings.  <br /></td></tr>
<tr class="separator:af3d6071dbbce259c8a19bbf75c7d44ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d172ad810a3db1362114f424836b05" id="r_a30d172ad810a3db1362114f424836b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a30d172ad810a3db1362114f424836b05">getInteriorRingCurve</a> (int)</td></tr>
<tr class="memdesc:a30d172ad810a3db1362114f424836b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch reference to indicated internal ring.  <br /></td></tr>
<tr class="separator:a30d172ad810a3db1362114f424836b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4cdd2ab417af986d414cd8ea77483f" id="r_ade4cdd2ab417af986d414cd8ea77483f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#ade4cdd2ab417af986d414cd8ea77483f">getInteriorRingCurve</a> (int) const</td></tr>
<tr class="memdesc:ade4cdd2ab417af986d414cd8ea77483f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch reference to indicated internal ring.  <br /></td></tr>
<tr class="separator:ade4cdd2ab417af986d414cd8ea77483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fdacfe9e3ffe0789cc21f1405f489c" id="r_a09fdacfe9e3ffe0789cc21f1405f489c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a09fdacfe9e3ffe0789cc21f1405f489c">stealExteriorRingCurve</a> ()</td></tr>
<tr class="memdesc:a09fdacfe9e3ffe0789cc21f1405f489c"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Steal" reference to external ring.  <br /></td></tr>
<tr class="separator:a09fdacfe9e3ffe0789cc21f1405f489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb46dfd0cd7eebe68555ac1b6da76f" id="r_af7fb46dfd0cd7eebe68555ac1b6da76f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#af7fb46dfd0cd7eebe68555ac1b6da76f">removeRing</a> (int iIndex, bool bDelete=true)</td></tr>
<tr class="memdesc:af7fb46dfd0cd7eebe68555ac1b6da76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a geometry from the container.  <br /></td></tr>
<tr class="separator:af7fb46dfd0cd7eebe68555ac1b6da76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c9af4e0ff50cec5e8662a4fdbd9628" id="r_a43c9af4e0ff50cec5e8662a4fdbd9628"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a43c9af4e0ff50cec5e8662a4fdbd9628">accept</a> (<a class="el" href="classIOGRGeometryVisitor.html">IOGRGeometryVisitor</a> *visitor) override</td></tr>
<tr class="memdesc:a43c9af4e0ff50cec5e8662a4fdbd9628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a visitor.  <br /></td></tr>
<tr class="separator:a43c9af4e0ff50cec5e8662a4fdbd9628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5129fb870acd6508fba57b800f7e07a" id="r_af5129fb870acd6508fba57b800f7e07a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#af5129fb870acd6508fba57b800f7e07a">accept</a> (<a class="el" href="classIOGRConstGeometryVisitor.html">IOGRConstGeometryVisitor</a> *visitor) const override</td></tr>
<tr class="memdesc:af5129fb870acd6508fba57b800f7e07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a visitor.  <br /></td></tr>
<tr class="separator:af5129fb870acd6508fba57b800f7e07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820f36b21407a7400b0af0a5d95b0e5e" id="r_a820f36b21407a7400b0af0a5d95b0e5e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a820f36b21407a7400b0af0a5d95b0e5e">swapXY</a> () override</td></tr>
<tr class="memdesc:a820f36b21407a7400b0af0a5d95b0e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap x and y coordinates.  <br /></td></tr>
<tr class="separator:a820f36b21407a7400b0af0a5d95b0e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bb0f7cae630c31511766718bcc5b66" id="r_af1bb0f7cae630c31511766718bcc5b66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#af1bb0f7cae630c31511766718bcc5b66">importFromWkt</a> (const char **ppszInput)=0</td></tr>
<tr class="memdesc:af1bb0f7cae630c31511766718bcc5b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known text data.  <br /></td></tr>
<tr class="separator:af1bb0f7cae630c31511766718bcc5b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7129d4459a847a8ea6ec8b5efc24c71" id="r_ac7129d4459a847a8ea6ec8b5efc24c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#ac7129d4459a847a8ea6ec8b5efc24c71">importFromWkt</a> (char **ppszInput)</td></tr>
<tr class="memdesc:ac7129d4459a847a8ea6ec8b5efc24c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <br /></td></tr>
<tr class="separator:ac7129d4459a847a8ea6ec8b5efc24c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17cfebfd9826a22763dff6280ba196e" id="r_ad17cfebfd9826a22763dff6280ba196e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#ad17cfebfd9826a22763dff6280ba196e">exportToWkt</a> (char **ppszDstText, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>) const</td></tr>
<tr class="memdesc:ad17cfebfd9826a22763dff6280ba196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known text format.  <br /></td></tr>
<tr class="separator:ad17cfebfd9826a22763dff6280ba196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d826f9d721fe0384b7561a2ade8963" id="r_a48d826f9d721fe0384b7561a2ade8963"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a48d826f9d721fe0384b7561a2ade8963">exportToWkt</a> (const <a class="el" href="structOGRWktOptions.html">OGRWktOptions</a> &amp;opts=<a class="el" href="structOGRWktOptions.html">OGRWktOptions</a>(), <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *err=nullptr) const=0</td></tr>
<tr class="memdesc:a48d826f9d721fe0384b7561a2ade8963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a WKT geometry.  <br /></td></tr>
<tr class="separator:a48d826f9d721fe0384b7561a2ade8963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb360e6efd4a9450f891972e495c5130" id="r_abb360e6efd4a9450f891972e495c5130"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSurface.html#abb360e6efd4a9450f891972e495c5130">PointOnSurface</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *poPoint) const</td></tr>
<tr class="memdesc:abb360e6efd4a9450f891972e495c5130"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method relates to the SFCOM ISurface::get_PointOnSurface() method.  <br /></td></tr>
<tr class="separator:abb360e6efd4a9450f891972e495c5130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e450007526af0a112b714f767732f58" id="r_a8e450007526af0a112b714f767732f58"><td class="memItemLeft" align="right" valign="top"><a id="a8e450007526af0a112b714f767732f58" name="a8e450007526af0a112b714f767732f58"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;other) const</td></tr>
<tr class="memdesc:a8e450007526af0a112b714f767732f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if two geometries are equal. <br /></td></tr>
<tr class="separator:a8e450007526af0a112b714f767732f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4e244846a69276bee362db04e15907" id="r_a2f4e244846a69276bee362db04e15907"><td class="memItemLeft" align="right" valign="top"><a id="a2f4e244846a69276bee362db04e15907" name="a2f4e244846a69276bee362db04e15907"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;other) const</td></tr>
<tr class="memdesc:a2f4e244846a69276bee362db04e15907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if two geometries are different. <br /></td></tr>
<tr class="separator:a2f4e244846a69276bee362db04e15907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6fdd4df7c043558b5428d8f1c35b16" id="r_a4a6fdd4df7c043558b5428d8f1c35b16"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4a6fdd4df7c043558b5428d8f1c35b16">getCoordinateDimension</a> () const</td></tr>
<tr class="memdesc:a4a6fdd4df7c043558b5428d8f1c35b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this object.  <br /></td></tr>
<tr class="separator:a4a6fdd4df7c043558b5428d8f1c35b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c4f4d75ec84fa225a9a4dee0a609c1" id="r_a35c4f4d75ec84fa225a9a4dee0a609c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a35c4f4d75ec84fa225a9a4dee0a609c1">CoordinateDimension</a> () const</td></tr>
<tr class="memdesc:a35c4f4d75ec84fa225a9a4dee0a609c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this object.  <br /></td></tr>
<tr class="separator:a35c4f4d75ec84fa225a9a4dee0a609c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681c8b8f8136764fd689ffbce24085d3" id="r_a681c8b8f8136764fd689ffbce24085d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3">IsValid</a> () const</td></tr>
<tr class="memdesc:a681c8b8f8136764fd689ffbce24085d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is valid.  <br /></td></tr>
<tr class="separator:a681c8b8f8136764fd689ffbce24085d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700a2d4b1c719e1f65fa3009bfc04f78" id="r_a700a2d4b1c719e1f65fa3009bfc04f78"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a700a2d4b1c719e1f65fa3009bfc04f78">MakeValid</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:a700a2d4b1c719e1f65fa3009bfc04f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to make an invalid geometry valid without losing vertices.  <br /></td></tr>
<tr class="separator:a700a2d4b1c719e1f65fa3009bfc04f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa518a2cafc2a2394bc3a5196fa7dd017" id="r_aa518a2cafc2a2394bc3a5196fa7dd017"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa518a2cafc2a2394bc3a5196fa7dd017">Normalize</a> () const</td></tr>
<tr class="memdesc:aa518a2cafc2a2394bc3a5196fa7dd017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to bring geometry into normalized/canonical form.  <br /></td></tr>
<tr class="separator:aa518a2cafc2a2394bc3a5196fa7dd017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe41ef903c94999a81a98c356b32e624" id="r_afe41ef903c94999a81a98c356b32e624"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afe41ef903c94999a81a98c356b32e624">IsSimple</a> () const</td></tr>
<tr class="memdesc:afe41ef903c94999a81a98c356b32e624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is simple.  <br /></td></tr>
<tr class="separator:afe41ef903c94999a81a98c356b32e624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9867dbbd6b840ca9c9240c7cb9c3b8c" id="r_ae9867dbbd6b840ca9c9240c7cb9c3b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae9867dbbd6b840ca9c9240c7cb9c3b8c">Is3D</a> () const</td></tr>
<tr class="separator:ae9867dbbd6b840ca9c9240c7cb9c3b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959d5776c17018e362b580b1e61e1caa" id="r_a959d5776c17018e362b580b1e61e1caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a959d5776c17018e362b580b1e61e1caa">IsMeasured</a> () const</td></tr>
<tr class="separator:a959d5776c17018e362b580b1e61e1caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3c69f5b89fa5eb0bfb03e4880822bf" id="r_afe3c69f5b89fa5eb0bfb03e4880822bf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afe3c69f5b89fa5eb0bfb03e4880822bf">IsRing</a> () const</td></tr>
<tr class="memdesc:afe3c69f5b89fa5eb0bfb03e4880822bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is a ring.  <br /></td></tr>
<tr class="separator:afe3c69f5b89fa5eb0bfb03e4880822bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2231c970e4075202cafb4f6a69e07e6" id="r_ae2231c970e4075202cafb4f6a69e07e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae2231c970e4075202cafb4f6a69e07e6">importFromWkb</a> (const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *, size_t=static_cast&lt; size_t &gt;(-1), <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>)</td></tr>
<tr class="memdesc:ae2231c970e4075202cafb4f6a69e07e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known binary data.  <br /></td></tr>
<tr class="separator:ae2231c970e4075202cafb4f6a69e07e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4bcfa2fd949bf8c889a1b128a6dbb5" id="r_abf4bcfa2fd949bf8c889a1b128a6dbb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abf4bcfa2fd949bf8c889a1b128a6dbb5">exportToWkb</a> (<a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>, unsigned char *, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>) const</td></tr>
<tr class="memdesc:abf4bcfa2fd949bf8c889a1b128a6dbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known binary format.  <br /></td></tr>
<tr class="separator:abf4bcfa2fd949bf8c889a1b128a6dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3989a0ff917a1e46d02170033996329" id="r_ac3989a0ff917a1e46d02170033996329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac3989a0ff917a1e46d02170033996329">getIsoGeometryType</a> () const</td></tr>
<tr class="memdesc:ac3989a0ff917a1e46d02170033996329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the geometry type that conforms with ISO SQL/MM Part3.  <br /></td></tr>
<tr class="separator:ac3989a0ff917a1e46d02170033996329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8836b9e2d6a79eee8f88c61718e1e50" id="r_ae8836b9e2d6a79eee8f88c61718e1e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae8836b9e2d6a79eee8f88c61718e1e50">dumpReadable</a> (FILE *, const char *=nullptr, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:ae8836b9e2d6a79eee8f88c61718e1e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump geometry in well known text format to indicated output file.  <br /></td></tr>
<tr class="separator:ae8836b9e2d6a79eee8f88c61718e1e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360570554fcd805f9fe673062ba5a22b" id="r_a360570554fcd805f9fe673062ba5a22b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a360570554fcd805f9fe673062ba5a22b">dumpReadable</a> (const char *=nullptr, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:a360570554fcd805f9fe673062ba5a22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump geometry in well known text format to indicated output file.  <br /></td></tr>
<tr class="separator:a360570554fcd805f9fe673062ba5a22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd63002f416db1ea0eb24857b5ef9f2" id="r_abbd63002f416db1ea0eb24857b5ef9f2"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abbd63002f416db1ea0eb24857b5ef9f2">exportToGML</a> (const char *const *papszOptions=nullptr) const</td></tr>
<tr class="memdesc:abbd63002f416db1ea0eb24857b5ef9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GML format.  <br /></td></tr>
<tr class="separator:abbd63002f416db1ea0eb24857b5ef9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73487475ea43a2e677fe0556bf738e0" id="r_ab73487475ea43a2e677fe0556bf738e0"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab73487475ea43a2e677fe0556bf738e0">exportToKML</a> () const</td></tr>
<tr class="memdesc:ab73487475ea43a2e677fe0556bf738e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into KML format.  <br /></td></tr>
<tr class="separator:ab73487475ea43a2e677fe0556bf738e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39899a5c670d2475281cbf5adf8fa97" id="r_af39899a5c670d2475281cbf5adf8fa97"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af39899a5c670d2475281cbf5adf8fa97">exportToJson</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:af39899a5c670d2475281cbf5adf8fa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <br /></td></tr>
<tr class="separator:af39899a5c670d2475281cbf5adf8fa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7e235d77963d37072814601e31c195" id="r_a1c7e235d77963d37072814601e31c195"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__geometry_8h.html#adc1d7838410d13f36b3fa41c17a1a57e">GEOSGeom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1c7e235d77963d37072814601e31c195">exportToGEOS</a> (<a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> hGEOSCtxt) const</td></tr>
<tr class="memdesc:a1c7e235d77963d37072814601e31c195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a GEOSGeom object corresponding to the geometry.  <br /></td></tr>
<tr class="separator:a1c7e235d77963d37072814601e31c195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1068398fd3af02de78bd2b9dbbb837f1" id="r_a1068398fd3af02de78bd2b9dbbb837f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1068398fd3af02de78bd2b9dbbb837f1">getCurveGeometry</a> (const char *const *papszOptions=nullptr) const</td></tr>
<tr class="memdesc:a1068398fd3af02de78bd2b9dbbb837f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return curve version of this geometry.  <br /></td></tr>
<tr class="separator:a1068398fd3af02de78bd2b9dbbb837f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f008712013032d876cc60860d317a33" id="r_a0f008712013032d876cc60860d317a33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33">roundCoordinates</a> (const <a class="el" href="structOGRGeomCoordinatePrecision.html">OGRGeomCoordinatePrecision</a> &amp;sPrecision)</td></tr>
<tr class="memdesc:a0f008712013032d876cc60860d317a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round coordinates of the geometry to the specified precision.  <br /></td></tr>
<tr class="separator:a0f008712013032d876cc60860d317a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3667da6ea2f9416c8f1b747391d0171" id="r_ad3667da6ea2f9416c8f1b747391d0171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad3667da6ea2f9416c8f1b747391d0171">roundCoordinatesIEEE754</a> (const <a class="el" href="structOGRGeomCoordinateBinaryPrecision.html">OGRGeomCoordinateBinaryPrecision</a> &amp;options)</td></tr>
<tr class="memdesc:ad3667da6ea2f9416c8f1b747391d0171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round coordinates of a geometry, exploiting characteristics of the IEEE-754 double-precision binary representation.  <br /></td></tr>
<tr class="separator:ad3667da6ea2f9416c8f1b747391d0171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6cf249316b3046e0d4f77ec400e844" id="r_aeb6cf249316b3046e0d4f77ec400e844"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aeb6cf249316b3046e0d4f77ec400e844">closeRings</a> ()</td></tr>
<tr class="memdesc:aeb6cf249316b3046e0d4f77ec400e844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force rings to be closed.  <br /></td></tr>
<tr class="separator:aeb6cf249316b3046e0d4f77ec400e844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a53c103e37c6d1ead00d2d74586ddd" id="r_a66a53c103e37c6d1ead00d2d74586ddd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a66a53c103e37c6d1ead00d2d74586ddd">getSpatialReference</a> (void) const</td></tr>
<tr class="memdesc:a66a53c103e37c6d1ead00d2d74586ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spatial reference system for object.  <br /></td></tr>
<tr class="separator:a66a53c103e37c6d1ead00d2d74586ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0ec206bcafdd27eef5ef455d366af3" id="r_abc0ec206bcafdd27eef5ef455d366af3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abc0ec206bcafdd27eef5ef455d366af3">transformTo</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSR)</td></tr>
<tr class="memdesc:abc0ec206bcafdd27eef5ef455d366af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform geometry to new spatial reference system.  <br /></td></tr>
<tr class="separator:abc0ec206bcafdd27eef5ef455d366af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4f0b34b165b589ffbef7d3ea65c00c" id="r_aaa4f0b34b165b589ffbef7d3ea65c00c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aaa4f0b34b165b589ffbef7d3ea65c00c">Disjoint</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:aaa4f0b34b165b589ffbef7d3ea65c00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for disjointness.  <br /></td></tr>
<tr class="separator:aaa4f0b34b165b589ffbef7d3ea65c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1be78538ab56a7c16cfa65797eeb0c" id="r_abd1be78538ab56a7c16cfa65797eeb0c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abd1be78538ab56a7c16cfa65797eeb0c">Touches</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:abd1be78538ab56a7c16cfa65797eeb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for touching.  <br /></td></tr>
<tr class="separator:abd1be78538ab56a7c16cfa65797eeb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf30cb59307e8d5889e9fcf71d371afb" id="r_adf30cb59307e8d5889e9fcf71d371afb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#adf30cb59307e8d5889e9fcf71d371afb">Crosses</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:adf30cb59307e8d5889e9fcf71d371afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for crossing.  <br /></td></tr>
<tr class="separator:adf30cb59307e8d5889e9fcf71d371afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9803164ead0c4fbea9eafce64184160c" id="r_a9803164ead0c4fbea9eafce64184160c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9803164ead0c4fbea9eafce64184160c">Within</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a9803164ead0c4fbea9eafce64184160c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <br /></td></tr>
<tr class="separator:a9803164ead0c4fbea9eafce64184160c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432b89868f8094004467e8e9b51ad5ca" id="r_a432b89868f8094004467e8e9b51ad5ca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a432b89868f8094004467e8e9b51ad5ca">Overlaps</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a432b89868f8094004467e8e9b51ad5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for overlap.  <br /></td></tr>
<tr class="separator:a432b89868f8094004467e8e9b51ad5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8eebc159f59a20d63f40539577dde7" id="r_abb8eebc159f59a20d63f40539577dde7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abb8eebc159f59a20d63f40539577dde7">Boundary</a> () const</td></tr>
<tr class="memdesc:abb8eebc159f59a20d63f40539577dde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute boundary.  <br /></td></tr>
<tr class="separator:abb8eebc159f59a20d63f40539577dde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e832f8dc1001de35e9e888a4bae8b3" id="r_a72e832f8dc1001de35e9e888a4bae8b3"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a72e832f8dc1001de35e9e888a4bae8b3">Distance</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a72e832f8dc1001de35e9e888a4bae8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two geometries.  <br /></td></tr>
<tr class="separator:a72e832f8dc1001de35e9e888a4bae8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83020c007c4f3beabe1e01edba173135" id="r_a83020c007c4f3beabe1e01edba173135"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a83020c007c4f3beabe1e01edba173135">ConvexHull</a> () const</td></tr>
<tr class="memdesc:a83020c007c4f3beabe1e01edba173135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convex hull.  <br /></td></tr>
<tr class="separator:a83020c007c4f3beabe1e01edba173135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eebda9322568a50da1cb8bb2bcf0a9e" id="r_a4eebda9322568a50da1cb8bb2bcf0a9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4eebda9322568a50da1cb8bb2bcf0a9e">ConcaveHull</a> (double dfRatio, bool bAllowHoles) const</td></tr>
<tr class="memdesc:a4eebda9322568a50da1cb8bb2bcf0a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute "concave hull" of a geometry.  <br /></td></tr>
<tr class="separator:a4eebda9322568a50da1cb8bb2bcf0a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8694e757f44388bd6da4cf7be696b7e7" id="r_a8694e757f44388bd6da4cf7be696b7e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a8694e757f44388bd6da4cf7be696b7e7">Buffer</a> (double dfDist, int nQuadSegs=30) const</td></tr>
<tr class="memdesc:a8694e757f44388bd6da4cf7be696b7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute buffer of geometry.  <br /></td></tr>
<tr class="separator:a8694e757f44388bd6da4cf7be696b7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac226d1821ce677689f1de12bbe6497b5" id="r_ac226d1821ce677689f1de12bbe6497b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac226d1821ce677689f1de12bbe6497b5">BufferEx</a> (double dfDistance, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions) const</td></tr>
<tr class="memdesc:ac226d1821ce677689f1de12bbe6497b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute buffer of geometry.  <br /></td></tr>
<tr class="separator:ac226d1821ce677689f1de12bbe6497b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fc420ca5d995bfef55adb1819a31f2" id="r_ae2fc420ca5d995bfef55adb1819a31f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae2fc420ca5d995bfef55adb1819a31f2">Intersection</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:ae2fc420ca5d995bfef55adb1819a31f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute intersection.  <br /></td></tr>
<tr class="separator:ae2fc420ca5d995bfef55adb1819a31f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4f808adcccaedbecc29fe034d312dc" id="r_a9e4f808adcccaedbecc29fe034d312dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9e4f808adcccaedbecc29fe034d312dc">Union</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a9e4f808adcccaedbecc29fe034d312dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union.  <br /></td></tr>
<tr class="separator:a9e4f808adcccaedbecc29fe034d312dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94533c5ac2331889ac93089c3316971c" id="r_a94533c5ac2331889ac93089c3316971c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a94533c5ac2331889ac93089c3316971c">UnionCascaded</a> () const</td></tr>
<tr class="memdesc:a94533c5ac2331889ac93089c3316971c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union using cascading.  <br /></td></tr>
<tr class="separator:a94533c5ac2331889ac93089c3316971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744223cab4361ffcdab949cebf27d5ad" id="r_a744223cab4361ffcdab949cebf27d5ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a744223cab4361ffcdab949cebf27d5ad">UnaryUnion</a> () const</td></tr>
<tr class="memdesc:a744223cab4361ffcdab949cebf27d5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of all components of a single geometry.  <br /></td></tr>
<tr class="separator:a744223cab4361ffcdab949cebf27d5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49d7599f955e3d459c4dd13bbf1f9e" id="r_a6f49d7599f955e3d459c4dd13bbf1f9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a6f49d7599f955e3d459c4dd13bbf1f9e">Difference</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a6f49d7599f955e3d459c4dd13bbf1f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute difference.  <br /></td></tr>
<tr class="separator:a6f49d7599f955e3d459c4dd13bbf1f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a5c298bb0dcc4d44500278238e0ac2" id="r_ab0a5c298bb0dcc4d44500278238e0ac2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab0a5c298bb0dcc4d44500278238e0ac2">SymDifference</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:ab0a5c298bb0dcc4d44500278238e0ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute symmetric difference.  <br /></td></tr>
<tr class="separator:ab0a5c298bb0dcc4d44500278238e0ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91787f669b2a148169667e270e7e40df" id="r_a91787f669b2a148169667e270e7e40df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a91787f669b2a148169667e270e7e40df">Centroid</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *poPoint) const</td></tr>
<tr class="memdesc:a91787f669b2a148169667e270e7e40df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometry centroid.  <br /></td></tr>
<tr class="separator:a91787f669b2a148169667e270e7e40df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40909bc6bc40b9aecfdae5cb70160eaa" id="r_a40909bc6bc40b9aecfdae5cb70160eaa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a40909bc6bc40b9aecfdae5cb70160eaa">Simplify</a> (double dTolerance) const</td></tr>
<tr class="memdesc:a40909bc6bc40b9aecfdae5cb70160eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the geometry.  <br /></td></tr>
<tr class="separator:a40909bc6bc40b9aecfdae5cb70160eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951fc5d0043af5794dd08d738e0a1dc" id="r_a3951fc5d0043af5794dd08d738e0a1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3951fc5d0043af5794dd08d738e0a1dc">SimplifyPreserveTopology</a> (double dTolerance) const</td></tr>
<tr class="memdesc:a3951fc5d0043af5794dd08d738e0a1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the geometry while preserving topology.  <br /></td></tr>
<tr class="separator:a3951fc5d0043af5794dd08d738e0a1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b0d68bea79509e675bd773c30eb350" id="r_a45b0d68bea79509e675bd773c30eb350"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a45b0d68bea79509e675bd773c30eb350">DelaunayTriangulation</a> (double dfTolerance, int bOnlyEdges) const</td></tr>
<tr class="memdesc:a45b0d68bea79509e675bd773c30eb350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Delaunay triangulation of the vertices of the geometry.  <br /></td></tr>
<tr class="separator:a45b0d68bea79509e675bd773c30eb350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f35edabf2e5d40a79f07f77d56a2459" id="r_a9f35edabf2e5d40a79f07f77d56a2459"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9f35edabf2e5d40a79f07f77d56a2459">Polygonize</a> () const</td></tr>
<tr class="memdesc:a9f35edabf2e5d40a79f07f77d56a2459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygonizes a set of sparse edges.  <br /></td></tr>
<tr class="separator:a9f35edabf2e5d40a79f07f77d56a2459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e39301afc475f5fff022af690fcf84" id="r_aa2e39301afc475f5fff022af690fcf84"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa2e39301afc475f5fff022af690fcf84">Distance3D</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *poOtherGeom) const</td></tr>
<tr class="memdesc:aa2e39301afc475f5fff022af690fcf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3D distance between two geometries.  <br /></td></tr>
<tr class="separator:aa2e39301afc475f5fff022af690fcf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36db4751a05c870f180fde6f1a6d939c" id="r_a36db4751a05c870f180fde6f1a6d939c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a36db4751a05c870f180fde6f1a6d939c">SetPrecision</a> (double dfGridSize, int nFlags) const</td></tr>
<tr class="memdesc:a36db4751a05c870f180fde6f1a6d939c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the geometry's precision, rounding all its coordinates to the precision grid, and making sure the geometry is still valid.  <br /></td></tr>
<tr class="separator:a36db4751a05c870f180fde6f1a6d939c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef198bb6f7179b2d36b1f6731017876" id="r_a1ef198bb6f7179b2d36b1f6731017876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1ef198bb6f7179b2d36b1f6731017876">toPoint</a> ()</td></tr>
<tr class="memdesc:a1ef198bb6f7179b2d36b1f6731017876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPoint*.  <br /></td></tr>
<tr class="separator:a1ef198bb6f7179b2d36b1f6731017876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5cca70c980cca021c8302c504d5b64" id="r_a3c5cca70c980cca021c8302c504d5b64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3c5cca70c980cca021c8302c504d5b64">toPoint</a> () const</td></tr>
<tr class="memdesc:a3c5cca70c980cca021c8302c504d5b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPoint*.  <br /></td></tr>
<tr class="separator:a3c5cca70c980cca021c8302c504d5b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd76ec529a6930904a43b2adfc987878" id="r_afd76ec529a6930904a43b2adfc987878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afd76ec529a6930904a43b2adfc987878">toCurve</a> ()</td></tr>
<tr class="memdesc:afd76ec529a6930904a43b2adfc987878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurve*.  <br /></td></tr>
<tr class="separator:afd76ec529a6930904a43b2adfc987878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b612c84549091a0c46cc238e6539cc" id="r_ad8b612c84549091a0c46cc238e6539cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad8b612c84549091a0c46cc238e6539cc">toCurve</a> () const</td></tr>
<tr class="memdesc:ad8b612c84549091a0c46cc238e6539cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurve*.  <br /></td></tr>
<tr class="separator:ad8b612c84549091a0c46cc238e6539cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7967ffd22bf483b8bc7f71b46a2c049" id="r_af7967ffd22bf483b8bc7f71b46a2c049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af7967ffd22bf483b8bc7f71b46a2c049">toSimpleCurve</a> ()</td></tr>
<tr class="memdesc:af7967ffd22bf483b8bc7f71b46a2c049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSimpleCurve*.  <br /></td></tr>
<tr class="separator:af7967ffd22bf483b8bc7f71b46a2c049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0eeec8555c96f73e140dc5216c06ad" id="r_adc0eeec8555c96f73e140dc5216c06ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#adc0eeec8555c96f73e140dc5216c06ad">toSimpleCurve</a> () const</td></tr>
<tr class="memdesc:adc0eeec8555c96f73e140dc5216c06ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSimpleCurve*.  <br /></td></tr>
<tr class="separator:adc0eeec8555c96f73e140dc5216c06ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a5ac15aac9b026aa492e67eae4b860" id="r_a33a5ac15aac9b026aa492e67eae4b860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a33a5ac15aac9b026aa492e67eae4b860">toLineString</a> ()</td></tr>
<tr class="memdesc:a33a5ac15aac9b026aa492e67eae4b860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLineString*.  <br /></td></tr>
<tr class="separator:a33a5ac15aac9b026aa492e67eae4b860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb15cf7a6a28edc74a265494de9d3af1" id="r_acb15cf7a6a28edc74a265494de9d3af1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#acb15cf7a6a28edc74a265494de9d3af1">toLineString</a> () const</td></tr>
<tr class="memdesc:acb15cf7a6a28edc74a265494de9d3af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLineString*.  <br /></td></tr>
<tr class="separator:acb15cf7a6a28edc74a265494de9d3af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f9393e2f63e2e40a85ba9a772841da" id="r_a91f9393e2f63e2e40a85ba9a772841da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a91f9393e2f63e2e40a85ba9a772841da">toLinearRing</a> ()</td></tr>
<tr class="memdesc:a91f9393e2f63e2e40a85ba9a772841da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLinearRing*.  <br /></td></tr>
<tr class="separator:a91f9393e2f63e2e40a85ba9a772841da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369f74aa2bae7ae30610c6ba355e681f" id="r_a369f74aa2bae7ae30610c6ba355e681f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a369f74aa2bae7ae30610c6ba355e681f">toLinearRing</a> () const</td></tr>
<tr class="memdesc:a369f74aa2bae7ae30610c6ba355e681f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLinearRing*.  <br /></td></tr>
<tr class="separator:a369f74aa2bae7ae30610c6ba355e681f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f596fd8003bb435c17914edf990578" id="r_ad5f596fd8003bb435c17914edf990578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCircularString.html">OGRCircularString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad5f596fd8003bb435c17914edf990578">toCircularString</a> ()</td></tr>
<tr class="memdesc:ad5f596fd8003bb435c17914edf990578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCircularString*.  <br /></td></tr>
<tr class="separator:ad5f596fd8003bb435c17914edf990578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f93722c76a41392f5d7c9aa04591a6" id="r_a83f93722c76a41392f5d7c9aa04591a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCircularString.html">OGRCircularString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a83f93722c76a41392f5d7c9aa04591a6">toCircularString</a> () const</td></tr>
<tr class="memdesc:a83f93722c76a41392f5d7c9aa04591a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCircularString*.  <br /></td></tr>
<tr class="separator:a83f93722c76a41392f5d7c9aa04591a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddc978b9086ae78999d5f5d4d1f7c41" id="r_abddc978b9086ae78999d5f5d4d1f7c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abddc978b9086ae78999d5f5d4d1f7c41">toCompoundCurve</a> ()</td></tr>
<tr class="memdesc:abddc978b9086ae78999d5f5d4d1f7c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCompoundCurve*.  <br /></td></tr>
<tr class="separator:abddc978b9086ae78999d5f5d4d1f7c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa796ff5f52ba253d503197cfb805c7c6" id="r_aa796ff5f52ba253d503197cfb805c7c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa796ff5f52ba253d503197cfb805c7c6">toCompoundCurve</a> () const</td></tr>
<tr class="memdesc:aa796ff5f52ba253d503197cfb805c7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCompoundCurve*.  <br /></td></tr>
<tr class="separator:aa796ff5f52ba253d503197cfb805c7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55e904eb68aadfbd80715fd0e780234" id="r_af55e904eb68aadfbd80715fd0e780234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSurface.html">OGRSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af55e904eb68aadfbd80715fd0e780234">toSurface</a> ()</td></tr>
<tr class="memdesc:af55e904eb68aadfbd80715fd0e780234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSurface*.  <br /></td></tr>
<tr class="separator:af55e904eb68aadfbd80715fd0e780234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046283abf737cc91f2bdc4c130294180" id="r_a046283abf737cc91f2bdc4c130294180"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRSurface.html">OGRSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a046283abf737cc91f2bdc4c130294180">toSurface</a> () const</td></tr>
<tr class="memdesc:a046283abf737cc91f2bdc4c130294180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSurface*.  <br /></td></tr>
<tr class="separator:a046283abf737cc91f2bdc4c130294180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87abd91a35de5e95c1e0c47941ec0f08" id="r_a87abd91a35de5e95c1e0c47941ec0f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRPolygon.html">OGRPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a87abd91a35de5e95c1e0c47941ec0f08">toPolygon</a> ()</td></tr>
<tr class="memdesc:a87abd91a35de5e95c1e0c47941ec0f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolygon*.  <br /></td></tr>
<tr class="separator:a87abd91a35de5e95c1e0c47941ec0f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc25a15b33f93563366dd32df58cf67" id="r_abdc25a15b33f93563366dd32df58cf67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRPolygon.html">OGRPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abdc25a15b33f93563366dd32df58cf67">toPolygon</a> () const</td></tr>
<tr class="memdesc:abdc25a15b33f93563366dd32df58cf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolygon*.  <br /></td></tr>
<tr class="separator:abdc25a15b33f93563366dd32df58cf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30484d069df37be8587aa63df24f67b5" id="r_a30484d069df37be8587aa63df24f67b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRTriangle.html">OGRTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a30484d069df37be8587aa63df24f67b5">toTriangle</a> ()</td></tr>
<tr class="memdesc:a30484d069df37be8587aa63df24f67b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangle*.  <br /></td></tr>
<tr class="separator:a30484d069df37be8587aa63df24f67b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0a1ac9886ba17b2c0ba135f00efa9e" id="r_aef0a1ac9886ba17b2c0ba135f00efa9e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRTriangle.html">OGRTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aef0a1ac9886ba17b2c0ba135f00efa9e">toTriangle</a> () const</td></tr>
<tr class="memdesc:aef0a1ac9886ba17b2c0ba135f00efa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangle*.  <br /></td></tr>
<tr class="separator:aef0a1ac9886ba17b2c0ba135f00efa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab177badcb46c78c0fa8cfe930d166f" id="r_adab177badcb46c78c0fa8cfe930d166f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#adab177badcb46c78c0fa8cfe930d166f">toCurvePolygon</a> ()</td></tr>
<tr class="memdesc:adab177badcb46c78c0fa8cfe930d166f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurvePolygon*.  <br /></td></tr>
<tr class="separator:adab177badcb46c78c0fa8cfe930d166f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072b2d27e0a908b96b255e8ee6d06ce3" id="r_a072b2d27e0a908b96b255e8ee6d06ce3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a072b2d27e0a908b96b255e8ee6d06ce3">toCurvePolygon</a> () const</td></tr>
<tr class="memdesc:a072b2d27e0a908b96b255e8ee6d06ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurvePolygon*.  <br /></td></tr>
<tr class="separator:a072b2d27e0a908b96b255e8ee6d06ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6520c61231ac4bf430d0755a7d7cf68" id="r_ab6520c61231ac4bf430d0755a7d7cf68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab6520c61231ac4bf430d0755a7d7cf68">toGeometryCollection</a> ()</td></tr>
<tr class="memdesc:ab6520c61231ac4bf430d0755a7d7cf68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRGeometryCollection*.  <br /></td></tr>
<tr class="separator:ab6520c61231ac4bf430d0755a7d7cf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e2f0fdb92a7742d5e0df5797629bf4" id="r_a62e2f0fdb92a7742d5e0df5797629bf4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a62e2f0fdb92a7742d5e0df5797629bf4">toGeometryCollection</a> () const</td></tr>
<tr class="memdesc:a62e2f0fdb92a7742d5e0df5797629bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRGeometryCollection*.  <br /></td></tr>
<tr class="separator:a62e2f0fdb92a7742d5e0df5797629bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e413e3d5b1a387b7c2773742dfbb4a" id="r_ae9e413e3d5b1a387b7c2773742dfbb4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae9e413e3d5b1a387b7c2773742dfbb4a">toMultiPoint</a> ()</td></tr>
<tr class="memdesc:ae9e413e3d5b1a387b7c2773742dfbb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPoint*.  <br /></td></tr>
<tr class="separator:ae9e413e3d5b1a387b7c2773742dfbb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1502ed8bb9f88df9170f65e24fae3936" id="r_a1502ed8bb9f88df9170f65e24fae3936"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1502ed8bb9f88df9170f65e24fae3936">toMultiPoint</a> () const</td></tr>
<tr class="memdesc:a1502ed8bb9f88df9170f65e24fae3936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPoint*.  <br /></td></tr>
<tr class="separator:a1502ed8bb9f88df9170f65e24fae3936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd1a8c63662855f47c78b6b675853e9" id="r_a4fd1a8c63662855f47c78b6b675853e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4fd1a8c63662855f47c78b6b675853e9">toMultiLineString</a> ()</td></tr>
<tr class="memdesc:a4fd1a8c63662855f47c78b6b675853e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiLineString*.  <br /></td></tr>
<tr class="separator:a4fd1a8c63662855f47c78b6b675853e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4cabf8127b3571817fe67d54aa0f54" id="r_a6b4cabf8127b3571817fe67d54aa0f54"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a6b4cabf8127b3571817fe67d54aa0f54">toMultiLineString</a> () const</td></tr>
<tr class="memdesc:a6b4cabf8127b3571817fe67d54aa0f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiLineString*.  <br /></td></tr>
<tr class="separator:a6b4cabf8127b3571817fe67d54aa0f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb1f2884c158183f0a26e21d286a6fe" id="r_abdb1f2884c158183f0a26e21d286a6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abdb1f2884c158183f0a26e21d286a6fe">toMultiPolygon</a> ()</td></tr>
<tr class="memdesc:abdb1f2884c158183f0a26e21d286a6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPolygon*.  <br /></td></tr>
<tr class="separator:abdb1f2884c158183f0a26e21d286a6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182d745b59cd11a32f8648807542198c" id="r_a182d745b59cd11a32f8648807542198c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a182d745b59cd11a32f8648807542198c">toMultiPolygon</a> () const</td></tr>
<tr class="memdesc:a182d745b59cd11a32f8648807542198c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPolygon*.  <br /></td></tr>
<tr class="separator:a182d745b59cd11a32f8648807542198c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa684011d14e4ede49063df21618e9178" id="r_aa684011d14e4ede49063df21618e9178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa684011d14e4ede49063df21618e9178">toMultiCurve</a> ()</td></tr>
<tr class="memdesc:aa684011d14e4ede49063df21618e9178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiCurve*.  <br /></td></tr>
<tr class="separator:aa684011d14e4ede49063df21618e9178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcdeb95ced81296a1cc755725e79bc0" id="r_a0fcdeb95ced81296a1cc755725e79bc0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0fcdeb95ced81296a1cc755725e79bc0">toMultiCurve</a> () const</td></tr>
<tr class="memdesc:a0fcdeb95ced81296a1cc755725e79bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiCurve*.  <br /></td></tr>
<tr class="separator:a0fcdeb95ced81296a1cc755725e79bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cd804e21956e330179475b067ded9b" id="r_a57cd804e21956e330179475b067ded9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a57cd804e21956e330179475b067ded9b">toMultiSurface</a> ()</td></tr>
<tr class="memdesc:a57cd804e21956e330179475b067ded9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiSurface*.  <br /></td></tr>
<tr class="separator:a57cd804e21956e330179475b067ded9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebef1fb440b811267692c07745b83c9" id="r_a1ebef1fb440b811267692c07745b83c9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1ebef1fb440b811267692c07745b83c9">toMultiSurface</a> () const</td></tr>
<tr class="memdesc:a1ebef1fb440b811267692c07745b83c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiSurface*.  <br /></td></tr>
<tr class="separator:a1ebef1fb440b811267692c07745b83c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e69ef12c587116ba0ff10090b54c229" id="r_a1e69ef12c587116ba0ff10090b54c229"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1e69ef12c587116ba0ff10090b54c229">toPolyhedralSurface</a> ()</td></tr>
<tr class="memdesc:a1e69ef12c587116ba0ff10090b54c229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolyhedralSurface*.  <br /></td></tr>
<tr class="separator:a1e69ef12c587116ba0ff10090b54c229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124c69073f92a84cffc6d037030c186c" id="r_a124c69073f92a84cffc6d037030c186c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a124c69073f92a84cffc6d037030c186c">toPolyhedralSurface</a> () const</td></tr>
<tr class="memdesc:a124c69073f92a84cffc6d037030c186c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolyhedralSurface*.  <br /></td></tr>
<tr class="separator:a124c69073f92a84cffc6d037030c186c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8717aa2f4ddbca33c2274f7e4af4f68" id="r_af8717aa2f4ddbca33c2274f7e4af4f68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af8717aa2f4ddbca33c2274f7e4af4f68">toTriangulatedSurface</a> ()</td></tr>
<tr class="memdesc:af8717aa2f4ddbca33c2274f7e4af4f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangulatedSurface*.  <br /></td></tr>
<tr class="separator:af8717aa2f4ddbca33c2274f7e4af4f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed98a3466303ca6522c397e5025c1375" id="r_aed98a3466303ca6522c397e5025c1375"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aed98a3466303ca6522c397e5025c1375">toTriangulatedSurface</a> () const</td></tr>
<tr class="memdesc:aed98a3466303ca6522c397e5025c1375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangulatedSurface*.  <br /></td></tr>
<tr class="separator:aed98a3466303ca6522c397e5025c1375"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adc3083a9978cf5ad3658b1b86342e256" id="r_adc3083a9978cf5ad3658b1b86342e256"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#adc3083a9978cf5ad3658b1b86342e256">createGEOSContext</a> ()</td></tr>
<tr class="memdesc:adc3083a9978cf5ad3658b1b86342e256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new GEOS context.  <br /></td></tr>
<tr class="separator:adc3083a9978cf5ad3658b1b86342e256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050eca02b140070855dff24bc5b18800" id="r_a050eca02b140070855dff24bc5b18800"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a050eca02b140070855dff24bc5b18800">freeGEOSContext</a> (<a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> hGEOSCtxt)</td></tr>
<tr class="memdesc:a050eca02b140070855dff24bc5b18800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a GEOS context.  <br /></td></tr>
<tr class="separator:a050eca02b140070855dff24bc5b18800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae518798c9e80bad59b0907f43d375876" id="r_ae518798c9e80bad59b0907f43d375876"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae518798c9e80bad59b0907f43d375876">ToHandle</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *poGeom)</td></tr>
<tr class="memdesc:ae518798c9e80bad59b0907f43d375876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRGeometry* to a OGRGeometryH.  <br /></td></tr>
<tr class="separator:ae518798c9e80bad59b0907f43d375876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2fa3e96b586f11bf6aedeccf73d600" id="r_a5c2fa3e96b586f11bf6aedeccf73d600"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5c2fa3e96b586f11bf6aedeccf73d600">FromHandle</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a5c2fa3e96b586f11bf6aedeccf73d600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRGeometryH to a OGRGeometry*.  <br /></td></tr>
<tr class="separator:a5c2fa3e96b586f11bf6aedeccf73d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a5e903ffdad46a4a225a706dde2ec9fd0" id="r_a5e903ffdad46a4a225a706dde2ec9fd0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRPolygon.html">OGRPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurvePolygon.html#a5e903ffdad46a4a225a706dde2ec9fd0">CastToPolygon</a> (<a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> *poCP)</td></tr>
<tr class="memdesc:a5e903ffdad46a4a225a706dde2ec9fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to polygon.  <br /></td></tr>
<tr class="separator:a5e903ffdad46a4a225a706dde2ec9fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Concrete class representing curve polygons. </p>
<p>Note that curve polygons consist of one outer (curve) ring, and zero or more inner rings. A curve polygon cannot represent disconnected regions (such as multiple islands in a political body). The <a class="el" href="classOGRMultiSurface.html" title="A collection of non-overlapping OGRSurface.">OGRMultiSurface</a> must be used for this.</p>
<p>Compatibility: ISO SQL/MM Part 3.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af8cf10bb3af3893e47b8506813aa2694" name="af8cf10bb3af3893e47b8506813aa2694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cf10bb3af3893e47b8506813aa2694">&#9670;&#160;</a></span>OGRCurvePolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OGRCurvePolygon::OGRCurvePolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Note: before GDAL 2.1, only the default implementation of the constructor existed, which could be unsafe to use.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af5129fb870acd6508fba57b800f7e07a" name="af5129fb870acd6508fba57b800f7e07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5129fb870acd6508fba57b800f7e07a">&#9670;&#160;</a></span>accept() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OGRCurvePolygon::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIOGRConstGeometryVisitor.html">IOGRConstGeometryVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept a visitor. </p>

<p>Implements <a class="el" href="classOGRGeometry.html#a5f659bec82c0184b3bd6592248afda74">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#ad23ed28465887650ec7887da73869e7c">OGRPolygon</a>, and <a class="el" href="classOGRTriangle.html#a6e2c3ed147af7f0c008873b33a918bfe">OGRTriangle</a>.</p>

</div>
</div>
<a id="a43c9af4e0ff50cec5e8662a4fdbd9628" name="a43c9af4e0ff50cec5e8662a4fdbd9628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c9af4e0ff50cec5e8662a4fdbd9628">&#9670;&#160;</a></span>accept() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OGRCurvePolygon::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIOGRGeometryVisitor.html">IOGRGeometryVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept a visitor. </p>

<p>Implements <a class="el" href="classOGRGeometry.html#aa26576c266578a8e83e325881243a166">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#af62d95144d5b6c747b492e40a5698195">OGRPolygon</a>, and <a class="el" href="classOGRTriangle.html#a60102fc842dcd482d95e08af225365bb">OGRTriangle</a>.</p>

</div>
</div>
<a id="ad3e97ce0148e216dc292de5bdec9ad04" name="ad3e97ce0148e216dc292de5bdec9ad04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e97ce0148e216dc292de5bdec9ad04">&#9670;&#160;</a></span>addRing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRCurvePolygon::addRing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td>
          <td class="paramname"><em>poNewRing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a ring to a polygon. </p>
<p>If the polygon has no external ring (it is empty) this will be used as the external ring, otherwise it is used as an internal ring. The passed <a class="el" href="classOGRCurve.html" title="Abstract curve base class for OGRLineString, OGRCircularString and OGRCompoundCurve.">OGRCurve</a> remains the responsibility of the caller (an internal copy is made).</p>
<p>This method has no SFCOM analog.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poNewRing</td><td>ring to be added to the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success </dd></dl>

</div>
</div>
<a id="a018e1aad6353a1f10a38639b51ae549e" name="a018e1aad6353a1f10a38639b51ae549e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018e1aad6353a1f10a38639b51ae549e">&#9670;&#160;</a></span>addRing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRCurvePolygon::addRing </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classOGRCurve.html">OGRCurve</a> &gt;&#160;</td>
          <td class="paramname"><em>poNewRing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a ring to a polygon. </p>
<p>If the polygon has no external ring (it is empty) this will be used as the external ring, otherwise it is used as an internal ring.</p>
<p>This method has no SFCOM analog.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poNewRing</td><td>ring to be added to the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success </dd></dl>

</div>
</div>
<a id="aa2b5dfcc342e2fde2bda9965fe4ac084" name="aa2b5dfcc342e2fde2bda9965fe4ac084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b5dfcc342e2fde2bda9965fe4ac084">&#9670;&#160;</a></span>addRingDirectly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRCurvePolygon::addRingDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td>
          <td class="paramname"><em>poNewRing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a ring to a polygon. </p>
<p>If the polygon has no external ring (it is empty) this will be used as the external ring, otherwise it is used as an internal ring. Ownership of the passed ring is assumed by the <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons.">OGRCurvePolygon</a>, but otherwise this method operates the same as OGRCurvePolygon::AddRing().</p>
<p>This method has no SFCOM analog.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poNewRing</td><td>ring to be added to the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRTriangle.html#a9a9da30d2756287a6b0470200316a9a2">OGRTriangle</a>.</p>

</div>
</div>
<a id="a10ebc5b56476b8fba1c18357c5bc71d2" name="a10ebc5b56476b8fba1c18357c5bc71d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ebc5b56476b8fba1c18357c5bc71d2">&#9670;&#160;</a></span>assignSpatialReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::assignSpatialReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign spatial reference to this object. </p>
<p>Any existing spatial reference is replaced, but under no circumstances does this result in the object being reprojected. It is just changing the interpretation of the existing geometry. Note that assigning a spatial reference increments the reference count on the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>, but does not copy it.</p>
<p>Starting with GDAL 2.3, this will also assign the spatial reference to potential sub-geometries of the geometry (<a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects.">OGRGeometryCollection</a>, OGRCurvePolygon/OGRPolygon, <a class="el" href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves.">OGRCompoundCurve</a>, <a class="el" href="classOGRPolyhedralSurface.html" title="PolyhedralSurface class.">OGRPolyhedralSurface</a> and their derived classes).</p>
<p>This is similar to the SFCOM IGeometry::put_SpatialReference() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536" title="Assign spatial reference to this object.">OGR_G_AssignSpatialReference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSR</td><td>new spatial reference system to apply. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#af57de03effd32d0d09cbdc0ed146b508">OGRGeometry</a>.</p>

</div>
</div>
<a id="ade25a38fd8b97333cf6df3446433bf93" name="ade25a38fd8b97333cf6df3446433bf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade25a38fd8b97333cf6df3446433bf93">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurvePolygon.html#aa63bd732e83f02b4d03d71f2d5d0c36b">ChildType</a> ** OGRCurvePolygon::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return begin of curve iterator. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ad4dd668a46c2b405b1a6dedf26c8b24e" name="ad4dd668a46c2b405b1a6dedf26c8b24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dd668a46c2b405b1a6dedf26c8b24e">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCurvePolygon.html#aa63bd732e83f02b4d03d71f2d5d0c36b">ChildType</a> *const  * OGRCurvePolygon::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return begin of curve iterator. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="abb8eebc159f59a20d63f40539577dde7" name="abb8eebc159f59a20d63f40539577dde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8eebc159f59a20d63f40539577dde7">&#9670;&#160;</a></span>Boundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute boundary. </p>
<p>A new geometry object is created and returned containing the boundary of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b" title="Compute boundary.">OGR_G_Boundary()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a8694e757f44388bd6da4cf7be696b7e7" name="a8694e757f44388bd6da4cf7be696b7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8694e757f44388bd6da4cf7be696b7e7">&#9670;&#160;</a></span>Buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Buffer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nQuadSegs</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>Some buffer sections are properly described as curves, but are converted to approximate polygons. The nQuadSegs parameter can be used to control how many segments should be used to define a 90 degree curve - a quadrant of a circle. A value of 30 is a reasonable default. Large values result in large numbers of vertices in the resulting buffer geometry while small numbers reduce the accuracy of the result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a398ad99b74f10fe63cdf81d8674edfc2" title="Compute buffer of geometry.">OGR_G_Buffer()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfDist</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry.</td></tr>
    <tr><td class="paramname">nQuadSegs</td><td>the number of segments used to approximate a 90 degree (quadrant) of curvature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="ac226d1821ce677689f1de12bbe6497b5" name="ac226d1821ce677689f1de12bbe6497b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac226d1821ce677689f1de12bbe6497b5">&#9670;&#160;</a></span>BufferEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::BufferEx </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p>The following options are supported. See the GEOS library for more detailed descriptions.</p>
<ul>
<li>
ENDCAP_STYLE=ROUND/FLAT/SQUARE </li>
<li>
JOIN_STYLE=ROUND/MITRE/BEVEL </li>
<li>
MITRE_LIMIT=double </li>
<li>
QUADRANT_SEGMENTS=double </li>
<li>
SINGLE_SIDED=YES/NO </li>
</ul>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#aa6daaf8d57da28ab6c45b8a8b3094901" title="Compute buffer of geometry.">OGR_G_BufferEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfDist</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.10 </dd></dl>

</div>
</div>
<a id="a5e903ffdad46a4a225a706dde2ec9fd0" name="a5e903ffdad46a4a225a706dde2ec9fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e903ffdad46a4a225a706dde2ec9fd0">&#9670;&#160;</a></span>CastToPolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPolygon.html">OGRPolygon</a> * OGRCurvePolygon::CastToPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> *&#160;</td>
          <td class="paramname"><em>poCP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to polygon. </p>
<p>This method should only be called if the curve polygon actually only contains instances of <a class="el" href="classOGRLineString.html" title="Concrete representation of a multi-vertex line.">OGRLineString</a>. This can be verified if hasCurveGeometry(TRUE) returns FALSE. It is not intended to approximate curve polygons. For that use <a class="el" href="classOGRCurvePolygon.html#a10c3cdd9accf2547e975ddb78558e9b4" title="Return, possibly approximate, non-curve version of this geometry.">getLinearGeometry()</a>.</p>
<p>The passed in geometry is consumed and a new one returned (or NULL in case of failure).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poCP</td><td>the input geometry - ownership is passed to the method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new geometry. </dd></dl>

</div>
</div>
<a id="a91787f669b2a148169667e270e7e40df" name="a91787f669b2a148169667e270e7e40df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91787f669b2a148169667e270e7e40df">&#9670;&#160;</a></span>Centroid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::Centroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td>
          <td class="paramname"><em>poPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the geometry centroid. </p>
<p>The centroid location is applied to the passed in <a class="el" href="classOGRPoint.html" title="Point class.">OGRPoint</a> object. The centroid is not necessarily within the geometry.</p>
<p>This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b" title="Compute the geometry centroid.">OGR_G_Centroid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or OGRERR_FAILURE on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 as a <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes.">OGRGeometry</a> method (previously was restricted to <a class="el" href="classOGRPolygon.html" title="Concrete class representing polygons.">OGRPolygon</a>) </dd></dl>

</div>
</div>
<a id="a42f4a0d3345503d5d62f29cb94eb2897" name="a42f4a0d3345503d5d62f29cb94eb2897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f4a0d3345503d5d62f29cb94eb2897">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> * OGRCurvePolygon::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of this object. </p>
<p>This method relates to the SFCOM IGeometry::clone() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa" title="Make a copy of this object.">OGR_G_Clone()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a new object instance with the same geometry, and spatial reference system as the original. </dd></dl>

<p>Implements <a class="el" href="classOGRSurface.html#a88b6df709dfac2c3341557590740d798">OGRSurface</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a87e553f0a6deb34c5f82d03525c67deb">OGRPolygon</a>, and <a class="el" href="classOGRTriangle.html#ae9414992391e52bc24c96aca8fc1b7a9">OGRTriangle</a>.</p>

</div>
</div>
<a id="aeb6cf249316b3046e0d4f77ec400e844" name="aeb6cf249316b3046e0d4f77ec400e844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6cf249316b3046e0d4f77ec400e844">&#9670;&#160;</a></span>closeRings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::closeRings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force rings to be closed. </p>
<p>If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end. </p>

<p>Reimplemented in <a class="el" href="classOGRLinearRing.html#aa094e3579479b77a9dfbcafd91a3f366">OGRLinearRing</a>, <a class="el" href="classOGRPolygon.html#aff7bce5d2c53421164b31cc9cb803d03">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a53b4239519af6079fa735e9d91938d5c">OGRGeometryCollection</a>.</p>

</div>
</div>
<a id="a4eebda9322568a50da1cb8bb2bcf0a9e" name="a4eebda9322568a50da1cb8bb2bcf0a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eebda9322568a50da1cb8bb2bcf0a9e">&#9670;&#160;</a></span>ConcaveHull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::ConcaveHull </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowHoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute "concave hull" of a geometry. </p>
<p>The concave hull is fully contained within the convex hull and also contains all the points of the input, but in a smaller area. The area ratio is the ratio of the area of the convex hull and the concave hull. Frequently used to convert a multi-point into a polygonal area. that contains all the points in the input Geometry.</p>
<p>A new geometry object is created and returned containing the concave hull of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a32f11850c5ed2f86b99e4682178c6797" title="Compute &quot;concave hull&quot; of a geometry.">OGR_G_ConcaveHull()</a>.</p>
<p>This method is built on the GEOS &gt;= 3.11 library If OGR is built without the GEOS &gt;= 3.11 librray, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfRatio</td><td>Ratio of the area of the convex hull and the concave hull. </td></tr>
    <tr><td class="paramname">bAllowHoles</td><td>Whether holes are allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a3e60f2ed59b940cf72746a2b9c4dfe18" name="a3e60f2ed59b940cf72746a2b9c4dfe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e60f2ed59b940cf72746a2b9c4dfe18">&#9670;&#160;</a></span>Contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRCurvePolygon::Contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if actual geometry object contains the passed geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8" title="Test for containment.">OGR_G_Contains()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if poOtherGeom contains this geometry, otherwise FALSE. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#ae818178178f80c2987c6173ab4da041e">OGRGeometry</a>.</p>

</div>
</div>
<a id="a83020c007c4f3beabe1e01edba173135" name="a83020c007c4f3beabe1e01edba173135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83020c007c4f3beabe1e01edba173135">&#9670;&#160;</a></span>ConvexHull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::ConvexHull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute convex hull. </p>
<p>A new geometry object is created and returned containing the convex hull of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7a93026cfae8ee6ce25546dba1b2df7d" title="Compute convex hull.">OGR_G_ConvexHull()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a35c4f4d75ec84fa225a9a4dee0a609c1" name="a35c4f4d75ec84fa225a9a4dee0a609c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c4f4d75ec84fa225a9a4dee0a609c1">&#9670;&#160;</a></span>CoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::CoordinateDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this object. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac4843a200c0c4e57bbdc99e509f68baf" title="Get the dimension of the coordinates in this geometry.">OGR_G_CoordinateDimension()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="adc3083a9978cf5ad3658b1b86342e256" name="adc3083a9978cf5ad3658b1b86342e256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3083a9978cf5ad3658b1b86342e256">&#9670;&#160;</a></span>createGEOSContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> OGRGeometry::createGEOSContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new GEOS context. </p>
<dl class="section return"><dt>Returns</dt><dd>a new GEOS context. </dd></dl>

</div>
</div>
<a id="adf30cb59307e8d5889e9fcf71d371afb" name="adf30cb59307e8d5889e9fcf71d371afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf30cb59307e8d5889e9fcf71d371afb">&#9670;&#160;</a></span>Crosses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Crosses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for crossing. </p>
<p>Tests if this geometry and the other passed into the method are crossing.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c" title="Test for crossing.">OGR_G_Crosses()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are crossing, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a4c0a7361f3b88736fa98145f8770bc0a" name="a4c0a7361f3b88736fa98145f8770bc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0a7361f3b88736fa98145f8770bc0a">&#9670;&#160;</a></span>CurvePolyToPoly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPolygon.html">OGRPolygon</a> * OGRCurvePolygon::CurvePolyToPoly </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a polygon from a curve polygon. </p>
<p>This method is the same as C function OGR_G_CurvePolyToPoly().</p>
<p>The returned geometry is a new instance whose ownership belongs to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. Unused for now. Must be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a linestring</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a7e5a3f9a67e18e045167832c5b8ff850">OGRPolygon</a>.</p>

</div>
</div>
<a id="a45b0d68bea79509e675bd773c30eb350" name="a45b0d68bea79509e675bd773c30eb350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b0d68bea79509e675bd773c30eb350">&#9670;&#160;</a></span>DelaunayTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::DelaunayTriangulation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bOnlyEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a Delaunay triangulation of the vertices of the geometry. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#acf65b24716b3538cb883de3fa0d35a8a" title="Return a Delaunay triangulation of the vertices of the geometry.">OGR_G_DelaunayTriangulation()</a>.</p>
<p>This function is built on the GEOS library, v3.4 or above. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfTolerance</td><td>optional snapping tolerance to use for improved robustness </td></tr>
    <tr><td class="paramname">bOnlyEdges</td><td>if TRUE, will return a MULTILINESTRING, otherwise it will return a GEOMETRYCOLLECTION containing triangular POLYGONs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry resulting from the Delaunay triangulation or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.1 </dd></dl>

</div>
</div>
<a id="a6f49d7599f955e3d459c4dd13bbf1f9e" name="a6f49d7599f955e3d459c4dd13bbf1f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f49d7599f955e3d459c4dd13bbf1f9e">&#9670;&#160;</a></span>Difference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute difference. </p>
<p>Generates a new geometry which is the region of this geometry with the region of the second geometry removed.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a497977bec6ecd9dade7a9694f776be64" title="Compute difference.">OGR_G_Difference()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry removed from "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the difference or NULL if the difference is empty or an error occurs. </dd></dl>

</div>
</div>
<a id="aaa4f0b34b165b589ffbef7d3ea65c00c" name="aaa4f0b34b165b589ffbef7d3ea65c00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4f0b34b165b589ffbef7d3ea65c00c">&#9670;&#160;</a></span>Disjoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Disjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for disjointness. </p>
<p>Tests if this geometry and the other passed into the method are disjoint.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503" title="Test for disjointness.">OGR_G_Disjoint()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are disjoint, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a72e832f8dc1001de35e9e888a4bae8b3" name="a72e832f8dc1001de35e9e888a4bae8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e832f8dc1001de35e9e888a4bae8b3">&#9670;&#160;</a></span>Distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeometry::Distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute distance between two geometries. </p>
<p>Returns the shortest distance between the two geometries. The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401" title="Compute distance between two geometries.">OGR_G_Distance()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the geometries or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="aa2e39301afc475f5fff022af690fcf84" name="aa2e39301afc475f5fff022af690fcf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e39301afc475f5fff022af690fcf84">&#9670;&#160;</a></span>Distance3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeometry::Distance3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 3D distance between two geometries. </p>
<p>The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is built on the SFCGAL library, check it for the definition of the geometry operation. If OGR is built without the SFCGAL library, this method will always return -1.0</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a7313a805a15bf78a26c52ff1bc6242e2" title="Returns the 3D distance between two geometries.">OGR_G_Distance3D()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>distance between the two geometries </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a360570554fcd805f9fe673062ba5a22b" name="a360570554fcd805f9fe673062ba5a22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360570554fcd805f9fe673062ba5a22b">&#9670;&#160;</a></span>dumpReadable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string OGRGeometry::dumpReadable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump geometry in well known text format to indicated output file. </p>
<p>A few options can be defined to change the default dump : </p><ul>
<li>
DISPLAY_GEOMETRY=NO : to hide the dump of the geometry </li>
<li>
DISPLAY_GEOMETRY=WKT or YES (default) : dump the geometry as a WKT </li>
<li>
DISPLAY_GEOMETRY=SUMMARY : to get only a summary of the geometry </li>
<li>
XY_COORD_PRECISION=integer: number of decimal figures for X,Y coordinates in WKT (added in GDAL 3.9) </li>
<li>
Z_COORD_PRECISION=integer: number of decimal figures for Z coordinates in WKT (added in GDAL 3.9) </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPrefix</td><td>the prefix to put on each line of output. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the geometry representation. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="ae8836b9e2d6a79eee8f88c61718e1e50" name="ae8836b9e2d6a79eee8f88c61718e1e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8836b9e2d6a79eee8f88c61718e1e50">&#9670;&#160;</a></span>dumpReadable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::dumpReadable </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump geometry in well known text format to indicated output file. </p>
<p>A few options can be defined to change the default dump : </p><ul>
<li>
DISPLAY_GEOMETRY=NO : to hide the dump of the geometry </li>
<li>
DISPLAY_GEOMETRY=WKT or YES (default) : dump the geometry as a WKT </li>
<li>
DISPLAY_GEOMETRY=SUMMARY : to get only a summary of the geometry </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f" title="Dump geometry in well known text format to indicated output file.">OGR_G_DumpReadable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>the text file to write the geometry to. </td></tr>
    <tr><td class="paramname">pszPrefix</td><td>the prefix to put on each line of output. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f8b6b73430f36513a65d27f556e796d" name="a4f8b6b73430f36513a65d27f556e796d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8b6b73430f36513a65d27f556e796d">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear geometry information. </p>
<p>This restores the geometry to its initial state after construction, and before assignment of actual geometry.</p>
<p>This method relates to the SFCOM IGeometry::Empty() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2" title="Clear geometry information.">OGR_G_Empty()</a>. </p>

<p>Implements <a class="el" href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05">OGRGeometry</a>.</p>

</div>
</div>
<a id="a866bf18d2c0a73d1ced4ff982aee6c25" name="a866bf18d2c0a73d1ced4ff982aee6c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866bf18d2c0a73d1ced4ff982aee6c25">&#9670;&#160;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRCurvePolygon::Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE if two geometries are equivalent. </p>
<p>This operation implements the SQL/MM ST_OrderingEquals() operation.</p>
<p>The comparison is done in a structural way, that is to say that the geometry types must be identical, as well as the number and ordering of sub-geometries and vertices. Or equivalently, two geometries are considered equal by this method if their WKT/WKB representation is equal. Note: this must be distinguished for equality in a spatial way (which is the purpose of the ST_Equals() operation).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3" title="Returns TRUE if two geometries are equivalent.">OGR_G_Equals()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a1b80c7f464de1d332215f16d35138590">OGRGeometry</a>.</p>

</div>
</div>
<a id="a1c7e235d77963d37072814601e31c195" name="a1c7e235d77963d37072814601e31c195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7e235d77963d37072814601e31c195">&#9670;&#160;</a></span>exportToGEOS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__geometry_8h.html#adc1d7838410d13f36b3fa41c17a1a57e">GEOSGeom</a> OGRGeometry::exportToGEOS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td>
          <td class="paramname"><em>hGEOSCtxt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a GEOSGeom object corresponding to the geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGEOSCtxt</td><td>GEOS context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a GEOSGeom object corresponding to the geometry. </dd></dl>

</div>
</div>
<a id="abbd63002f416db1ea0eb24857b5ef9f2" name="abbd63002f416db1ea0eb24857b5ef9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd63002f416db1ea0eb24857b5ef9f2">&#9670;&#160;</a></span>exportToGML()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToGML </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>The supported options are : </p><ul>
<li>
FORMAT=GML2/GML3/GML32 (GML2 or GML32 added in GDAL 2.1). If not set, it will default to GML 2.1.2 output.  </li>
<li>
GML3_LINESTRING_ELEMENT=curve. (Only valid for FORMAT=GML3) To use gml:Curve element for linestrings. Otherwise gml:LineString will be used .  </li>
<li>
GML3_LONGSRS=YES/NO. (Only valid for FORMAT=GML3, deprecated by SRSNAME_FORMAT in GDAL &gt;=2.2). Defaults to YES. If YES, SRS with EPSG authority will be written with the "urn:ogc:def:crs:EPSG::" prefix. In the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it. If set to NO, SRS with EPSG authority will be written with the "EPSG:" prefix, even if they are in lat/long order.  </li>
<li>
SRSNAME_FORMAT=SHORT/OGC_URN/OGC_URL (Only valid for FORMAT=GML3, added in GDAL 2.2). Defaults to OGC_URN. If SHORT, then srsName will be in the form AUTHORITY_NAME:AUTHORITY_CODE. If OGC_URN, then srsName will be in the form urn:ogc:def:crs:AUTHORITY_NAME::AUTHORITY_CODE. If OGC_URL, then srsName will be in the form <a href="http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE">http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE</a>. For OGC_URN and OGC_URL, in the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it.  </li>
<li>
GMLID=astring. If specified, a gml:id attribute will be written in the top-level geometry element with the provided value. Required for GML 3.2 compatibility.  </li>
<li>
SRSDIMENSION_LOC=POSLIST/GEOMETRY/GEOMETRY,POSLIST. (Only valid for FORMAT=GML3/GML32, GDAL &gt;= 2.0) Default to POSLIST. For 2.5D geometries, define the location where to attach the srsDimension attribute. There are diverging implementations. Some put in on the &lt;gml:posList&gt; element, other on the top geometry element.  </li>
<li>
NAMESPACE_DECL=YES/NO. If set to YES, xmlns:gml="http://www.opengis.net/gml" will be added to the root node for GML &lt; 3.2 or xmlns:gml="http://www.opengis.net/gml/3.2" for GML 3.2  </li>
<li>
XY_COORD_RESOLUTION=double (added in GDAL 3.9): Resolution for the coordinate precision of the X and Y coordinates. Expressed in the units of the X and Y axis of the SRS. eg 1e-5 for up to 5 decimal digits. 0 for the default behavior.  </li>
<li>
Z_COORD_RESOLUTION=double (added in GDAL 3.9): Resolution for the coordinate precision of the Z coordinates. Expressed in the units of the Z axis of the SRS. 0 for the default behavior.  </li>
</ul>
<p>This method is the same as the C function OGR_G_ExportToGMLEx().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="af39899a5c670d2475281cbf5adf8fa97" name="af39899a5c670d2475281cbf5adf8fa97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39899a5c670d2475281cbf5adf8fa97">&#9670;&#160;</a></span>exportToJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToJson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>The following options are supported : </p><ul>
<li>
XY_COORD_PRECISION=integer: number of decimal figures for X,Y coordinates (added in GDAL 3.9) </li>
<li>
Z_COORD_PRECISION=integer: number of decimal figures for Z coordinates (added in GDAL 3.9) </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad42a1d3da3b4f13ff2185342afb546e2" title="Convert a geometry into GeoJSON format.">OGR_G_ExportToJson()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>Null terminated list of options, or null (added in 3.9) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GeoJSON fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="ab73487475ea43a2e677fe0556bf738e0" name="ab73487475ea43a2e677fe0556bf738e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73487475ea43a2e677fe0556bf738e0">&#9670;&#160;</a></span>exportToKML()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToKML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into KML format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7f73b8d9f32fda331b804fd0cd59c087" title="Convert a geometry into KML format.">OGR_G_ExportToKML()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A KML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="abf4bcfa2fd949bf8c889a1b128a6dbb5" name="abf4bcfa2fd949bf8c889a1b128a6dbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4bcfa2fd949bf8c889a1b128a6dbb5">&#9670;&#160;</a></span>exportToWkb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::exportToWkb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>&#160;</td>
          <td class="paramname"><em>eByteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6" title="Convert a geometry well known binary format.">OGR_G_ExportToWkb()</a> or <a class="el" href="ogr__api_8h.html#a622a18776e6d51515d0f2ff0ee211d91" title="Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format.">OGR_G_ExportToIsoWkb()</a>, depending on the value of eWkbVariant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eByteOrder</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td class="paramname">pabyData</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation.">OGRGeometry::WkbSize()</a> byte in size. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>What standard to use when exporting geometries with three dimensions (or more). The default wkbVariantOldOgc is the historical OGR variant. wkbVariantIso is the variant defined in ISO SQL/MM and adopted by OGC for SFSQL 1.2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

</div>
</div>
<a id="acce34b5497984619d0fb14f831856313" name="acce34b5497984619d0fb14f831856313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce34b5497984619d0fb14f831856313">&#9670;&#160;</a></span>exportToWkb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRCurvePolygon::exportToWkb </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyDstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *&#160;</td>
          <td class="paramname"><em>psOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ae18ca8de10fb5fc90705d4e91791566f" title="Convert a geometry into well known binary format.">OGR_G_ExportToWkbEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyDstBuffer</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a> byte in size. </td></tr>
    <tr><td class="paramname">psOptions</td><td>WKB export options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a96db112c727147a65329c1eea1ca57b4">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#aa568fca9b0225756a8d8e50fa20852bf">OGRPolygon</a>.</p>

</div>
</div>
<a id="ad17cfebfd9826a22763dff6280ba196e" name="ad17cfebfd9826a22763dff6280ba196e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17cfebfd9826a22763dff6280ba196e">&#9670;&#160;</a></span>exportToWkt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszDstText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>variant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into well known text format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb" title="Convert a geometry into well known text format.">OGR_G_ExportToWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszDstText</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>. </td></tr>
    <tr><td class="paramname">variant</td><td>the specification that must be conformed too :<ul>
<li>wkbVariantOgc for old-style 99-402 extended dimension (Z) WKB types</li>
<li>wkbVariantIso for SFSQL 1.2 and ISO SQL/MM Part 3</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

</div>
</div>
<a id="a09338292b7382ade8d59a5fa40867f4b" name="a09338292b7382ade8d59a5fa40867f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09338292b7382ade8d59a5fa40867f4b">&#9670;&#160;</a></span>exportToWkt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string OGRCurvePolygon::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOGRWktOptions.html">OGRWktOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="structOGRWktOptions.html">OGRWktOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>err</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export a curve polygon to WKT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Output options. </td></tr>
    <tr><td class="paramname">err</td><td>Pointer to error code, if desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WKT representation of the curve polygon. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#afc5e4417e06fb4726ba80461b30aa289">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a02ff39b5de89dcbfdc27315177fccfe1">OGRPolygon</a>, and <a class="el" href="classOGRPolygon.html#a48d826f9d721fe0384b7561a2ade8963">OGRPolygon</a>.</p>

</div>
</div>
<a id="a48d826f9d721fe0384b7561a2ade8963" name="a48d826f9d721fe0384b7561a2ade8963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d826f9d721fe0384b7561a2ade8963">&#9670;&#160;</a></span>exportToWkt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string OGRGeometry::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOGRWktOptions.html">OGRWktOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="structOGRWktOptions.html">OGRWktOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>err</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export a WKT geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Output options. </td></tr>
    <tr><td class="paramname">err</td><td>Pointer to error code, if desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WKT string representing this geometry. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#afc5e4417e06fb4726ba80461b30aa289">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a02ff39b5de89dcbfdc27315177fccfe1">OGRPolygon</a>, and <a class="el" href="classOGRPolygon.html#a48d826f9d721fe0384b7561a2ade8963">OGRPolygon</a>.</p>

</div>
</div>
<a id="a42e2b4087c482df97a2cb8ba6d9eb7c1" name="a42e2b4087c482df97a2cb8ba6d9eb7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e2b4087c482df97a2cb8ba6d9eb7c1">&#9670;&#160;</a></span>flattenTo2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::flattenTo2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert geometry to strictly 2D. </p>
<p>In a sense this converts all Z coordinates to 0.0.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8" title="Convert geometry to strictly 2D.">OGR_G_FlattenTo2D()</a>. </p>

<p>Implements <a class="el" href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9">OGRGeometry</a>.</p>

</div>
</div>
<a id="a050eca02b140070855dff24bc5b18800" name="a050eca02b140070855dff24bc5b18800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050eca02b140070855dff24bc5b18800">&#9670;&#160;</a></span>freeGEOSContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::freeGEOSContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td>
          <td class="paramname"><em>hGEOSCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a GEOS context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGEOSCtxt</td><td>GEOS context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c2fa3e96b586f11bf6aedeccf73d600" name="a5c2fa3e96b586f11bf6aedeccf73d600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2fa3e96b586f11bf6aedeccf73d600">&#9670;&#160;</a></span>FromHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::FromHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRGeometryH to a OGRGeometry*. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a6159cf2c28cd236ad2aa593c005c473a" name="a6159cf2c28cd236ad2aa593c005c473a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6159cf2c28cd236ad2aa593c005c473a">&#9670;&#160;</a></span>get_Area()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRCurvePolygon::get_Area </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the area of the surface object. </p>
<p>The returned area is a 2D Cartesian (planar) area in square units of the spatial reference system in use, so potentially "square degrees" for a geometry expressed in a geographic SRS.</p>
<p>For polygons the area is computed as the area of the outer ring less the area of all internal rings.</p>
<p>This method relates to the SFCOM ISurface::get_Area() method.</p>
<dl class="section return"><dt>Returns</dt><dd>the area of the geometry in square units of the spatial reference system in use.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRCurvePolygon.html#a7d872967b12ec5cf55846555fe32c983" title="Get the area of the surface object, considered as a surface on the underlying ellipsoid of the SRS at...">get_GeodesicArea()</a> for an alternative method returning areas computed on the ellipsoid, an in square meters. </dd></dl>

<p>Implements <a class="el" href="classOGRSurface.html#a3b2c3125ec8c0b3a986e43cd1056f9e4">OGRSurface</a>.</p>

</div>
</div>
<a id="a7d872967b12ec5cf55846555fe32c983" name="a7d872967b12ec5cf55846555fe32c983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d872967b12ec5cf55846555fe32c983">&#9670;&#160;</a></span>get_GeodesicArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRCurvePolygon::get_GeodesicArea </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSRSOverride</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the area of the surface object, considered as a surface on the underlying ellipsoid of the SRS attached to the geometry. </p>
<p>The returned area will always be in square meters, and assumes that polygon edges describe geodesic lines on the ellipsoid.</p>
<p>If the geometry' SRS is not a geographic one, geometries are reprojected to the underlying geographic SRS of the geometry' SRS. <a class="el" href="classOGRSpatialReference.html#a50a4542a228db455df2126e98a971d5d" title="Return the data axis to SRS axis mapping.">OGRSpatialReference::GetDataAxisToSRSAxisMapping()</a> is honored.</p>
<p>For polygons the area is computed as the area of the outer ring less the area of all internal rings.</p>
<p>Note that geometries with circular arcs will be linearized in their original coordinate space first, so the resulting geodesic area will be an approximation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSRSOverride</td><td>If not null, overrides <a class="el" href="classOGRGeometry.html#a66a53c103e37c6d1ead00d2d74586ddd" title="Returns spatial reference system for object.">OGRGeometry::getSpatialReference()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of the geometry in square meters, or a negative value in case of error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRCurvePolygon.html#a6159cf2c28cd236ad2aa593c005c473a" title="Get the area of the surface object.">get_Area()</a> for an alternative method returning areas computed in 2D Cartesian space.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

<p>Implements <a class="el" href="classOGRSurface.html#a7ef99197393373bd09b745ae3818fb18">OGRSurface</a>.</p>

</div>
</div>
<a id="a4a6fdd4df7c043558b5428d8f1c35b16" name="a4a6fdd4df7c043558b5428d8f1c35b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6fdd4df7c043558b5428d8f1c35b16">&#9670;&#160;</a></span>getCoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::getCoordinateDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this object. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f" title="Get the dimension of the coordinates in this geometry.">OGR_G_GetCoordinateDimension()</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>use <a class="el" href="classOGRGeometry.html#a35c4f4d75ec84fa225a9a4dee0a609c1" title="Get the dimension of the coordinates in this object.">CoordinateDimension()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 or 3. </dd></dl>

</div>
</div>
<a id="a1068398fd3af02de78bd2b9dbbb837f1" name="a1068398fd3af02de78bd2b9dbbb837f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1068398fd3af02de78bd2b9dbbb837f1">&#9670;&#160;</a></span>getCurveGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::getCurveGeometry </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return curve version of this geometry. </p>
<p>Returns a geometry that has possibly CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by de-approximating curve geometries.</p>
<p>If the geometry has no curve portion, the returned geometry will be a clone of it.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse method is <a class="el" href="classOGRGeometry.html#ada1408cd0015a83b697eb27aebaf5480" title="Return, possibly approximate, non-curve version of this geometry.">OGRGeometry::getLinearGeometry()</a>.</p>
<p>This function is the same as C function OGR_G_GetCurveGeometry().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. Unused for now. Must be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLineString.html#ab9eab58c0487fcc49c1595e99c881d26">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#af35b73e64c9b296afa0685575d6e524f">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a25a7ee787f1e660014a5ffa69a94f28e">OGRGeometryCollection</a>.</p>

</div>
</div>
<a id="a6cfab51e053c687ad39244c08ea298a7" name="a6cfab51e053c687ad39244c08ea298a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfab51e053c687ad39244c08ea298a7">&#9670;&#160;</a></span>getDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRCurvePolygon::getDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimension of this object. </p>
<p>This method corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the object, but does not indicate the dimension of the underlying space (as indicated by <a class="el" href="classOGRGeometry.html#a4a6fdd4df7c043558b5428d8f1c35b16" title="Get the dimension of the coordinates in this object.">OGRGeometry::getCoordinateDimension()</a>).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104" title="Get the dimension of this geometry.">OGR_G_GetDimension()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 for points, 1 for lines and 2 for surfaces. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">OGRGeometry</a>.</p>

</div>
</div>
<a id="a5c37b416860a3fd2b2aaf471ffd9ad69" name="a5c37b416860a3fd2b2aaf471ffd9ad69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c37b416860a3fd2b2aaf471ffd9ad69">&#9670;&#160;</a></span>getEnvelope() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psEnvelope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.">OGR_G_GetEnvelope()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">OGRGeometry</a>.</p>

</div>
</div>
<a id="a46fa4514aead52995de7aee70a6b8bb3" name="a46fa4514aead52995de7aee70a6b8bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fa4514aead52995de7aee70a6b8bb3">&#9670;&#160;</a></span>getEnvelope() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&#160;</td>
          <td class="paramname"><em>psEnvelope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce" title="Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.">OGR_G_GetEnvelope3D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a3926892dbde299ffd652ee109b5967c5">OGRGeometry</a>.</p>

</div>
</div>
<a id="a2880929fb3d5d80e8f023364da38f5f1" name="a2880929fb3d5d80e8f023364da38f5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2880929fb3d5d80e8f023364da38f5f1">&#9670;&#160;</a></span>getExteriorRingCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurve.html">OGRCurve</a> * OGRCurvePolygon::getExteriorRingCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch reference to external polygon ring. </p>
<p>Note that the returned ring pointer is to an internal data object of the <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons.">OGRCurvePolygon</a>. It should not be modified or deleted by the application, and the pointer is only valid till the polygon is next modified. Use the <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161" title="Make a copy of this object.">OGRGeometry::clone()</a> method to make a separate copy within the application.</p>
<p>Relates to the Simple Features for COM (SFCOM) IPolygon::get_ExteriorRing() method. TODO(rouault): What does that mean?</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to external ring. May be NULL if the <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons.">OGRCurvePolygon</a> is empty. </dd></dl>

</div>
</div>
<a id="ae081de82d00671e1cf400b19fe402298" name="ae081de82d00671e1cf400b19fe402298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae081de82d00671e1cf400b19fe402298">&#9670;&#160;</a></span>getExteriorRingCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCurve.html">OGRCurve</a> * OGRCurvePolygon::getExteriorRingCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch reference to external polygon ring. </p>
<p>Note that the returned ring pointer is to an internal data object of the <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons.">OGRCurvePolygon</a>. It should not be modified or deleted by the application, and the pointer is only valid till the polygon is next modified. Use the <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161" title="Make a copy of this object.">OGRGeometry::clone()</a> method to make a separate copy within the application.</p>
<p>Relates to the SFCOM IPolygon::get_ExteriorRing() method.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to external ring. May be NULL if the <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons.">OGRCurvePolygon</a> is empty. </dd></dl>

</div>
</div>
<a id="a657a572a4c14c429f6729b22f813a0b8" name="a657a572a4c14c429f6729b22f813a0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657a572a4c14c429f6729b22f813a0b8">&#9670;&#160;</a></span>getGeometryName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRCurvePolygon::getGeometryName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a58f6b34ad73d40c8a32cd4668b1b8d0f" title="Fetch WKT name for geometry type.">OGR_G_GetGeometryName()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>name used for this geometry type in well known text format. The returned pointer is to a static internal string and should not be modified or freed. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a70ab4a9518743c87ab7d36b731fce530">OGRPolygon</a>, and <a class="el" href="classOGRTriangle.html#af85e6b2097861cc92f74678acfb341f0">OGRTriangle</a>.</p>

</div>
</div>
<a id="a9a1a2d708cdf852785a66417f9889bfc" name="a9a1a2d708cdf852785a66417f9889bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1a2d708cdf852785a66417f9889bfc">&#9670;&#160;</a></span>getGeometryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRCurvePolygon::getGeometryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten()</a> macro to the return result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76" title="Fetch geometry type.">OGR_G_GetGeometryType()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the geometry type code. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a5f1316ac915dad438b599c825b8c0068">OGRPolygon</a>, and <a class="el" href="classOGRTriangle.html#a48b5fd19cbd9e93e4961a46660bb8181">OGRTriangle</a>.</p>

</div>
</div>
<a id="a30d172ad810a3db1362114f424836b05" name="a30d172ad810a3db1362114f424836b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d172ad810a3db1362114f424836b05">&#9670;&#160;</a></span>getInteriorRingCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurve.html">OGRCurve</a> * OGRCurvePolygon::getInteriorRingCurve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iRing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch reference to indicated internal ring. </p>
<p>Note that the returned ring pointer is to an internal data object of the <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons.">OGRCurvePolygon</a>. It should not be modified or deleted by the application, and the pointer is only valid till the polygon is next modified. Use the <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161" title="Make a copy of this object.">OGRGeometry::clone()</a> method to make a separate copy within the application.</p>
<p>Relates to the SFCOM IPolygon::get_InternalRing() method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iRing</td><td>internal ring index from 0 to <a class="el" href="classOGRCurvePolygon.html#af3d6071dbbce259c8a19bbf75c7d44ef" title="Fetch the number of internal rings.">getNumInteriorRings()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to interior ring. May be NULL. </dd></dl>

</div>
</div>
<a id="ade4cdd2ab417af986d414cd8ea77483f" name="ade4cdd2ab417af986d414cd8ea77483f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4cdd2ab417af986d414cd8ea77483f">&#9670;&#160;</a></span>getInteriorRingCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCurve.html">OGRCurve</a> * OGRCurvePolygon::getInteriorRingCurve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iRing</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch reference to indicated internal ring. </p>
<p>Note that the returned ring pointer is to an internal data object of the <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons.">OGRCurvePolygon</a>. It should not be modified or deleted by the application, and the pointer is only valid till the polygon is next modified. Use the <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161" title="Make a copy of this object.">OGRGeometry::clone()</a> method to make a separate copy within the application.</p>
<p>Relates to the SFCOM IPolygon::get_InternalRing() method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iRing</td><td>internal ring index from 0 to <a class="el" href="classOGRCurvePolygon.html#af3d6071dbbce259c8a19bbf75c7d44ef" title="Fetch the number of internal rings.">getNumInteriorRings()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to interior ring. May be NULL. </dd></dl>

</div>
</div>
<a id="ac3989a0ff917a1e46d02170033996329" name="ac3989a0ff917a1e46d02170033996329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3989a0ff917a1e46d02170033996329">&#9670;&#160;</a></span>getIsoGeometryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRGeometry::getIsoGeometryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the geometry type that conforms with ISO SQL/MM Part3. </p>
<dl class="section return"><dt>Returns</dt><dd>the geometry type that conforms with ISO SQL/MM Part3 </dd></dl>

</div>
</div>
<a id="a10c3cdd9accf2547e975ddb78558e9b4" name="a10c3cdd9accf2547e975ddb78558e9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c3cdd9accf2547e975ddb78558e9b4">&#9670;&#160;</a></span>getLinearGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRCurvePolygon::getLinearGeometry </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return, possibly approximate, non-curve version of this geometry. </p>
<p>Returns a geometry that has no CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by approximating curve geometries.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse method is <a class="el" href="classOGRGeometry.html#a1068398fd3af02de78bd2b9dbbb837f1" title="Return curve version of this geometry.">OGRGeometry::getCurveGeometry()</a>.</p>
<p>This method is the same as the C function OGR_G_GetLinearGeometry().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. See <a class="el" href="classOGRGeometryFactory.html#a6f661d6691fcf745ca185ae4d586156c" title="Converts an arc circle into an approximate line string.">OGRGeometryFactory::curveToLineString()</a> for valid options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#ada1408cd0015a83b697eb27aebaf5480">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a19479ddee1f05fe4d6b4ae9f52cbfb71">OGRPolygon</a>.</p>

</div>
</div>
<a id="af3d6071dbbce259c8a19bbf75c7d44ef" name="af3d6071dbbce259c8a19bbf75c7d44ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d6071dbbce259c8a19bbf75c7d44ef">&#9670;&#160;</a></span>getNumInteriorRings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRCurvePolygon::getNumInteriorRings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the number of internal rings. </p>
<p>Relates to the SFCOM IPolygon::get_NumInteriorRings() method.</p>
<dl class="section return"><dt>Returns</dt><dd>count of internal rings, zero or more. </dd></dl>

</div>
</div>
<a id="a66a53c103e37c6d1ead00d2d74586ddd" name="a66a53c103e37c6d1ead00d2d74586ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a53c103e37c6d1ead00d2d74586ddd">&#9670;&#160;</a></span>getSpatialReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRGeometry::getSpatialReference </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns spatial reference system for object. </p>
<p>This method relates to the SFCOM IGeometry::get_SpatialReference() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf" title="Returns spatial reference system for geometry.">OGR_G_GetSpatialReference()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the spatial reference object. The object may be shared with many geometry objects, and should not be modified. </dd></dl>

</div>
</div>
<a id="af3e3b31c4b80544151852e825f3f555c" name="af3e3b31c4b80544151852e825f3f555c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e3b31c4b80544151852e825f3f555c">&#9670;&#160;</a></span>hasCurveGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRCurvePolygon::hasCurveGeometry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bLookForNonLinear</em> = <code>FALSE</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this geometry is or has curve geometry. </p>
<p>Returns if a geometry is, contains or may contain a CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE.</p>
<p>If bLookForNonLinear is set to TRUE, it will be actually looked if the geometry or its subgeometries are or contain a non-linear geometry in them. In which case, if the method returns TRUE, it means that <a class="el" href="classOGRCurvePolygon.html#a10c3cdd9accf2547e975ddb78558e9b4" title="Return, possibly approximate, non-curve version of this geometry.">getLinearGeometry()</a> would return an approximate version of the geometry. Otherwise, <a class="el" href="classOGRCurvePolygon.html#a10c3cdd9accf2547e975ddb78558e9b4" title="Return, possibly approximate, non-curve version of this geometry.">getLinearGeometry()</a> would do a conversion, but with just converting container type, like COMPOUNDCURVE -&gt; LINESTRING, MULTICURVE -&gt; MULTILINESTRING or MULTISURFACE -&gt; MULTIPOLYGON, resulting in a "loss-less" conversion.</p>
<p>This method is the same as the C function OGR_G_HasCurveGeometry().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bLookForNonLinear</td><td>set it to TRUE to check if the geometry is or contains a CIRCULARSTRING.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this geometry is or has curve geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a15afb03f64091205af0530d8d1262798">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a473e648dc1d29d9776811b27ad53b7a2">OGRPolygon</a>.</p>

</div>
</div>
<a id="ae2231c970e4075202cafb4f6a69e07e6" name="ae2231c970e4075202cafb4f6a69e07e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2231c970e4075202cafb4f6a69e07e6">&#9670;&#160;</a></span>importFromWkb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em> = <code>static_cast&lt;size_t&gt;(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type. This method is used by the <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary.">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae523fe14c8c87dffcee706438ec2e81f" title="Assign geometry from well known binary data.">OGR_G_ImportFromWkb()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>the binary input data. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of pabyData in bytes, or -1 if not known. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>if wkbVariantPostGIS1, special interpretation is done for curve geometries code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a7b22999d7055ac9f2d9d92728213e33f" name="a7b22999d7055ac9f2d9d92728213e33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b22999d7055ac9f2d9d92728213e33f">&#9670;&#160;</a></span>importFromWkb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRCurvePolygon::importFromWkb </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>nBytesConsumedOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type. This method is used by the <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary.">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae523fe14c8c87dffcee706438ec2e81f" title="Assign geometry from well known binary data.">OGR_G_ImportFromWkb()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>the binary input data. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of pabyData in bytes, or -1 if not known. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>if wkbVariantPostGIS1, special interpretation is done for curve geometries code </td></tr>
    <tr><td class="paramname">nBytesConsumedOut</td><td>output parameter. Number of bytes consumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a0fe73abb288066cc511546350829c136">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a8527c3c09a7e677131d29acc9ff8636b">OGRPolygon</a>, and <a class="el" href="classOGRTriangle.html#a669e6383ac8f68d632ddb6366eea998f">OGRTriangle</a>.</p>

</div>
</div>
<a id="ac7129d4459a847a8ea6ec8b5efc24c71" name="ac7129d4459a847a8ea6ec8b5efc24c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7129d4459a847a8ea6ec8b5efc24c71">&#9670;&#160;</a></span>importFromWkt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>in GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a154a45e780861e77d1a17520c08a527d" name="a154a45e780861e77d1a17520c08a527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154a45e780861e77d1a17520c08a527d">&#9670;&#160;</a></span>importFromWkt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRCurvePolygon::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deprecated </p>

<p>Implements <a class="el" href="classOGRGeometry.html#af1bb0f7cae630c31511766718bcc5b66">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a7e59ca06b3f87c688d4ad4ff3b31fd24">OGRPolygon</a>, and <a class="el" href="classOGRPolygon.html#af1bb0f7cae630c31511766718bcc5b66">OGRPolygon</a>.</p>

</div>
</div>
<a id="af1bb0f7cae630c31511766718bcc5b66" name="af1bb0f7cae630c31511766718bcc5b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bb0f7cae630c31511766718bcc5b66">&#9670;&#160;</a></span>importFromWkt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type. This method is used by the <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary.">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8" title="Assign geometry from well known text data.">OGR_G_ImportFromWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszInput</td><td>pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#af1bb0f7cae630c31511766718bcc5b66">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a7e59ca06b3f87c688d4ad4ff3b31fd24">OGRPolygon</a>, and <a class="el" href="classOGRPolygon.html#af1bb0f7cae630c31511766718bcc5b66">OGRPolygon</a>.</p>

</div>
</div>
<a id="ae2fc420ca5d995bfef55adb1819a31f2" name="ae2fc420ca5d995bfef55adb1819a31f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fc420ca5d995bfef55adb1819a31f2">&#9670;&#160;</a></span>Intersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute intersection. </p>
<p>Generates a new geometry which is the region of intersection of the two geometries operated on. The <a class="el" href="classOGRCurvePolygon.html#a78ec798e8a8918c0bf71edceff9765da" title="Do these features intersect?">Intersects()</a> method can be used to test if two geometries intersect.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5a271b5c7b72994120e7a6bbc7e7e5cb" title="Compute intersection.">OGR_G_Intersection()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry intersected with "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the intersection or NULL if there is no intersection or an error occurs. </dd></dl>

</div>
</div>
<a id="a78ec798e8a8918c0bf71edceff9765da" name="a78ec798e8a8918c0bf71edceff9765da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ec798e8a8918c0bf71edceff9765da">&#9670;&#160;</a></span>Intersects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRCurvePolygon::Intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do these features intersect? </p>
<p>Determines whether two geometries intersect. If GEOS is enabled, then this is done in rigorous fashion otherwise TRUE is returned if the envelopes (bounding boxes) of the two geometries overlap.</p>
<p>The poOtherGeom argument may be safely NULL, but in this case the method will always return TRUE. That is, a NULL geometry is treated as being everywhere.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87" title="Do these features intersect?">OGR_G_Intersects()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry to test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometries intersect, otherwise FALSE. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a12b9bf1e607908703d68bcdd5a82440c">OGRGeometry</a>.</p>

</div>
</div>
<a id="ae9867dbbd6b840ca9c9240c7cb9c3b8c" name="ae9867dbbd6b840ca9c9240c7cb9c3b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9867dbbd6b840ca9c9240c7cb9c3b8c">&#9670;&#160;</a></span>Is3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Is3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the geometry has a Z component. </p>

</div>
</div>
<a id="aa659e9d7d87da1ae552a69a7fc5508f9" name="aa659e9d7d87da1ae552a69a7fc5508f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa659e9d7d87da1ae552a69a7fc5508f9">&#9670;&#160;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRCurvePolygon::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE (non-zero) if the object has no points. </p>
<p>Normally this returns FALSE except between when an object is instantiated and points have been assigned.</p>
<p>This method relates to the SFCOM IGeometry::IsEmpty() method.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if object is empty, otherwise FALSE. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry</a>.</p>

</div>
</div>
<a id="a959d5776c17018e362b580b1e61e1caa" name="a959d5776c17018e362b580b1e61e1caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959d5776c17018e362b580b1e61e1caa">&#9670;&#160;</a></span>IsMeasured()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsMeasured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the geometry has a M component. </p>

</div>
</div>
<a id="afe3c69f5b89fa5eb0bfb03e4880822bf" name="afe3c69f5b89fa5eb0bfb03e4880822bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3c69f5b89fa5eb0bfb03e4880822bf">&#9670;&#160;</a></span>IsRing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsRing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the geometry is a ring. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826" title="Test if the geometry is a ring.">OGR_G_IsRing()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="afe41ef903c94999a81a98c356b32e624" name="afe41ef903c94999a81a98c356b32e624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe41ef903c94999a81a98c356b32e624">&#9670;&#160;</a></span>IsSimple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsSimple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the geometry is simple. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73" title="Returns TRUE if the geometry is simple.">OGR_G_IsSimple()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a681c8b8f8136764fd689ffbce24085d3" name="a681c8b8f8136764fd689ffbce24085d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681c8b8f8136764fd689ffbce24085d3">&#9670;&#160;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the geometry is valid. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b" title="Test if the geometry is valid.">OGR_G_IsValid()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRCircularString.html#a540c540f8454d5c6726969caf3e8f904">OGRCircularString</a>.</p>

</div>
</div>
<a id="a700a2d4b1c719e1f65fa3009bfc04f78" name="a700a2d4b1c719e1f65fa3009bfc04f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700a2d4b1c719e1f65fa3009bfc04f78">&#9670;&#160;</a></span>MakeValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::MakeValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to make an invalid geometry valid without losing vertices. </p>
<p>Already-valid geometries are cloned without further intervention.</p>
<p>Running <a class="el" href="classOGRGeometryFactory.html#a9dda76280700944f813f6b4c8e7be7a0" title="Remove sub-geometries from a geometry collection that do not have the maximum topological dimensional...">OGRGeometryFactory::removeLowerDimensionSubGeoms()</a> as a post-processing step is often desired.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4e24b3b68c6fc20ed8a315451bd61514" title="Attempts to make an invalid geometry valid without losing vertices.">OGR_G_MakeValid()</a>.</p>
<p>This function is built on the GEOS &gt;= 3.8 library, check it for the definition of the geometry operation. If OGR is built without the GEOS &gt;= 3.8 library, this function will return a clone of the input geometry if it is valid, or NULL if it is invalid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options, or NULL. The following options are available: <ul>
<li>
METHOD=LINEWORK/STRUCTURE. LINEWORK is the default method, which combines all rings into a set of noded lines and then extracts valid polygons from that linework. The STRUCTURE method (requires GEOS &gt;= 3.10 and GDAL &gt;= 3.4) first makes all rings valid, then merges shells and subtracts holes from shells to generate valid result. Assumes that holes and shells are correctly categorized. </li>
<li>
KEEP_COLLAPSED=YES/NO. Only for METHOD=STRUCTURE. NO (default): collapses are converted to empty geometries YES: collapses are converted to a valid geometry of lower dimension. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="aa518a2cafc2a2394bc3a5196fa7dd017" name="aa518a2cafc2a2394bc3a5196fa7dd017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa518a2cafc2a2394bc3a5196fa7dd017">&#9670;&#160;</a></span>Normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to bring geometry into normalized/canonical form. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#affbc131cab986a87e0db5b8b4dda91e3" title="Attempts to bring geometry into normalized/canonical form.">OGR_G_Normalize()</a>.</p>
<p>This function is built on the GEOS library; check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="ad5fbcada309b9562536aad08fe0da73a" name="ad5fbcada309b9562536aad08fe0da73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fbcada309b9562536aad08fe0da73a">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> &amp; OGRCurvePolygon::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Note: before GDAL 2.1, only the default implementation of the operator existed, which could be unsafe to use.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a432b89868f8094004467e8e9b51ad5ca" name="a432b89868f8094004467e8e9b51ad5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432b89868f8094004467e8e9b51ad5ca">&#9670;&#160;</a></span>Overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for overlap. </p>
<p>Tests if this geometry and the other passed into the method overlap, that is their intersection has a non-zero area.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb" title="Test for overlap.">OGR_G_Overlaps()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are overlapping, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="abb360e6efd4a9450f891972e495c5130" name="abb360e6efd4a9450f891972e495c5130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb360e6efd4a9450f891972e495c5130">&#9670;&#160;</a></span>PointOnSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSurface::PointOnSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td>
          <td class="paramname"><em>poPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method relates to the SFCOM ISurface::get_PointOnSurface() method. </p>
<p>NOTE: Only implemented when GEOS included in build.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poPoint</td><td>point to be set with an internal point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if it succeeds or OGRERR_FAILURE otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#adb7c16fe6a07deb1777799860c889dd8">OGRPolyhedralSurface</a>.</p>

</div>
</div>
<a id="a9f35edabf2e5d40a79f07f77d56a2459" name="a9f35edabf2e5d40a79f07f77d56a2459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f35edabf2e5d40a79f07f77d56a2459">&#9670;&#160;</a></span>Polygonize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Polygonize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polygonizes a set of sparse edges. </p>
<p>A new geometry object is created and returned containing a collection of reassembled Polygons: NULL will be returned if the input collection doesn't corresponds to a MultiLinestring, or when reassembling Edges into Polygons is impossible due to topological inconsistencies.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a673c6c4745d5092fb250ae5342bc1b3b" title="Polygonizes a set of sparse edges.">OGR_G_Polygonize()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="af7fb46dfd0cd7eebe68555ac1b6da76f" name="af7fb46dfd0cd7eebe68555ac1b6da76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fb46dfd0cd7eebe68555ac1b6da76f">&#9670;&#160;</a></span>removeRing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRCurvePolygon::removeRing </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDelete</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a geometry from the container. </p>
<p>Removing a geometry will cause the geometry count to drop by one, and all "higher" geometries will shuffle down one in index.</p>
<p>There is no SFCOM analog to this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iIndex</td><td>the index of the geometry to delete. A value of -1 is a special flag meaning that all geometries should be removed.</td></tr>
    <tr><td class="paramname">bDelete</td><td>if true the geometry will be deallocated, otherwise it will not. The default is true as the container is considered to own the geometries in it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGRERR_FAILURE if the index is out of range. </dd></dl>

</div>
</div>
<a id="a0f008712013032d876cc60860d317a33" name="a0f008712013032d876cc60860d317a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f008712013032d876cc60860d317a33">&#9670;&#160;</a></span>roundCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::roundCoordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOGRGeomCoordinatePrecision.html">OGRGeomCoordinatePrecision</a> &amp;&#160;</td>
          <td class="paramname"><em>sPrecision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round coordinates of the geometry to the specified precision. </p>
<p>Note that this is not the same as <a class="el" href="classOGRGeometry.html#a36db4751a05c870f180fde6f1a6d939c" title="Set the geometry&#39;s precision, rounding all its coordinates to the precision grid, and making sure the...">OGRGeometry::SetPrecision()</a>. The later will return valid geometries, whereas <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a> does not make such guarantee and may return geometries with invalidities, if they are not compatible of the specified precision. <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a> supports curve geometries, whereas <a class="el" href="classOGRGeometry.html#a36db4751a05c870f180fde6f1a6d939c" title="Set the geometry&#39;s precision, rounding all its coordinates to the precision grid, and making sure the...">SetPrecision()</a> does not currently.</p>
<p>One use case for <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a> is to undo the effect of quantizeCoordinates().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sPrecision</td><td>Contains the precision requirements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="ad3667da6ea2f9416c8f1b747391d0171" name="ad3667da6ea2f9416c8f1b747391d0171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3667da6ea2f9416c8f1b747391d0171">&#9670;&#160;</a></span>roundCoordinatesIEEE754()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::roundCoordinatesIEEE754 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOGRGeomCoordinateBinaryPrecision.html">OGRGeomCoordinateBinaryPrecision</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round coordinates of a geometry, exploiting characteristics of the IEEE-754 double-precision binary representation. </p>
<p>Determines the number of bits (N) required to represent a coordinate value with a specified number of digits after the decimal point, and then sets all but the N most significant bits to zero. The resulting coordinate value will still round to the original value (e.g. after <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a>), but will have improved compressiblity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Contains the precision requirements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a922d66445e62efa2199595821dfc3d44" name="a922d66445e62efa2199595821dfc3d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922d66445e62efa2199595821dfc3d44">&#9670;&#160;</a></span>segmentize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::segmentize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>This method modifies the geometry to add intermediate vertices if necessary so that the maximum length between 2 consecutive vertices is lower than dfMaxLength.</p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423" title="Modify the geometry such it has no segment longer then the given distance.">OGR_G_Segmentize()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMaxLength</td><td>the maximum distance between 2 points after segmentization </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5">OGRGeometry</a>.</p>

</div>
</div>
<a id="afb4e059b5d4965304f795044910c8769" name="afb4e059b5d4965304f795044910c8769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4e059b5d4965304f795044910c8769">&#9670;&#160;</a></span>set3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::set3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td>
          <td class="paramname"><em>bIs3D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or remove the Z coordinate dimension. </p>
<p>This method adds or removes the explicit Z coordinate dimension. Removing the Z coordinate dimension of a geometry will remove any existing Z values. Adding the Z dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIs3D</td><td>Should the geometry have a Z dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#ad4dc0ab8f5269e24faad26387e344913">OGRGeometry</a>.</p>

</div>
</div>
<a id="adf41d14265fdabd4b4ceb3d8c22341fa" name="adf41d14265fdabd4b4ceb3d8c22341fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf41d14265fdabd4b4ceb3d8c22341fa">&#9670;&#160;</a></span>setCoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::setCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewDimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection, a compound curve, a polygon, etc. will affect the children geometries. This will also remove the M dimension if present before this call.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>use <a class="el" href="classOGRCurvePolygon.html#afb4e059b5d4965304f795044910c8769" title="Add or remove the Z coordinate dimension.">set3D()</a> or <a class="el" href="classOGRCurvePolygon.html#adf784aaad99c0878b5bc8f8e5a65c3b0" title="Add or remove the M coordinate dimension.">setMeasured()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nNewDimension</td><td>New coordinate dimension value, either 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a79f84a2b948d511f28c47c47577dea49">OGRGeometry</a>.</p>

</div>
</div>
<a id="adf784aaad99c0878b5bc8f8e5a65c3b0" name="adf784aaad99c0878b5bc8f8e5a65c3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf784aaad99c0878b5bc8f8e5a65c3b0">&#9670;&#160;</a></span>setMeasured()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::setMeasured </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td>
          <td class="paramname"><em>bIsMeasured</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or remove the M coordinate dimension. </p>
<p>This method adds or removes the explicit M coordinate dimension. Removing the M coordinate dimension of a geometry will remove any existing M values. Adding the M dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIsMeasured</td><td>Should the geometry have a M dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a5f1d7eea437838415a14f9dc54523857">OGRGeometry</a>.</p>

</div>
</div>
<a id="a36db4751a05c870f180fde6f1a6d939c" name="a36db4751a05c870f180fde6f1a6d939c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36db4751a05c870f180fde6f1a6d939c">&#9670;&#160;</a></span>SetPrecision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SetPrecision </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfGridSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the geometry's precision, rounding all its coordinates to the precision grid, and making sure the geometry is still valid. </p>
<p>This is a stronger version of <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a>.</p>
<p>Note that at time of writing GEOS does no supported curve geometries. So currently if this function is called on such a geometry, OGR will first call <a class="el" href="classOGRCurvePolygon.html#a10c3cdd9accf2547e975ddb78558e9b4" title="Return, possibly approximate, non-curve version of this geometry.">getLinearGeometry()</a> on the input and <a class="el" href="classOGRGeometry.html#a1068398fd3af02de78bd2b9dbbb837f1" title="Return curve version of this geometry.">getCurveGeometry()</a> on the output, but that it is unlikely to yield to the expected result.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a90133f7d05c95ae681274cce4481c74f" title="Set the geometry&#39;s precision, rounding all its coordinates to the precision grid, and making sure the...">OGR_G_SetPrecision()</a>.</p>
<p>This function is built on the GEOSGeom_setPrecision_r() function of the GEOS library. Check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfGridSize</td><td>size of the precision grid, or 0 for FLOATING precision. </td></tr>
    <tr><td class="paramname">nFlags</td><td>The bitwise OR of zero, one or several of OGR_GEOS_PREC_NO_TOPO and OGR_GEOS_PREC_KEEP_COLLAPSED</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a40909bc6bc40b9aecfdae5cb70160eaa" name="a40909bc6bc40b9aecfdae5cb70160eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40909bc6bc40b9aecfdae5cb70160eaa">&#9670;&#160;</a></span>Simplify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Simplify </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the geometry. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a0453f97e9d4fc44e13787ad1a8439c0c" title="Compute a simplified geometry.">OGR_G_Simplify()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a3951fc5d0043af5794dd08d738e0a1dc" name="a3951fc5d0043af5794dd08d738e0a1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3951fc5d0043af5794dd08d738e0a1dc">&#9670;&#160;</a></span>SimplifyPreserveTopology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SimplifyPreserveTopology </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the geometry while preserving topology. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a8e19e9cfa01744db6a2e8eee710611b6" title="Simplify the geometry while preserving topology.">OGR_G_SimplifyPreserveTopology()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a09fdacfe9e3ffe0789cc21f1405f489c" name="a09fdacfe9e3ffe0789cc21f1405f489c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fdacfe9e3ffe0789cc21f1405f489c">&#9670;&#160;</a></span>stealExteriorRingCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurve.html">OGRCurve</a> * OGRCurvePolygon::stealExteriorRingCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Steal" reference to external ring. </p>
<p>After the call to that function, only call to stealInteriorRing() or destruction of the <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons.">OGRCurvePolygon</a> is valid. Other operations may crash.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to external ring. May be NULL if the <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons.">OGRCurvePolygon</a> is empty. </dd></dl>

</div>
</div>
<a id="a820f36b21407a7400b0af0a5d95b0e5e" name="a820f36b21407a7400b0af0a5d95b0e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820f36b21407a7400b0af0a5d95b0e5e">&#9670;&#160;</a></span>swapXY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurvePolygon::swapXY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap x and y coordinates. </p>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a3ffd51d4998a8e2ae422c69b6adf480a">OGRGeometry</a>.</p>

</div>
</div>
<a id="ab0a5c298bb0dcc4d44500278238e0ac2" name="ab0a5c298bb0dcc4d44500278238e0ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a5c298bb0dcc4d44500278238e0ac2">&#9670;&#160;</a></span>SymDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SymDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute symmetric difference. </p>
<p>Generates a new geometry which is the symmetric difference of this geometry and the second geometry passed into the method.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a2b047fca89d06a08a5c34f210c4c97d5" title="Compute symmetric difference.">OGR_G_SymDifference()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="ad5f596fd8003bb435c17914edf990578" name="ad5f596fd8003bb435c17914edf990578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f596fd8003bb435c17914edf990578">&#9670;&#160;</a></span>toCircularString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCircularString.html">OGRCircularString</a> * OGRGeometry::toCircularString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCircularString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCircularString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a83f93722c76a41392f5d7c9aa04591a6" name="a83f93722c76a41392f5d7c9aa04591a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f93722c76a41392f5d7c9aa04591a6">&#9670;&#160;</a></span>toCircularString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCircularString.html">OGRCircularString</a> * OGRGeometry::toCircularString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCircularString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCircularString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="abddc978b9086ae78999d5f5d4d1f7c41" name="abddc978b9086ae78999d5f5d4d1f7c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abddc978b9086ae78999d5f5d4d1f7c41">&#9670;&#160;</a></span>toCompoundCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> * OGRGeometry::toCompoundCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCompoundCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCompoundCurve. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="aa796ff5f52ba253d503197cfb805c7c6" name="aa796ff5f52ba253d503197cfb805c7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa796ff5f52ba253d503197cfb805c7c6">&#9670;&#160;</a></span>toCompoundCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> * OGRGeometry::toCompoundCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCompoundCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCompoundCurve. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="afd76ec529a6930904a43b2adfc987878" name="afd76ec529a6930904a43b2adfc987878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd76ec529a6930904a43b2adfc987878">&#9670;&#160;</a></span>toCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurve.html">OGRCurve</a> * OGRGeometry::toCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurve*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(),
wkbCurve). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ad8b612c84549091a0c46cc238e6539cc" name="ad8b612c84549091a0c46cc238e6539cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b612c84549091a0c46cc238e6539cc">&#9670;&#160;</a></span>toCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCurve.html">OGRCurve</a> * OGRGeometry::toCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurve*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(),
wkbCurve). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="adab177badcb46c78c0fa8cfe930d166f" name="adab177badcb46c78c0fa8cfe930d166f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab177badcb46c78c0fa8cfe930d166f">&#9670;&#160;</a></span>toCurvePolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> * OGRGeometry::toCurvePolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurvePolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCurvePolygon or wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a072b2d27e0a908b96b255e8ee6d06ce3" name="a072b2d27e0a908b96b255e8ee6d06ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072b2d27e0a908b96b255e8ee6d06ce3">&#9670;&#160;</a></span>toCurvePolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> * OGRGeometry::toCurvePolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurvePolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCurvePolygon or wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ab6520c61231ac4bf430d0755a7d7cf68" name="ab6520c61231ac4bf430d0755a7d7cf68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6520c61231ac4bf430d0755a7d7cf68">&#9670;&#160;</a></span>toGeometryCollection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> * OGRGeometry::toGeometryCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRGeometryCollection*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(),
wkbGeometryCollection). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a62e2f0fdb92a7742d5e0df5797629bf4" name="a62e2f0fdb92a7742d5e0df5797629bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e2f0fdb92a7742d5e0df5797629bf4">&#9670;&#160;</a></span>toGeometryCollection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> * OGRGeometry::toGeometryCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRGeometryCollection*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(),
wkbGeometryCollection). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ae518798c9e80bad59b0907f43d375876" name="ae518798c9e80bad59b0907f43d375876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae518798c9e80bad59b0907f43d375876">&#9670;&#160;</a></span>ToHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGRGeometry::ToHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRGeometry* to a OGRGeometryH. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a91f9393e2f63e2e40a85ba9a772841da" name="a91f9393e2f63e2e40a85ba9a772841da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f9393e2f63e2e40a85ba9a772841da">&#9670;&#160;</a></span>toLinearRing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> * OGRGeometry::toLinearRing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLinearRing*. </p>
<p>Implies prior checking that EQUAL(<a class="el" href="classOGRCurvePolygon.html#a657a572a4c14c429f6729b22f813a0b8" title="Fetch WKT name for geometry type.">getGeometryName()</a>, "LINEARRING"). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a369f74aa2bae7ae30610c6ba355e681f" name="a369f74aa2bae7ae30610c6ba355e681f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369f74aa2bae7ae30610c6ba355e681f">&#9670;&#160;</a></span>toLinearRing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> * OGRGeometry::toLinearRing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLinearRing*. </p>
<p>Implies prior checking that EQUAL(<a class="el" href="classOGRCurvePolygon.html#a657a572a4c14c429f6729b22f813a0b8" title="Fetch WKT name for geometry type.">getGeometryName()</a>, "LINEARRING"). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a33a5ac15aac9b026aa492e67eae4b860" name="a33a5ac15aac9b026aa492e67eae4b860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a5ac15aac9b026aa492e67eae4b860">&#9670;&#160;</a></span>toLineString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLineString.html">OGRLineString</a> * OGRGeometry::toLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="acb15cf7a6a28edc74a265494de9d3af1" name="acb15cf7a6a28edc74a265494de9d3af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb15cf7a6a28edc74a265494de9d3af1">&#9670;&#160;</a></span>toLineString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRLineString.html">OGRLineString</a> * OGRGeometry::toLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="aa684011d14e4ede49063df21618e9178" name="aa684011d14e4ede49063df21618e9178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa684011d14e4ede49063df21618e9178">&#9670;&#160;</a></span>toMultiCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a> * OGRGeometry::toMultiCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiCurve and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a0fcdeb95ced81296a1cc755725e79bc0" name="a0fcdeb95ced81296a1cc755725e79bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcdeb95ced81296a1cc755725e79bc0">&#9670;&#160;</a></span>toMultiCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a> * OGRGeometry::toMultiCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiCurve and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a4fd1a8c63662855f47c78b6b675853e9" name="a4fd1a8c63662855f47c78b6b675853e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd1a8c63662855f47c78b6b675853e9">&#9670;&#160;</a></span>toMultiLineString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a> * OGRGeometry::toMultiLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a6b4cabf8127b3571817fe67d54aa0f54" name="a6b4cabf8127b3571817fe67d54aa0f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4cabf8127b3571817fe67d54aa0f54">&#9670;&#160;</a></span>toMultiLineString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a> * OGRGeometry::toMultiLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ae9e413e3d5b1a387b7c2773742dfbb4a" name="ae9e413e3d5b1a387b7c2773742dfbb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e413e3d5b1a387b7c2773742dfbb4a">&#9670;&#160;</a></span>toMultiPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a> * OGRGeometry::toMultiPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a1502ed8bb9f88df9170f65e24fae3936" name="a1502ed8bb9f88df9170f65e24fae3936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1502ed8bb9f88df9170f65e24fae3936">&#9670;&#160;</a></span>toMultiPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a> * OGRGeometry::toMultiPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="abdb1f2884c158183f0a26e21d286a6fe" name="abdb1f2884c158183f0a26e21d286a6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb1f2884c158183f0a26e21d286a6fe">&#9670;&#160;</a></span>toMultiPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a> * OGRGeometry::toMultiPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiPolygon. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a182d745b59cd11a32f8648807542198c" name="a182d745b59cd11a32f8648807542198c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182d745b59cd11a32f8648807542198c">&#9670;&#160;</a></span>toMultiPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a> * OGRGeometry::toMultiPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiPolygon. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a57cd804e21956e330179475b067ded9b" name="a57cd804e21956e330179475b067ded9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cd804e21956e330179475b067ded9b">&#9670;&#160;</a></span>toMultiSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a> * OGRGeometry::toMultiSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiSurface and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a1ebef1fb440b811267692c07745b83c9" name="a1ebef1fb440b811267692c07745b83c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebef1fb440b811267692c07745b83c9">&#9670;&#160;</a></span>toMultiSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a> * OGRGeometry::toMultiSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiSurface and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a1ef198bb6f7179b2d36b1f6731017876" name="a1ef198bb6f7179b2d36b1f6731017876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef198bb6f7179b2d36b1f6731017876">&#9670;&#160;</a></span>toPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPoint.html">OGRPoint</a> * OGRGeometry::toPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a3c5cca70c980cca021c8302c504d5b64" name="a3c5cca70c980cca021c8302c504d5b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5cca70c980cca021c8302c504d5b64">&#9670;&#160;</a></span>toPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRPoint.html">OGRPoint</a> * OGRGeometry::toPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a87abd91a35de5e95c1e0c47941ec0f08" name="a87abd91a35de5e95c1e0c47941ec0f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87abd91a35de5e95c1e0c47941ec0f08">&#9670;&#160;</a></span>toPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPolygon.html">OGRPolygon</a> * OGRGeometry::toPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="abdc25a15b33f93563366dd32df58cf67" name="abdc25a15b33f93563366dd32df58cf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc25a15b33f93563366dd32df58cf67">&#9670;&#160;</a></span>toPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRPolygon.html">OGRPolygon</a> * OGRGeometry::toPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a1e69ef12c587116ba0ff10090b54c229" name="a1e69ef12c587116ba0ff10090b54c229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e69ef12c587116ba0ff10090b54c229">&#9670;&#160;</a></span>toPolyhedralSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a> * OGRGeometry::toPolyhedralSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolyhedralSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPolyhedralSurface or wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a124c69073f92a84cffc6d037030c186c" name="a124c69073f92a84cffc6d037030c186c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124c69073f92a84cffc6d037030c186c">&#9670;&#160;</a></span>toPolyhedralSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a> * OGRGeometry::toPolyhedralSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolyhedralSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPolyhedralSurface or wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="af7967ffd22bf483b8bc7f71b46a2c049" name="af7967ffd22bf483b8bc7f71b46a2c049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7967ffd22bf483b8bc7f71b46a2c049">&#9670;&#160;</a></span>toSimpleCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a> * OGRGeometry::toSimpleCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSimpleCurve*. </p>
<p>Implies prior checking that <a class="el" href="classOGRCurvePolygon.html#a9a1a2d708cdf852785a66417f9889bfc" title="Fetch geometry type.">getGeometryType()</a> is wkbLineString, wkbCircularString or a derived type. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="adc0eeec8555c96f73e140dc5216c06ad" name="adc0eeec8555c96f73e140dc5216c06ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0eeec8555c96f73e140dc5216c06ad">&#9670;&#160;</a></span>toSimpleCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a> * OGRGeometry::toSimpleCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSimpleCurve*. </p>
<p>Implies prior checking that <a class="el" href="classOGRCurvePolygon.html#a9a1a2d708cdf852785a66417f9889bfc" title="Fetch geometry type.">getGeometryType()</a> is wkbLineString, wkbCircularString or a derived type. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="af55e904eb68aadfbd80715fd0e780234" name="af55e904eb68aadfbd80715fd0e780234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55e904eb68aadfbd80715fd0e780234">&#9670;&#160;</a></span>toSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSurface.html">OGRSurface</a> * OGRGeometry::toSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSurface*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(),
wkbSurface). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a046283abf737cc91f2bdc4c130294180" name="a046283abf737cc91f2bdc4c130294180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046283abf737cc91f2bdc4c130294180">&#9670;&#160;</a></span>toSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRSurface.html">OGRSurface</a> * OGRGeometry::toSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSurface*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(),
wkbSurface). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a30484d069df37be8587aa63df24f67b5" name="a30484d069df37be8587aa63df24f67b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30484d069df37be8587aa63df24f67b5">&#9670;&#160;</a></span>toTriangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRTriangle.html">OGRTriangle</a> * OGRGeometry::toTriangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangle*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="aef0a1ac9886ba17b2c0ba135f00efa9e" name="aef0a1ac9886ba17b2c0ba135f00efa9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0a1ac9886ba17b2c0ba135f00efa9e">&#9670;&#160;</a></span>toTriangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRTriangle.html">OGRTriangle</a> * OGRGeometry::toTriangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangle*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="af8717aa2f4ddbca33c2274f7e4af4f68" name="af8717aa2f4ddbca33c2274f7e4af4f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8717aa2f4ddbca33c2274f7e4af4f68">&#9670;&#160;</a></span>toTriangulatedSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a> * OGRGeometry::toTriangulatedSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangulatedSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="aed98a3466303ca6522c397e5025c1375" name="aed98a3466303ca6522c397e5025c1375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed98a3466303ca6522c397e5025c1375">&#9670;&#160;</a></span>toTriangulatedSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a> * OGRGeometry::toTriangulatedSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangulatedSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="abd1be78538ab56a7c16cfa65797eeb0c" name="abd1be78538ab56a7c16cfa65797eeb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1be78538ab56a7c16cfa65797eeb0c">&#9670;&#160;</a></span>Touches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Touches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for touching. </p>
<p>Tests if this geometry and the other passed into the method are touching.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9" title="Test for touching.">OGR_G_Touches()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are touching, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a6c14e71640ee125335023f2f0124aecc" name="a6c14e71640ee125335023f2f0124aecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c14e71640ee125335023f2f0124aecc">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRCurvePolygon::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *&#160;</td>
          <td class="paramname"><em>poCT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this method does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> will be assigned to the geometry.</p>
<p>This method only does reprojection on a point-by-point basis. It does not include advanced logic to deal with discontinuities at poles or antimeridian. For that, use the <a class="el" href="classOGRGeometryFactory.html#a47b03de00271a9ca9902d2c8920414ad" title="Transform a geometry.">OGRGeometryFactory::transformWithOptions()</a> method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090" title="Apply arbitrary coordinate transformation to geometry.">OGR_G_Transform()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poCT</td><td>the transformation to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba">OGRGeometry</a>.</p>

</div>
</div>
<a id="abc0ec206bcafdd27eef5ef455d366af3" name="abc0ec206bcafdd27eef5ef455d366af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0ec206bcafdd27eef5ef455d366af3">&#9670;&#160;</a></span>transformTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::transformTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform geometry to new spatial reference system. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>This method will only work if the geometry already has an assigned spatial reference system, and if it is transformable to the target coordinate system.</p>
<p>Because this method requires internal creation and initialization of an <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> object it is significantly more expensive to use this method to transform many geometries than it is to create the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> in advance, and call <a class="el" href="classOGRCurvePolygon.html#a6c14e71640ee125335023f2f0124aecc" title="Apply arbitrary coordinate transformation to geometry.">transform()</a> with that transformation. This method exists primarily for convenience when only transforming a single geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63" title="Transform geometry to new spatial reference system.">OGR_G_TransformTo()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSR</td><td>spatial reference system to transform to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or an error code. </dd></dl>

</div>
</div>
<a id="a744223cab4361ffcdab949cebf27d5ad" name="a744223cab4361ffcdab949cebf27d5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744223cab4361ffcdab949cebf27d5ad">&#9670;&#160;</a></span>UnaryUnion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::UnaryUnion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of all components of a single geometry. </p>
<p>Usually used to convert a collection into the smallest set of polygons that cover the same area.</p>
<p>See <a href="https://postgis.net/docs/ST_UnaryUnion.html">https://postgis.net/docs/ST_UnaryUnion.html</a> for more details.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae4e284189448b23bc3dae1ad7ab54b50" title="Returns the union of all components of a single geometry.">OGR_G_UnaryUnion()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a9e4f808adcccaedbecc29fe034d312dc" name="a9e4f808adcccaedbecc29fe034d312dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4f808adcccaedbecc29fe034d312dc">&#9670;&#160;</a></span>Union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute union. </p>
<p>Generates a new geometry which is the region of union of the two geometries operated on.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#af58f2cfbdb2497659d2eabea73d3b8a0" title="Compute union.">OGR_G_Union()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry unioned with "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="a94533c5ac2331889ac93089c3316971c" name="a94533c5ac2331889ac93089c3316971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94533c5ac2331889ac93089c3316971c">&#9670;&#160;</a></span>UnionCascaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::UnionCascaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute union using cascading. </p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>The input geometry must be a MultiPolygon.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a2bb45d7d6ca9641be5f0773f1d60aa0f" title="Compute union using cascading.">OGR_G_UnionCascaded()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use <a class="el" href="classOGRGeometry.html#a744223cab4361ffcdab949cebf27d5ad" title="Returns the union of all components of a single geometry.">UnaryUnion()</a> instead </dd></dl>

</div>
</div>
<a id="a9803164ead0c4fbea9eafce64184160c" name="a9803164ead0c4fbea9eafce64184160c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9803164ead0c4fbea9eafce64184160c">&#9670;&#160;</a></span>Within()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if actual geometry object is within the passed geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72" title="Test for containment.">OGR_G_Within()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if poOtherGeom is within this geometry, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPoint.html#a6d60b7f1e06f837425e598ddc47443a8">OGRPoint</a>.</p>

</div>
</div>
<a id="ae402b4ce557a98b5f2871d5de9852a5b" name="ae402b4ce557a98b5f2871d5de9852a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae402b4ce557a98b5f2871d5de9852a5b">&#9670;&#160;</a></span>WkbSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OGRCurvePolygon::WkbSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This method returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This method relates to the SFCOM IWks::WkbSize() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>size of binary representation in bytes. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRPolygon.html#a6e5fccb1ca9e2b655c420f2bad47b9cb">OGRPolygon</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a></li>
<li><b>ogrcurvepolygon.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
