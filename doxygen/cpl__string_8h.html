<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: cpl_string.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_651562d8bf6cfd3e81eff5b570d7df50.html">port</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cpl_string.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Various convenience functions for working with strings and string lists.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cpl__error_8h_source.html">cpl_error.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cpl__conv_8h_source.html">cpl_conv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cpl__vsi_8h_source.html">cpl_vsi.h</a>&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="cpl__string_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLString.html">CPLString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient string class based on std::string.  <a href="classCPLString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLStringList.html">CPLStringList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String list class designed around our use of C "char**" string lists.  <a href="classCPLStringList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2338aada58f9282979f68e527f5aeb03" id="r_a2338aada58f9282979f68e527f5aeb03"><td class="memItemLeft" align="right" valign="top"><a id="a2338aada58f9282979f68e527f5aeb03" name="a2338aada58f9282979f68e527f5aeb03"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSLT_HONOURSTRINGS</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a2338aada58f9282979f68e527f5aeb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="cpl__string_8h.html#a48cef19d299caab18a426a30816bf4e8" title="Tokenize a string.">CSLTokenizeString2()</a> to honour strings. <br /></td></tr>
<tr class="separator:a2338aada58f9282979f68e527f5aeb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf4a54c9dc07fb312ff0f0d143048cc" id="r_a2cf4a54c9dc07fb312ff0f0d143048cc"><td class="memItemLeft" align="right" valign="top"><a id="a2cf4a54c9dc07fb312ff0f0d143048cc" name="a2cf4a54c9dc07fb312ff0f0d143048cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSLT_ALLOWEMPTYTOKENS</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a2cf4a54c9dc07fb312ff0f0d143048cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="cpl__string_8h.html#a48cef19d299caab18a426a30816bf4e8" title="Tokenize a string.">CSLTokenizeString2()</a> to allow empty tokens. <br /></td></tr>
<tr class="separator:a2cf4a54c9dc07fb312ff0f0d143048cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6b937d227431e8076ec35294a3cb56" id="r_ada6b937d227431e8076ec35294a3cb56"><td class="memItemLeft" align="right" valign="top"><a id="ada6b937d227431e8076ec35294a3cb56" name="ada6b937d227431e8076ec35294a3cb56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSLT_PRESERVEQUOTES</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:ada6b937d227431e8076ec35294a3cb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="cpl__string_8h.html#a48cef19d299caab18a426a30816bf4e8" title="Tokenize a string.">CSLTokenizeString2()</a> to preserve quotes. <br /></td></tr>
<tr class="separator:ada6b937d227431e8076ec35294a3cb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aace221e37b023221866198770ffe50" id="r_a8aace221e37b023221866198770ffe50"><td class="memItemLeft" align="right" valign="top"><a id="a8aace221e37b023221866198770ffe50" name="a8aace221e37b023221866198770ffe50"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSLT_PRESERVEESCAPES</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a8aace221e37b023221866198770ffe50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="cpl__string_8h.html#a48cef19d299caab18a426a30816bf4e8" title="Tokenize a string.">CSLTokenizeString2()</a> to preserve escape characters. <br /></td></tr>
<tr class="separator:a8aace221e37b023221866198770ffe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abb7b31dfa10f4480f4ada48db2cd5b" id="r_a3abb7b31dfa10f4480f4ada48db2cd5b"><td class="memItemLeft" align="right" valign="top"><a id="a3abb7b31dfa10f4480f4ada48db2cd5b" name="a3abb7b31dfa10f4480f4ada48db2cd5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSLT_STRIPLEADSPACES</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a3abb7b31dfa10f4480f4ada48db2cd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="cpl__string_8h.html#a48cef19d299caab18a426a30816bf4e8" title="Tokenize a string.">CSLTokenizeString2()</a> to strip leading spaces. <br /></td></tr>
<tr class="separator:a3abb7b31dfa10f4480f4ada48db2cd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45f2f4c3d953ab2bf6594ac042a265b" id="r_af45f2f4c3d953ab2bf6594ac042a265b"><td class="memItemLeft" align="right" valign="top"><a id="af45f2f4c3d953ab2bf6594ac042a265b" name="af45f2f4c3d953ab2bf6594ac042a265b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSLT_STRIPENDSPACES</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:af45f2f4c3d953ab2bf6594ac042a265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="cpl__string_8h.html#a48cef19d299caab18a426a30816bf4e8" title="Tokenize a string.">CSLTokenizeString2()</a> to strip trailaing spaces. <br /></td></tr>
<tr class="separator:af45f2f4c3d953ab2bf6594ac042a265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d69daceff916c28ef0c65506d89d6d3" id="r_a4d69daceff916c28ef0c65506d89d6d3"><td class="memItemLeft" align="right" valign="top"><a id="a4d69daceff916c28ef0c65506d89d6d3" name="a4d69daceff916c28ef0c65506d89d6d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPLES_BackslashQuotable</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a4d69daceff916c28ef0c65506d89d6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme for <a class="el" href="cpl__string_8h.html#a08201755db4923cdc823f71615d12207" title="Apply escaping to string to preserve special characters.">CPLEscapeString()</a>/CPLUnescapeString() for backlash quoting. <br /></td></tr>
<tr class="separator:a4d69daceff916c28ef0c65506d89d6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5479acb68fb882fed8bada7b92db15" id="r_a7f5479acb68fb882fed8bada7b92db15"><td class="memItemLeft" align="right" valign="top"><a id="a7f5479acb68fb882fed8bada7b92db15" name="a7f5479acb68fb882fed8bada7b92db15"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPLES_XML</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a7f5479acb68fb882fed8bada7b92db15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme for <a class="el" href="cpl__string_8h.html#a08201755db4923cdc823f71615d12207" title="Apply escaping to string to preserve special characters.">CPLEscapeString()</a>/CPLUnescapeString() for XML. <br /></td></tr>
<tr class="separator:a7f5479acb68fb882fed8bada7b92db15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88296f14572ad5a724fb512357fddb03" id="r_a88296f14572ad5a724fb512357fddb03"><td class="memItemLeft" align="right" valign="top"><a id="a88296f14572ad5a724fb512357fddb03" name="a88296f14572ad5a724fb512357fddb03"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPLES_URL</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a88296f14572ad5a724fb512357fddb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme for <a class="el" href="cpl__string_8h.html#a08201755db4923cdc823f71615d12207" title="Apply escaping to string to preserve special characters.">CPLEscapeString()</a>/CPLUnescapeString() for URL. <br /></td></tr>
<tr class="separator:a88296f14572ad5a724fb512357fddb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90614c3cf4cdd748e063f9c2cf669246" id="r_a90614c3cf4cdd748e063f9c2cf669246"><td class="memItemLeft" align="right" valign="top"><a id="a90614c3cf4cdd748e063f9c2cf669246" name="a90614c3cf4cdd748e063f9c2cf669246"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPLES_SQL</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a90614c3cf4cdd748e063f9c2cf669246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme for <a class="el" href="cpl__string_8h.html#a08201755db4923cdc823f71615d12207" title="Apply escaping to string to preserve special characters.">CPLEscapeString()</a>/CPLUnescapeString() for SQL. <br /></td></tr>
<tr class="separator:a90614c3cf4cdd748e063f9c2cf669246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3347d20cc965ec42e25bc285a763ea9" id="r_aa3347d20cc965ec42e25bc285a763ea9"><td class="memItemLeft" align="right" valign="top"><a id="aa3347d20cc965ec42e25bc285a763ea9" name="aa3347d20cc965ec42e25bc285a763ea9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPLES_CSV</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:aa3347d20cc965ec42e25bc285a763ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme for <a class="el" href="cpl__string_8h.html#a08201755db4923cdc823f71615d12207" title="Apply escaping to string to preserve special characters.">CPLEscapeString()</a>/CPLUnescapeString() for CSV. <br /></td></tr>
<tr class="separator:aa3347d20cc965ec42e25bc285a763ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbabb77330e2927fafb93b568735ccd6" id="r_abbabb77330e2927fafb93b568735ccd6"><td class="memItemLeft" align="right" valign="top"><a id="abbabb77330e2927fafb93b568735ccd6" name="abbabb77330e2927fafb93b568735ccd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPLES_XML_BUT_QUOTES</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:abbabb77330e2927fafb93b568735ccd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme for <a class="el" href="cpl__string_8h.html#a08201755db4923cdc823f71615d12207" title="Apply escaping to string to preserve special characters.">CPLEscapeString()</a>/CPLUnescapeString() for XML (preserves quotes) <br /></td></tr>
<tr class="separator:abbabb77330e2927fafb93b568735ccd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04305ab1c7d63b320aa876708f772d87" id="r_a04305ab1c7d63b320aa876708f772d87"><td class="memItemLeft" align="right" valign="top"><a id="a04305ab1c7d63b320aa876708f772d87" name="a04305ab1c7d63b320aa876708f772d87"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPLES_CSV_FORCE_QUOTING</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a04305ab1c7d63b320aa876708f772d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme for <a class="el" href="cpl__string_8h.html#a08201755db4923cdc823f71615d12207" title="Apply escaping to string to preserve special characters.">CPLEscapeString()</a>/CPLUnescapeString() for CSV (forced quoting) <br /></td></tr>
<tr class="separator:a04305ab1c7d63b320aa876708f772d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b06de69ccbf6c0f6127a8f033fd056" id="r_a97b06de69ccbf6c0f6127a8f033fd056"><td class="memItemLeft" align="right" valign="top"><a id="a97b06de69ccbf6c0f6127a8f033fd056" name="a97b06de69ccbf6c0f6127a8f033fd056"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPLES_SQLI</b>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:a97b06de69ccbf6c0f6127a8f033fd056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme for <a class="el" href="cpl__string_8h.html#a08201755db4923cdc823f71615d12207" title="Apply escaping to string to preserve special characters.">CPLEscapeString()</a>/CPLUnescapeString() for SQL identifiers. <br /></td></tr>
<tr class="separator:a97b06de69ccbf6c0f6127a8f033fd056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d8ea35a911bef8e5bd3e851043d959" id="r_a87d8ea35a911bef8e5bd3e851043d959"><td class="memItemLeft" align="right" valign="top"><a id="a87d8ea35a911bef8e5bd3e851043d959" name="a87d8ea35a911bef8e5bd3e851043d959"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPL_ENC_LOCALE</b>&#160;&#160;&#160;&quot;&quot;</td></tr>
<tr class="memdesc:a87d8ea35a911bef8e5bd3e851043d959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoding of the current locale. <br /></td></tr>
<tr class="separator:a87d8ea35a911bef8e5bd3e851043d959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d8bd24304461e94dd5a407576c6f42" id="r_a26d8bd24304461e94dd5a407576c6f42"><td class="memItemLeft" align="right" valign="top"><a id="a26d8bd24304461e94dd5a407576c6f42" name="a26d8bd24304461e94dd5a407576c6f42"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPL_ENC_UTF8</b>&#160;&#160;&#160;&quot;UTF-8&quot;</td></tr>
<tr class="memdesc:a26d8bd24304461e94dd5a407576c6f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 encoding. <br /></td></tr>
<tr class="separator:a26d8bd24304461e94dd5a407576c6f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc6144aae9925e22d6476e8df3ae937" id="r_a8bc6144aae9925e22d6476e8df3ae937"><td class="memItemLeft" align="right" valign="top"><a id="a8bc6144aae9925e22d6476e8df3ae937" name="a8bc6144aae9925e22d6476e8df3ae937"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPL_ENC_UTF16</b>&#160;&#160;&#160;&quot;UTF-16&quot;</td></tr>
<tr class="memdesc:a8bc6144aae9925e22d6476e8df3ae937"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-16 encoding. <br /></td></tr>
<tr class="separator:a8bc6144aae9925e22d6476e8df3ae937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aab58c768a810389f63c3de7867b50" id="r_a04aab58c768a810389f63c3de7867b50"><td class="memItemLeft" align="right" valign="top"><a id="a04aab58c768a810389f63c3de7867b50" name="a04aab58c768a810389f63c3de7867b50"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPL_ENC_UCS2</b>&#160;&#160;&#160;&quot;UCS-2&quot;</td></tr>
<tr class="memdesc:a04aab58c768a810389f63c3de7867b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCS-2 encoding. <br /></td></tr>
<tr class="separator:a04aab58c768a810389f63c3de7867b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134294ed95e8c77931dc817146449aa7" id="r_a134294ed95e8c77931dc817146449aa7"><td class="memItemLeft" align="right" valign="top"><a id="a134294ed95e8c77931dc817146449aa7" name="a134294ed95e8c77931dc817146449aa7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPL_ENC_UCS4</b>&#160;&#160;&#160;&quot;UCS-4&quot;</td></tr>
<tr class="memdesc:a134294ed95e8c77931dc817146449aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCS-4 encoding. <br /></td></tr>
<tr class="separator:a134294ed95e8c77931dc817146449aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc150659994a7c7d66a5ed64ed4ff9b" id="r_adcc150659994a7c7d66a5ed64ed4ff9b"><td class="memItemLeft" align="right" valign="top"><a id="adcc150659994a7c7d66a5ed64ed4ff9b" name="adcc150659994a7c7d66a5ed64ed4ff9b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPL_ENC_ASCII</b>&#160;&#160;&#160;&quot;ASCII&quot;</td></tr>
<tr class="memdesc:adcc150659994a7c7d66a5ed64ed4ff9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ASCII encoding. <br /></td></tr>
<tr class="separator:adcc150659994a7c7d66a5ed64ed4ff9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b2de9456d43c67ba3eeeb9e2ca239b" id="r_a82b2de9456d43c67ba3eeeb9e2ca239b"><td class="memItemLeft" align="right" valign="top"><a id="a82b2de9456d43c67ba3eeeb9e2ca239b" name="a82b2de9456d43c67ba3eeeb9e2ca239b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPL_ENC_ISO8859_1</b>&#160;&#160;&#160;&quot;ISO-8859-1&quot;</td></tr>
<tr class="memdesc:a82b2de9456d43c67ba3eeeb9e2ca239b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISO-8859-1 (LATIN1) encoding. <br /></td></tr>
<tr class="separator:a82b2de9456d43c67ba3eeeb9e2ca239b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a58696cad4b2dc09a3190fa5f64486bf3" id="r_a58696cad4b2dc09a3190fa5f64486bf3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a58696cad4b2dc09a3190fa5f64486bf3">CPLValueType</a> { <a class="el" href="cpl__string_8h.html#a58696cad4b2dc09a3190fa5f64486bf3a64b8a3bba9771a99925907adf8b8d580">CPL_VALUE_STRING</a>
, <a class="el" href="cpl__string_8h.html#a58696cad4b2dc09a3190fa5f64486bf3ad528bf096c3066deec561c7a8d79eac9">CPL_VALUE_REAL</a>
, <a class="el" href="cpl__string_8h.html#a58696cad4b2dc09a3190fa5f64486bf3a10b62ee4d5c309a03a6d0e1a1ccd53c9">CPL_VALUE_INTEGER</a>
 }</td></tr>
<tr class="memdesc:a58696cad4b2dc09a3190fa5f64486bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of value.  <a href="cpl__string_8h.html#a58696cad4b2dc09a3190fa5f64486bf3">More...</a><br /></td></tr>
<tr class="separator:a58696cad4b2dc09a3190fa5f64486bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8445a2b9a14142387cdd35856224c736" id="r_a8445a2b9a14142387cdd35856224c736"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a8445a2b9a14142387cdd35856224c736">CSLAddString</a> (char **papszStrList, const char *pszNewString)</td></tr>
<tr class="memdesc:a8445a2b9a14142387cdd35856224c736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a string to a StringList and return a pointer to the modified StringList.  <br /></td></tr>
<tr class="separator:a8445a2b9a14142387cdd35856224c736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9506c0cce248407959a8e34a45a827" id="r_aec9506c0cce248407959a8e34a45a827"><td class="memItemLeft" align="right" valign="top"><a id="aec9506c0cce248407959a8e34a45a827" name="aec9506c0cce248407959a8e34a45a827"></a>
char **&#160;</td><td class="memItemRight" valign="bottom"><b>CSLAddStringMayFail</b> (char **papszStrList, const char *pszNewString)</td></tr>
<tr class="memdesc:aec9506c0cce248407959a8e34a45a827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as CSLAddString() but may return NULL in case of (memory) failure. <br /></td></tr>
<tr class="separator:aec9506c0cce248407959a8e34a45a827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827f21b7a67d16059c131d0946482bb1" id="r_a827f21b7a67d16059c131d0946482bb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a827f21b7a67d16059c131d0946482bb1">CSLCount</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList)</td></tr>
<tr class="memdesc:a827f21b7a67d16059c131d0946482bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of items in a string list.  <br /></td></tr>
<tr class="separator:a827f21b7a67d16059c131d0946482bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730ac2e48a15ebfdd23b558b82a43ebe" id="r_a730ac2e48a15ebfdd23b558b82a43ebe"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a730ac2e48a15ebfdd23b558b82a43ebe">CSLGetField</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>, int)</td></tr>
<tr class="memdesc:a730ac2e48a15ebfdd23b558b82a43ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the indicated field, being careful not to crash if the field doesn't exist within this string list.  <br /></td></tr>
<tr class="separator:a730ac2e48a15ebfdd23b558b82a43ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a39b9c5896a273cc6f06c1d5be93238" id="r_a5a39b9c5896a273cc6f06c1d5be93238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238">CSLDestroy</a> (char **papszStrList)</td></tr>
<tr class="memdesc:a5a39b9c5896a273cc6f06c1d5be93238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free string list.  <br /></td></tr>
<tr class="separator:a5a39b9c5896a273cc6f06c1d5be93238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88bb0ccd4baa3c6d974e99ffde6d6a9" id="r_ad88bb0ccd4baa3c6d974e99ffde6d6a9"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ad88bb0ccd4baa3c6d974e99ffde6d6a9">CSLDuplicate</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList)</td></tr>
<tr class="memdesc:ad88bb0ccd4baa3c6d974e99ffde6d6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a string list.  <br /></td></tr>
<tr class="separator:ad88bb0ccd4baa3c6d974e99ffde6d6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f338c7010d3f367f64eb094bbc29eb" id="r_ae8f338c7010d3f367f64eb094bbc29eb"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ae8f338c7010d3f367f64eb094bbc29eb">CSLMerge</a> (char **papszOrig, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOverride)</td></tr>
<tr class="memdesc:ae8f338c7010d3f367f64eb094bbc29eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two lists.  <br /></td></tr>
<tr class="separator:ae8f338c7010d3f367f64eb094bbc29eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30d22f0b8f173f805adaeac54f50fac" id="r_aa30d22f0b8f173f805adaeac54f50fac"><td class="memItemLeft" align="right" valign="top"><a id="aa30d22f0b8f173f805adaeac54f50fac" name="aa30d22f0b8f173f805adaeac54f50fac"></a>
char **&#160;</td><td class="memItemRight" valign="bottom"><b>CSLTokenizeString</b> (const char *pszString)</td></tr>
<tr class="memdesc:aa30d22f0b8f173f805adaeac54f50fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenizes a string and returns a StringList with one string for each token. <br /></td></tr>
<tr class="separator:aa30d22f0b8f173f805adaeac54f50fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11722f741f5f766b4b4c537e3129e21c" id="r_a11722f741f5f766b4b4c537e3129e21c"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a11722f741f5f766b4b4c537e3129e21c">CSLTokenizeStringComplex</a> (const char *pszString, const char *pszDelimiter, int bHonourStrings, int bAllowEmptyTokens)</td></tr>
<tr class="memdesc:a11722f741f5f766b4b4c537e3129e21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obsolete tokenizing api.  <br /></td></tr>
<tr class="separator:a11722f741f5f766b4b4c537e3129e21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cef19d299caab18a426a30816bf4e8" id="r_a48cef19d299caab18a426a30816bf4e8"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a48cef19d299caab18a426a30816bf4e8">CSLTokenizeString2</a> (const char *pszString, const char *pszDelimiter, int nCSLTFlags)</td></tr>
<tr class="memdesc:a48cef19d299caab18a426a30816bf4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenize a string.  <br /></td></tr>
<tr class="separator:a48cef19d299caab18a426a30816bf4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baf50b494941fe28c65b4d43d2ce36f" id="r_a3baf50b494941fe28c65b4d43d2ce36f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a3baf50b494941fe28c65b4d43d2ce36f">CSLPrint</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList, FILE *fpOut)</td></tr>
<tr class="memdesc:a3baf50b494941fe28c65b4d43d2ce36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a StringList to fpOut.  <br /></td></tr>
<tr class="separator:a3baf50b494941fe28c65b4d43d2ce36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63d7761b8a380c07b582729dfed2c74" id="r_ab63d7761b8a380c07b582729dfed2c74"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ab63d7761b8a380c07b582729dfed2c74">CSLLoad</a> (const char *pszFname)</td></tr>
<tr class="memdesc:ab63d7761b8a380c07b582729dfed2c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a text file into a string list.  <br /></td></tr>
<tr class="separator:ab63d7761b8a380c07b582729dfed2c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab881670cedcdc221394cc35de8c508e6" id="r_ab881670cedcdc221394cc35de8c508e6"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ab881670cedcdc221394cc35de8c508e6">CSLLoad2</a> (const char *pszFname, int nMaxLines, int nMaxCols, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:ab881670cedcdc221394cc35de8c508e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a text file into a string list.  <br /></td></tr>
<tr class="separator:ab881670cedcdc221394cc35de8c508e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75750c97bdcf1ccf13ffaae6a30a07a6" id="r_a75750c97bdcf1ccf13ffaae6a30a07a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a75750c97bdcf1ccf13ffaae6a30a07a6">CSLSave</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList, const char *pszFname)</td></tr>
<tr class="memdesc:a75750c97bdcf1ccf13ffaae6a30a07a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a StringList to a text file.  <br /></td></tr>
<tr class="separator:a75750c97bdcf1ccf13ffaae6a30a07a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bf8a17b5b3305f2711a01b7d778113" id="r_ad1bf8a17b5b3305f2711a01b7d778113"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ad1bf8a17b5b3305f2711a01b7d778113">CSLInsertStrings</a> (char **papszStrList, int nInsertAtLineNo, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszNewLines)</td></tr>
<tr class="memdesc:ad1bf8a17b5b3305f2711a01b7d778113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of a StringList inside another StringList before the specified line.  <br /></td></tr>
<tr class="separator:ad1bf8a17b5b3305f2711a01b7d778113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956390f5a48f1019d6e0374530604edf" id="r_a956390f5a48f1019d6e0374530604edf"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a956390f5a48f1019d6e0374530604edf">CSLInsertString</a> (char **papszStrList, int nInsertAtLineNo, const char *pszNewLine)</td></tr>
<tr class="memdesc:a956390f5a48f1019d6e0374530604edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a string at a given line number inside a StringList.  <br /></td></tr>
<tr class="separator:a956390f5a48f1019d6e0374530604edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab539fd5cef8ad875d12fba3ef104f6ca" id="r_ab539fd5cef8ad875d12fba3ef104f6ca"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ab539fd5cef8ad875d12fba3ef104f6ca">CSLRemoveStrings</a> (char **papszStrList, int nFirstLineToDelete, int nNumToRemove, char ***ppapszRetStrings)</td></tr>
<tr class="memdesc:ab539fd5cef8ad875d12fba3ef104f6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove strings inside a StringList.  <br /></td></tr>
<tr class="separator:ab539fd5cef8ad875d12fba3ef104f6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e2f4bc3bbf2cca1a8bf9954fae5174" id="r_a74e2f4bc3bbf2cca1a8bf9954fae5174"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a74e2f4bc3bbf2cca1a8bf9954fae5174">CSLFindString</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszList, const char *pszTarget)</td></tr>
<tr class="memdesc:a74e2f4bc3bbf2cca1a8bf9954fae5174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a string within a string list (case insensitive).  <br /></td></tr>
<tr class="separator:a74e2f4bc3bbf2cca1a8bf9954fae5174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0716feff9a1b9f40e14226c8a7a127c5" id="r_a0716feff9a1b9f40e14226c8a7a127c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a0716feff9a1b9f40e14226c8a7a127c5">CSLFindStringCaseSensitive</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszList, const char *pszTarget)</td></tr>
<tr class="memdesc:a0716feff9a1b9f40e14226c8a7a127c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a string within a string list(case sensitive)  <br /></td></tr>
<tr class="separator:a0716feff9a1b9f40e14226c8a7a127c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f36efd8180e51959d075fe759d8c7be" id="r_a9f36efd8180e51959d075fe759d8c7be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a9f36efd8180e51959d075fe759d8c7be">CSLPartialFindString</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszHaystack, const char *pszNeedle)</td></tr>
<tr class="memdesc:a9f36efd8180e51959d075fe759d8c7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a substring within a string list.  <br /></td></tr>
<tr class="separator:a9f36efd8180e51959d075fe759d8c7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba908f3bf572c87dadeade7e8cbc260" id="r_a5ba908f3bf572c87dadeade7e8cbc260"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a5ba908f3bf572c87dadeade7e8cbc260">CSLFindName</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList, const char *pszName)</td></tr>
<tr class="memdesc:a5ba908f3bf572c87dadeade7e8cbc260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find StringList entry with given key name.  <br /></td></tr>
<tr class="separator:a5ba908f3bf572c87dadeade7e8cbc260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4157385a06d3d1cc905fda008cd75" id="r_ac8d4157385a06d3d1cc905fda008cd75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ac8d4157385a06d3d1cc905fda008cd75">CSLFetchBoolean</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList, const char *pszKey, int bDefault)</td></tr>
<tr class="memdesc:ac8d4157385a06d3d1cc905fda008cd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED.  <br /></td></tr>
<tr class="separator:ac8d4157385a06d3d1cc905fda008cd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada798bb0fafd08c7908d0f3716f341b3" id="r_ada798bb0fafd08c7908d0f3716f341b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ada798bb0fafd08c7908d0f3716f341b3">CSLTestBoolean</a> (const char *pszValue)</td></tr>
<tr class="memdesc:ada798bb0fafd08c7908d0f3716f341b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test what boolean value contained in the string.  <br /></td></tr>
<tr class="separator:ada798bb0fafd08c7908d0f3716f341b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8206b42cbbc7d96b2c3aaf093a00de1" id="r_af8206b42cbbc7d96b2c3aaf093a00de1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#af8206b42cbbc7d96b2c3aaf093a00de1">CPLTestBoolean</a> (const char *pszValue)</td></tr>
<tr class="memdesc:af8206b42cbbc7d96b2c3aaf093a00de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test what boolean value contained in the string.  <br /></td></tr>
<tr class="separator:af8206b42cbbc7d96b2c3aaf093a00de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6873dfd5c12d0b24e561ce65b4266d" id="r_a7e6873dfd5c12d0b24e561ce65b4266d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a7e6873dfd5c12d0b24e561ce65b4266d">CPLTestBool</a> (const char *pszValue)</td></tr>
<tr class="memdesc:a7e6873dfd5c12d0b24e561ce65b4266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test what boolean value contained in the string.  <br /></td></tr>
<tr class="separator:a7e6873dfd5c12d0b24e561ce65b4266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac8be2978f873873dbb1ad47f8d9319" id="r_a5ac8be2978f873873dbb1ad47f8d9319"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a5ac8be2978f873873dbb1ad47f8d9319">CPLFetchBool</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList, const char *pszKey, bool bDefault)</td></tr>
<tr class="memdesc:a5ac8be2978f873873dbb1ad47f8d9319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for boolean key value.  <br /></td></tr>
<tr class="separator:a5ac8be2978f873873dbb1ad47f8d9319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91223c2a3b06931310e4ad52165117f" id="r_ad91223c2a3b06931310e4ad52165117f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ad91223c2a3b06931310e4ad52165117f">CPLParseNameValue</a> (const char *pszNameValue, char **ppszKey)</td></tr>
<tr class="memdesc:ad91223c2a3b06931310e4ad52165117f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse NAME=VALUE string into name and value components.  <br /></td></tr>
<tr class="separator:ad91223c2a3b06931310e4ad52165117f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6614f3d2c28629c7967430c0ed14e6ee" id="r_a6614f3d2c28629c7967430c0ed14e6ee"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a6614f3d2c28629c7967430c0ed14e6ee">CPLParseNameValueSep</a> (const char *pszNameValue, char **ppszKey, char chSep)</td></tr>
<tr class="memdesc:a6614f3d2c28629c7967430c0ed14e6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse NAME&lt;Sep&gt;VALUE string into name and value components.  <br /></td></tr>
<tr class="separator:a6614f3d2c28629c7967430c0ed14e6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f23675f8b6f015ed23d9928048361a1" id="r_a4f23675f8b6f015ed23d9928048361a1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a4f23675f8b6f015ed23d9928048361a1">CSLFetchNameValue</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList, const char *pszName)</td></tr>
<tr class="memdesc:a4f23675f8b6f015ed23d9928048361a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In a StringList of "Name=Value" pairs, look for the first value associated with the specified name.  <br /></td></tr>
<tr class="separator:a4f23675f8b6f015ed23d9928048361a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816f2922f536aa822c00fd1d8fa24935" id="r_a816f2922f536aa822c00fd1d8fa24935"><td class="memItemLeft" align="right" valign="top"><a id="a816f2922f536aa822c00fd1d8fa24935" name="a816f2922f536aa822c00fd1d8fa24935"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>CSLFetchNameValueDef</b> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList, const char *pszName, const char *pszDefault)</td></tr>
<tr class="memdesc:a816f2922f536aa822c00fd1d8fa24935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as CSLFetchNameValue() but return pszDefault in case of no match. <br /></td></tr>
<tr class="separator:a816f2922f536aa822c00fd1d8fa24935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa868f5db129cbabe130bbfd03d1d4839" id="r_aa868f5db129cbabe130bbfd03d1d4839"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#aa868f5db129cbabe130bbfd03d1d4839">CSLFetchNameValueMultiple</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszStrList, const char *pszName)</td></tr>
<tr class="memdesc:aa868f5db129cbabe130bbfd03d1d4839"><td class="mdescLeft">&#160;</td><td class="mdescRight">In a StringList of "Name=Value" pairs, look for all the values with the specified name.  <br /></td></tr>
<tr class="separator:aa868f5db129cbabe130bbfd03d1d4839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260bac64c376e2fe723a158569ccbb24" id="r_a260bac64c376e2fe723a158569ccbb24"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a260bac64c376e2fe723a158569ccbb24">CSLAddNameValue</a> (char **papszStrList, const char *pszName, const char *pszValue)</td></tr>
<tr class="memdesc:a260bac64c376e2fe723a158569ccbb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new entry to a StringList of "Name=Value" pairs, ("Name:Value" pairs are also supported for backward compatibility with older stuff.)  <br /></td></tr>
<tr class="separator:a260bac64c376e2fe723a158569ccbb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e0ecf12c50f0e9b69db4643f96d004" id="r_ab0e0ecf12c50f0e9b69db4643f96d004"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ab0e0ecf12c50f0e9b69db4643f96d004">CSLSetNameValue</a> (char **papszStrList, const char *pszName, const char *pszValue)</td></tr>
<tr class="memdesc:ab0e0ecf12c50f0e9b69db4643f96d004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign value to name in StringList.  <br /></td></tr>
<tr class="separator:ab0e0ecf12c50f0e9b69db4643f96d004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b38f55a35f3c1d66ba343692ab9ec0" id="r_a97b38f55a35f3c1d66ba343692ab9ec0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a97b38f55a35f3c1d66ba343692ab9ec0">CSLSetNameValueSeparator</a> (char **papszStrList, const char *pszSeparator)</td></tr>
<tr class="memdesc:a97b38f55a35f3c1d66ba343692ab9ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the default separator (":" or "=") with the passed separator in the given name/value list.  <br /></td></tr>
<tr class="separator:a97b38f55a35f3c1d66ba343692ab9ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80da7e2cabe09e999eb4e597f4df0ba9" id="r_a80da7e2cabe09e999eb4e597f4df0ba9"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a80da7e2cabe09e999eb4e597f4df0ba9">CSLParseCommandLine</a> (const char *pszCommandLine)</td></tr>
<tr class="memdesc:a80da7e2cabe09e999eb4e597f4df0ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenize command line arguments in a list of strings.  <br /></td></tr>
<tr class="separator:a80da7e2cabe09e999eb4e597f4df0ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08201755db4923cdc823f71615d12207" id="r_a08201755db4923cdc823f71615d12207"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a08201755db4923cdc823f71615d12207">CPLEscapeString</a> (const char *pszString, int nLength, int nScheme)</td></tr>
<tr class="memdesc:a08201755db4923cdc823f71615d12207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply escaping to string to preserve special characters.  <br /></td></tr>
<tr class="separator:a08201755db4923cdc823f71615d12207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af066b55bb33e580b6d86904828daee31" id="r_af066b55bb33e580b6d86904828daee31"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#af066b55bb33e580b6d86904828daee31">CPLUnescapeString</a> (const char *pszString, int *pnLength, int nScheme)</td></tr>
<tr class="memdesc:af066b55bb33e580b6d86904828daee31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unescape a string.  <br /></td></tr>
<tr class="separator:af066b55bb33e580b6d86904828daee31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feb4f054598b78197d5ddf3011e830d" id="r_a0feb4f054598b78197d5ddf3011e830d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a0feb4f054598b78197d5ddf3011e830d">CPLBinaryToHex</a> (int nBytes, const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *pabyData)</td></tr>
<tr class="memdesc:a0feb4f054598b78197d5ddf3011e830d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary to hexadecimal translation.  <br /></td></tr>
<tr class="separator:a0feb4f054598b78197d5ddf3011e830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aff1c9cccf82b941da8a7f375a1391" id="r_ae0aff1c9cccf82b941da8a7f375a1391"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ae0aff1c9cccf82b941da8a7f375a1391">CPLHexToBinary</a> (const char *pszHex, int *pnBytes)</td></tr>
<tr class="memdesc:ae0aff1c9cccf82b941da8a7f375a1391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hexadecimal to binary translation.  <br /></td></tr>
<tr class="separator:ae0aff1c9cccf82b941da8a7f375a1391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a4b48b69dc279ea5e2a89e1ef30350" id="r_af5a4b48b69dc279ea5e2a89e1ef30350"><td class="memItemLeft" align="right" valign="top"><a id="af5a4b48b69dc279ea5e2a89e1ef30350" name="af5a4b48b69dc279ea5e2a89e1ef30350"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>CPLBase64Encode</b> (int nBytes, const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *pabyData)</td></tr>
<tr class="memdesc:af5a4b48b69dc279ea5e2a89e1ef30350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base64 encode a buffer. <br /></td></tr>
<tr class="separator:af5a4b48b69dc279ea5e2a89e1ef30350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7b946cdafbe30a1d0f74e5a5c15f29" id="r_a1e7b946cdafbe30a1d0f74e5a5c15f29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a1e7b946cdafbe30a1d0f74e5a5c15f29">CPLBase64DecodeInPlace</a> (<a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *pszBase64)</td></tr>
<tr class="memdesc:a1e7b946cdafbe30a1d0f74e5a5c15f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode base64 string "pszBase64" (null terminated) in place.  <br /></td></tr>
<tr class="separator:a1e7b946cdafbe30a1d0f74e5a5c15f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0188f43b0848407f5e6e7c3cfdbb8" id="r_aafb0188f43b0848407f5e6e7c3cfdbb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__string_8h.html#a58696cad4b2dc09a3190fa5f64486bf3">CPLValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#aafb0188f43b0848407f5e6e7c3cfdbb8">CPLGetValueType</a> (const char *pszValue)</td></tr>
<tr class="memdesc:aafb0188f43b0848407f5e6e7c3cfdbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect the type of the value contained in a string, whether it is a real, an integer or a string Leading and trailing spaces are skipped in the analysis.  <br /></td></tr>
<tr class="separator:aafb0188f43b0848407f5e6e7c3cfdbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea84812431610a8f65dcfd09ec3ea7c" id="r_adea84812431610a8f65dcfd09ec3ea7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#adea84812431610a8f65dcfd09ec3ea7c">CPLToupper</a> (int c)</td></tr>
<tr class="memdesc:adea84812431610a8f65dcfd09ec3ea7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (ASCII) lowercase character to uppercase.  <br /></td></tr>
<tr class="separator:adea84812431610a8f65dcfd09ec3ea7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b41a4419b0710245e8cdfa655823b4e" id="r_a6b41a4419b0710245e8cdfa655823b4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a6b41a4419b0710245e8cdfa655823b4e">CPLTolower</a> (int c)</td></tr>
<tr class="memdesc:a6b41a4419b0710245e8cdfa655823b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (ASCII) uppercase character to lowercase.  <br /></td></tr>
<tr class="separator:a6b41a4419b0710245e8cdfa655823b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dee6db43b3ce18912ee45fbfc83e747" id="r_a4dee6db43b3ce18912ee45fbfc83e747"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a4dee6db43b3ce18912ee45fbfc83e747">CPLStrlcpy</a> (char *pszDest, const char *pszSrc, size_t nDestSize)</td></tr>
<tr class="memdesc:a4dee6db43b3ce18912ee45fbfc83e747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy source string to a destination buffer.  <br /></td></tr>
<tr class="separator:a4dee6db43b3ce18912ee45fbfc83e747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35417428994b5306ca08df7899f9703c" id="r_a35417428994b5306ca08df7899f9703c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a35417428994b5306ca08df7899f9703c">CPLStrlcat</a> (char *pszDest, const char *pszSrc, size_t nDestSize)</td></tr>
<tr class="memdesc:a35417428994b5306ca08df7899f9703c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a source string to a destination buffer.  <br /></td></tr>
<tr class="separator:a35417428994b5306ca08df7899f9703c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d45dc0510e8e8f4e58f3cb70e341732" id="r_a8d45dc0510e8e8f4e58f3cb70e341732"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a8d45dc0510e8e8f4e58f3cb70e341732">CPLStrnlen</a> (const char *pszStr, size_t nMaxLen)</td></tr>
<tr class="memdesc:a8d45dc0510e8e8f4e58f3cb70e341732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a NUL terminated string by reading at most the specified number of bytes.  <br /></td></tr>
<tr class="separator:a8d45dc0510e8e8f4e58f3cb70e341732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bbf9c41f4ae994e2bd4e1466d4ed0b" id="r_a07bbf9c41f4ae994e2bd4e1466d4ed0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a07bbf9c41f4ae994e2bd4e1466d4ed0b">CPLvsnprintf</a> (char *str, size_t size, const char *fmt, va_list args)</td></tr>
<tr class="memdesc:a07bbf9c41f4ae994e2bd4e1466d4ed0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vsnprintf() wrapper that is not sensitive to LC_NUMERIC settings.  <br /></td></tr>
<tr class="separator:a07bbf9c41f4ae994e2bd4e1466d4ed0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bc998139a3664bb33f03848e1cf08a" id="r_a52bc998139a3664bb33f03848e1cf08a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a52bc998139a3664bb33f03848e1cf08a">CPLsnprintf</a> (char *str, size_t size, const char *fmt,...)</td></tr>
<tr class="memdesc:a52bc998139a3664bb33f03848e1cf08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">snprintf() wrapper that is not sensitive to LC_NUMERIC settings.  <br /></td></tr>
<tr class="separator:a52bc998139a3664bb33f03848e1cf08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125dbe90534c2688426bb518b81d262e" id="r_a125dbe90534c2688426bb518b81d262e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a125dbe90534c2688426bb518b81d262e">CPLprintf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a125dbe90534c2688426bb518b81d262e"><td class="mdescLeft">&#160;</td><td class="mdescRight">printf() wrapper that is not sensitive to LC_NUMERIC settings.  <br /></td></tr>
<tr class="separator:a125dbe90534c2688426bb518b81d262e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfcfa28b741e1e8fb266d47a9b2b944" id="r_adbfcfa28b741e1e8fb266d47a9b2b944"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#adbfcfa28b741e1e8fb266d47a9b2b944">CPLSPrintf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:adbfcfa28b741e1e8fb266d47a9b2b944"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPLSPrintf() that works with 10 static buffer.  <br /></td></tr>
<tr class="separator:adbfcfa28b741e1e8fb266d47a9b2b944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82ba646903716247a341e95b478288" id="r_acf82ba646903716247a341e95b478288"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#acf82ba646903716247a341e95b478288">CSLAppendPrintf</a> (char **papszStrList, const char *fmt,...)</td></tr>
<tr class="memdesc:acf82ba646903716247a341e95b478288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use CPLSPrintf() to append a new line at the end of a StringList.  <br /></td></tr>
<tr class="separator:acf82ba646903716247a341e95b478288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394d3ee8e57452cd7d4207b031e75bd" id="r_a6394d3ee8e57452cd7d4207b031e75bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a6394d3ee8e57452cd7d4207b031e75bd">CPLVASPrintf</a> (char **buf, const char *fmt, va_list args)</td></tr>
<tr class="memdesc:a6394d3ee8e57452cd7d4207b031e75bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is intended to serve as an easy to use C callable vasprintf() alternative.  <br /></td></tr>
<tr class="separator:a6394d3ee8e57452cd7d4207b031e75bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4d78cf4a6db43d07129a89af6fd45d" id="r_aed4d78cf4a6db43d07129a89af6fd45d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#aed4d78cf4a6db43d07129a89af6fd45d">CPLEncodingCharSize</a> (const char *pszEncoding)</td></tr>
<tr class="memdesc:aed4d78cf4a6db43d07129a89af6fd45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return bytes per character for encoding.  <br /></td></tr>
<tr class="separator:aed4d78cf4a6db43d07129a89af6fd45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab848e2fb5cce507247cbbafe1dafc1bf" id="r_ab848e2fb5cce507247cbbafe1dafc1bf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ab848e2fb5cce507247cbbafe1dafc1bf">CPLRecode</a> (const char *pszSource, const char *pszSrcEncoding, const char *pszDstEncoding)</td></tr>
<tr class="memdesc:ab848e2fb5cce507247cbbafe1dafc1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string from a source encoding to a destination encoding.  <br /></td></tr>
<tr class="separator:ab848e2fb5cce507247cbbafe1dafc1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51398fbf4d8afe5ec8f32177c2a5709e" id="r_a51398fbf4d8afe5ec8f32177c2a5709e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a51398fbf4d8afe5ec8f32177c2a5709e">CPLRecodeFromWChar</a> (const wchar_t *pwszSource, const char *pszSrcEncoding, const char *pszDstEncoding)</td></tr>
<tr class="memdesc:a51398fbf4d8afe5ec8f32177c2a5709e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert wchar_t string to UTF-8.  <br /></td></tr>
<tr class="separator:a51398fbf4d8afe5ec8f32177c2a5709e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6413c61c9b78f1e0b8a9ecc954a14f" id="r_afe6413c61c9b78f1e0b8a9ecc954a14f"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#afe6413c61c9b78f1e0b8a9ecc954a14f">CPLRecodeToWChar</a> (const char *pszSource, const char *pszSrcEncoding, const char *pszDstEncoding)</td></tr>
<tr class="memdesc:afe6413c61c9b78f1e0b8a9ecc954a14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UTF-8 string to a wchar_t string.  <br /></td></tr>
<tr class="separator:afe6413c61c9b78f1e0b8a9ecc954a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b56be2f17e4c2300af2f0357d32baec" id="r_a9b56be2f17e4c2300af2f0357d32baec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a9b56be2f17e4c2300af2f0357d32baec">CPLIsUTF8</a> (const char *pabyData, int nLen)</td></tr>
<tr class="memdesc:a9b56be2f17e4c2300af2f0357d32baec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string is encoded as UTF-8.  <br /></td></tr>
<tr class="separator:a9b56be2f17e4c2300af2f0357d32baec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53611712cbde9fad4d5616b1357aeecf" id="r_a53611712cbde9fad4d5616b1357aeecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a53611712cbde9fad4d5616b1357aeecf">CPLIsASCII</a> (const char *pabyData, size_t nLen)</td></tr>
<tr class="memdesc:a53611712cbde9fad4d5616b1357aeecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string is encoded as ASCII.  <br /></td></tr>
<tr class="separator:a53611712cbde9fad4d5616b1357aeecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9d8d2dd19da9a8a59799175f50fa80" id="r_a3f9d8d2dd19da9a8a59799175f50fa80"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a3f9d8d2dd19da9a8a59799175f50fa80">CPLForceToASCII</a> (const char *pabyData, int nLen, char chReplacementChar)</td></tr>
<tr class="memdesc:a3f9d8d2dd19da9a8a59799175f50fa80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new string that is made only of ASCII characters.  <br /></td></tr>
<tr class="separator:a3f9d8d2dd19da9a8a59799175f50fa80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94da8e06c5bc7d7decce57e245551d13" id="r_a94da8e06c5bc7d7decce57e245551d13"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a94da8e06c5bc7d7decce57e245551d13">CPLUTF8ForceToASCII</a> (const char *pszStr, char chReplacementChar)</td></tr>
<tr class="memdesc:a94da8e06c5bc7d7decce57e245551d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new string that is made only of ASCII characters.  <br /></td></tr>
<tr class="separator:a94da8e06c5bc7d7decce57e245551d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8e4b09f4437d7ef0cc09b5e3ab93cb" id="r_acc8e4b09f4437d7ef0cc09b5e3ab93cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#acc8e4b09f4437d7ef0cc09b5e3ab93cb">CPLStrlenUTF8</a> (const char *pszUTF8Str)</td></tr>
<tr class="memdesc:acc8e4b09f4437d7ef0cc09b5e3ab93cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of UTF-8 characters of a nul-terminated string.  <br /></td></tr>
<tr class="separator:acc8e4b09f4437d7ef0cc09b5e3ab93cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729bc2a41d9459cabde20d2d46abbfd0" id="r_a729bc2a41d9459cabde20d2d46abbfd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a729bc2a41d9459cabde20d2d46abbfd0">CPLCanRecode</a> (const char *pszTestStr, const char *pszSrcEncoding, const char *pszDstEncoding)</td></tr>
<tr class="memdesc:a729bc2a41d9459cabde20d2d46abbfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if it is possible to recode a string from one encoding to another.  <br /></td></tr>
<tr class="separator:a729bc2a41d9459cabde20d2d46abbfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4abb2f061361ee535ec483a5342469" id="r_a2e4abb2f061361ee535ec483a5342469"><td class="memItemLeft" align="right" valign="top"><a id="a2e4abb2f061361ee535ec483a5342469" name="a2e4abb2f061361ee535ec483a5342469"></a>
<a class="el" href="classCPLString.html">CPLString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CPLOPrintf</b> (const char *pszFormat,...)</td></tr>
<tr class="memdesc:a2e4abb2f061361ee535ec483a5342469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classCPLString.html" title="Convenient string class based on std::string.">CPLString</a> with the content of sprintf() <br /></td></tr>
<tr class="separator:a2e4abb2f061361ee535ec483a5342469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f34d382627c37ce414188e679389a8" id="r_ad2f34d382627c37ce414188e679389a8"><td class="memItemLeft" align="right" valign="top"><a id="ad2f34d382627c37ce414188e679389a8" name="ad2f34d382627c37ce414188e679389a8"></a>
<a class="el" href="classCPLString.html">CPLString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CPLOvPrintf</b> (const char *pszFormat, va_list args)</td></tr>
<tr class="memdesc:ad2f34d382627c37ce414188e679389a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classCPLString.html" title="Convenient string class based on std::string.">CPLString</a> with the content of vsprintf() <br /></td></tr>
<tr class="separator:ad2f34d382627c37ce414188e679389a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3e2a3a5717d890a1f5e4fb7f089dc7" id="r_a2e3e2a3a5717d890a1f5e4fb7f089dc7"><td class="memItemLeft" align="right" valign="top"><a id="a2e3e2a3a5717d890a1f5e4fb7f089dc7" name="a2e3e2a3a5717d890a1f5e4fb7f089dc7"></a>
<a class="el" href="classCPLString.html">CPLString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CPLQuotedSQLIdentifier</b> (const char *pszIdent)</td></tr>
<tr class="memdesc:a2e3e2a3a5717d890a1f5e4fb7f089dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classCPLString.html" title="Convenient string class based on std::string.">CPLString</a> of the SQL quoted identifier. <br /></td></tr>
<tr class="separator:a2e3e2a3a5717d890a1f5e4fb7f089dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49550245214ac079518c5fcd5084ecd0" id="r_a49550245214ac079518c5fcd5084ecd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCPLString.html">CPLString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a49550245214ac079518c5fcd5084ecd0">CPLURLGetValue</a> (const char *pszURL, const char *pszKey)</td></tr>
<tr class="memdesc:a49550245214ac079518c5fcd5084ecd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value matching a key from a key=value pair in a URL.  <br /></td></tr>
<tr class="separator:a49550245214ac079518c5fcd5084ecd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45405998f4df728887be28a1a6d4b6e" id="r_ac45405998f4df728887be28a1a6d4b6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCPLString.html">CPLString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ac45405998f4df728887be28a1a6d4b6e">CPLURLAddKVP</a> (const char *pszURL, const char *pszKey, const char *pszValue)</td></tr>
<tr class="memdesc:ac45405998f4df728887be28a1a6d4b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new URL with a new key=value pair.  <br /></td></tr>
<tr class="separator:ac45405998f4df728887be28a1a6d4b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Various convenience functions for working with strings and string lists. </p>
<p>A StringList is just an array of strings with the last pointer being NULL. An empty StringList may be either a NULL pointer, or a pointer to a pointer memory location with a NULL value.</p>
<p>A common convention for StringLists is to use them to store name/value lists. In this case the contents are treated like a dictionary of name/value pairs. The actual data is formatted with each string having the format "&lt;name&gt;:&lt;value&gt;" (though "=" is also an acceptable separator). A number of the functions in the file operate on name/value style string lists (such as <a class="el" href="cpl__string_8h.html#ab0e0ecf12c50f0e9b69db4643f96d004" title="Assign value to name in StringList.">CSLSetNameValue()</a>, and <a class="el" href="cpl__string_8h.html#a4f23675f8b6f015ed23d9928048361a1" title="In a StringList of &quot;Name=Value&quot; pairs, look for the first value associated with the specified name.">CSLFetchNameValue()</a>).</p>
<p>To some extent the <a class="el" href="classCPLStringList.html" title="String list class designed around our use of C &quot;char**&quot; string lists.">CPLStringList</a> C++ class can be used to abstract managing string lists a bit but still be able to return them from C functions. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a58696cad4b2dc09a3190fa5f64486bf3" name="a58696cad4b2dc09a3190fa5f64486bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58696cad4b2dc09a3190fa5f64486bf3">&#9670;&#160;</a></span>CPLValueType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cpl__string_8h.html#a58696cad4b2dc09a3190fa5f64486bf3">CPLValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a58696cad4b2dc09a3190fa5f64486bf3a64b8a3bba9771a99925907adf8b8d580" name="a58696cad4b2dc09a3190fa5f64486bf3a64b8a3bba9771a99925907adf8b8d580"></a>CPL_VALUE_STRING&#160;</td><td class="fielddoc"><p>String. </p>
</td></tr>
<tr><td class="fieldname"><a id="a58696cad4b2dc09a3190fa5f64486bf3ad528bf096c3066deec561c7a8d79eac9" name="a58696cad4b2dc09a3190fa5f64486bf3ad528bf096c3066deec561c7a8d79eac9"></a>CPL_VALUE_REAL&#160;</td><td class="fielddoc"><p>Real number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a58696cad4b2dc09a3190fa5f64486bf3a10b62ee4d5c309a03a6d0e1a1ccd53c9" name="a58696cad4b2dc09a3190fa5f64486bf3a10b62ee4d5c309a03a6d0e1a1ccd53c9"></a>CPL_VALUE_INTEGER&#160;</td><td class="fielddoc"><p>Integer. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1e7b946cdafbe30a1d0f74e5a5c15f29" name="a1e7b946cdafbe30a1d0f74e5a5c15f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7b946cdafbe30a1d0f74e5a5c15f29">&#9670;&#160;</a></span>CPLBase64DecodeInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLBase64DecodeInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td>
          <td class="paramname"><em>pszBase64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode base64 string "pszBase64" (null terminated) in place. </p>
<p>Returns length of decoded array or 0 on failure. </p>

</div>
</div>
<a id="a0feb4f054598b78197d5ddf3011e830d" name="a0feb4f054598b78197d5ddf3011e830d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0feb4f054598b78197d5ddf3011e830d">&#9670;&#160;</a></span>CPLBinaryToHex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLBinaryToHex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td>
          <td class="paramname"><em>pabyData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary to hexadecimal translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nBytes</td><td>number of bytes of binary data in pabyData. </td></tr>
    <tr><td class="paramname">pabyData</td><td>array of data bytes to translate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hexadecimal translation, zero terminated. Free with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>. </dd></dl>

</div>
</div>
<a id="a729bc2a41d9459cabde20d2d46abbfd0" name="a729bc2a41d9459cabde20d2d46abbfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729bc2a41d9459cabde20d2d46abbfd0">&#9670;&#160;</a></span>CPLCanRecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLCanRecode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTestStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrcEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDstEncoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if it is possible to recode a string from one encoding to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTestStr</td><td>a NULL terminated string. </td></tr>
    <tr><td class="paramname">pszSrcEncoding</td><td>the source encoding. </td></tr>
    <tr><td class="paramname">pszDstEncoding</td><td>the destination encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a TRUE if recode is possible.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1.0 </dd></dl>

</div>
</div>
<a id="aed4d78cf4a6db43d07129a89af6fd45d" name="aed4d78cf4a6db43d07129a89af6fd45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4d78cf4a6db43d07129a89af6fd45d">&#9670;&#160;</a></span>CPLEncodingCharSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLEncodingCharSize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszEncoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return bytes per character for encoding. </p>
<p>This function returns the size in bytes of the smallest character in this encoding. For fixed width encodings (ASCII, UCS-2, UCS-4) this is straight forward. For encodings like UTF8 and UTF16 which represent some characters as a sequence of atomic character sizes the function still returns the atomic character size (1 for UTF8, 2 for UTF16).</p>
<p>This function will return the correct value for well known encodings with corresponding CPL_ENC_ values. It may not return the correct value for other encodings even if they are supported by the underlying iconv or windows transliteration services. Hopefully it will improve over time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszEncoding</td><td>the name of the encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of a minimal character in bytes or -1 if the size is unknown. </dd></dl>

</div>
</div>
<a id="a08201755db4923cdc823f71615d12207" name="a08201755db4923cdc823f71615d12207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08201755db4923cdc823f71615d12207">&#9670;&#160;</a></span>CPLEscapeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLEscapeString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nScheme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply escaping to string to preserve special characters. </p>
<p>This function will "escape" a variety of special characters to make the string suitable to embed within a string constant or to write within a text stream but in a form that can be reconstituted to its original form. The escaping will even preserve zero bytes allowing preservation of raw binary data.</p>
<p><a class="el" href="cpl__string_8h.html#a4d69daceff916c28ef0c65506d89d6d3" title="Scheme for CPLEscapeString()/CPLUnescapeString() for backlash quoting.">CPLES_BackslashQuotable(0)</a>: This scheme turns a binary string into a form suitable to be placed within double quotes as a string constant. The backslash, quote, '\0' and newline characters are all escaped in the usual C style.</p>
<p><a class="el" href="cpl__string_8h.html#a7f5479acb68fb882fed8bada7b92db15" title="Scheme for CPLEscapeString()/CPLUnescapeString() for XML.">CPLES_XML(1)</a>: This scheme converts the '&lt;', '&gt;', '"' and '&amp;' characters into their XML/HTML equivalent (&lt;, &gt;, &quot; and &amp;) making a string safe to embed as CDATA within an XML element. The '\0' is not escaped and should not be included in the input.</p>
<p><a class="el" href="cpl__string_8h.html#a88296f14572ad5a724fb512357fddb03" title="Scheme for CPLEscapeString()/CPLUnescapeString() for URL.">CPLES_URL(2)</a>: Everything except alphanumerics and the characters '$', '-', '_', '.', '+', '!', '*', ''', '(', ')' and ',' (see RFC1738) are converted to a percent followed by a two digit hex encoding of the character (leading zero supplied if needed). This is the mechanism used for encoding values to be passed in URLs.</p>
<p><a class="el" href="cpl__string_8h.html#a90614c3cf4cdd748e063f9c2cf669246" title="Scheme for CPLEscapeString()/CPLUnescapeString() for SQL.">CPLES_SQL(3)</a>: All single quotes are replaced with two single quotes. Suitable for use when constructing literal values for SQL commands where the literal will be enclosed in single quotes.</p>
<p><a class="el" href="cpl__string_8h.html#aa3347d20cc965ec42e25bc285a763ea9" title="Scheme for CPLEscapeString()/CPLUnescapeString() for CSV.">CPLES_CSV(4)</a>: If the values contains commas, semicolons, tabs, double quotes, or newlines it placed in double quotes, and double quotes in the value are doubled. Suitable for use when constructing field values for .csv files. Note that CPLUnescapeString() currently does not support this format, only CPLEscapeString(). See cpl_csv.cpp for CSV parsing support.</p>
<p><a class="el" href="cpl__string_8h.html#a97b06de69ccbf6c0f6127a8f033fd056" title="Scheme for CPLEscapeString()/CPLUnescapeString() for SQL identifiers.">CPLES_SQLI(7)</a>: All double quotes are replaced with two double quotes. Suitable for use when constructing identifiers for SQL commands where the literal will be enclosed in double quotes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszInput</td><td>the string to escape. </td></tr>
    <tr><td class="paramname">nLength</td><td>The number of bytes of data to preserve. If this is -1 the strlen(pszString) function will be used to compute the length. </td></tr>
    <tr><td class="paramname">nScheme</td><td>the encoding scheme to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an escaped, zero terminated string that should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer needed. </dd></dl>

</div>
</div>
<a id="a5ac8be2978f873873dbb1ad47f8d9319" name="a5ac8be2978f873873dbb1ad47f8d9319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac8be2978f873873dbb1ad47f8d9319">&#9670;&#160;</a></span>CPLFetchBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CPLFetchBool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for boolean key value. </p>
<p>In a StringList of "Name=Value" pairs, look to see if there is a key with the given name, and if it can be interpreted as being TRUE. If the key appears without any "=Value" portion it will be considered true. If the value is NO, FALSE or 0 it will be considered FALSE otherwise if the key appears in the list it will be considered TRUE. If the key doesn't appear at all, the indicated default value will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszStrList</td><td>the string list to search. </td></tr>
    <tr><td class="paramname">pszKey</td><td>the key value to look for (case insensitive). </td></tr>
    <tr><td class="paramname">bDefault</td><td>the value to return if the key isn't found at all.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a id="a3f9d8d2dd19da9a8a59799175f50fa80" name="a3f9d8d2dd19da9a8a59799175f50fa80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9d8d2dd19da9a8a59799175f50fa80">&#9670;&#160;</a></span>CPLForceToASCII()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLForceToASCII </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>chReplacementChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new string that is made only of ASCII characters. </p>
<p>If non-ASCII characters are found in the input string, they will be replaced by the provided replacement character.</p>
<p>This function does not make any assumption on the encoding of the input string (except it must be nul-terminated if nLen equals -1, or have at least nLen bytes otherwise). CPLUTF8ForceToASCII() can be used instead when the input string is known to be UTF-8 encoded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>input string to test </td></tr>
    <tr><td class="paramname">nLen</td><td>length of the input string, or -1 if the function must compute the string length. In which case it must be null terminated.</td></tr>
    <tr><td class="paramname">chReplacementChar</td><td>character which will be used when the input stream contains a non ASCII character. Must be valid ASCII!</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string that must be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a id="aafb0188f43b0848407f5e6e7c3cfdbb8" name="aafb0188f43b0848407f5e6e7c3cfdbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb0188f43b0848407f5e6e7c3cfdbb8">&#9670;&#160;</a></span>CPLGetValueType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__string_8h.html#a58696cad4b2dc09a3190fa5f64486bf3">CPLValueType</a> CPLGetValueType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect the type of the value contained in a string, whether it is a real, an integer or a string Leading and trailing spaces are skipped in the analysis. </p>
<p>Note: in the context of this function, integer must be understood in a broad sense. It does not mean that the value can fit into a 32 bit integer for example. It might be larger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszValue</td><td>the string to analyze</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the type of the value contained in the string. </dd></dl>

</div>
</div>
<a id="ae0aff1c9cccf82b941da8a7f375a1391" name="ae0aff1c9cccf82b941da8a7f375a1391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0aff1c9cccf82b941da8a7f375a1391">&#9670;&#160;</a></span>CPLHexToBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> * CPLHexToBinary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hexadecimal to binary translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszHex</td><td>the input hex encoded string. </td></tr>
    <tr><td class="paramname">pnBytes</td><td>the returned count of decoded bytes placed here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns binary buffer of data - free with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>. </dd></dl>

</div>
</div>
<a id="a53611712cbde9fad4d5616b1357aeecf" name="a53611712cbde9fad4d5616b1357aeecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53611712cbde9fad4d5616b1357aeecf">&#9670;&#160;</a></span>CPLIsASCII()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CPLIsASCII </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string is encoded as ASCII. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>input string to test </td></tr>
    <tr><td class="paramname">nLen</td><td>length of the input string, or -1 if the function must compute the string length. In which case it must be null terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string is encoded as ASCII. false otherwise</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6.0 </dd></dl>

</div>
</div>
<a id="a9b56be2f17e4c2300af2f0357d32baec" name="a9b56be2f17e4c2300af2f0357d32baec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b56be2f17e4c2300af2f0357d32baec">&#9670;&#160;</a></span>CPLIsUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLIsUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string is encoded as UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>input string to test </td></tr>
    <tr><td class="paramname">nLen</td><td>length of the input string, or -1 if the function must compute the string length. In which case it must be null terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the string is encoded as UTF-8. FALSE otherwise</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a id="ad91223c2a3b06931310e4ad52165117f" name="ad91223c2a3b06931310e4ad52165117f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91223c2a3b06931310e4ad52165117f">&#9670;&#160;</a></span>CPLParseNameValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLParseNameValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNameValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse NAME=VALUE string into name and value components. </p>
<p>Note that if ppszKey is non-NULL, the key (or name) portion will be allocated using CPLMalloc(), and returned in that pointer. It is the applications responsibility to free this string, but the application should not modify or free the returned value portion.</p>
<p>This function also support "NAME:VALUE" strings and will strip white space from around the delimiter when forming name and value strings.</p>
<p>Eventually CSLFetchNameValue() and friends may be modified to use CPLParseNameValue().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNameValue</td><td>string in "NAME=VALUE" format. </td></tr>
    <tr><td class="paramname">ppszKey</td><td>optional pointer though which to return the name portion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value portion (pointing into original string). </dd></dl>

</div>
</div>
<a id="a6614f3d2c28629c7967430c0ed14e6ee" name="a6614f3d2c28629c7967430c0ed14e6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6614f3d2c28629c7967430c0ed14e6ee">&#9670;&#160;</a></span>CPLParseNameValueSep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLParseNameValueSep </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNameValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>chSep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse NAME&lt;Sep&gt;VALUE string into name and value components. </p>
<p>This is derived directly from CPLParseNameValue() which will separate on '=' OR ':', here chSep is required for specifying the separator explicitly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNameValue</td><td>string in "NAME=VALUE" format. </td></tr>
    <tr><td class="paramname">ppszKey</td><td>optional pointer though which to return the name portion. </td></tr>
    <tr><td class="paramname">chSep</td><td>required single char separator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value portion (pointing into original string). </dd></dl>

</div>
</div>
<a id="a125dbe90534c2688426bb518b81d262e" name="a125dbe90534c2688426bb518b81d262e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125dbe90534c2688426bb518b81d262e">&#9670;&#160;</a></span>CPLprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>printf() wrapper that is not sensitive to LC_NUMERIC settings. </p>
<p>This function has the same contract as standard printf(), except that formatting of floating-point numbers will use decimal point, whatever the current locale is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>formatting string </td></tr>
    <tr><td class="paramname">...</td><td>arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters (excluding terminating nul) written in output buffer. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ab848e2fb5cce507247cbbafe1dafc1bf" name="ab848e2fb5cce507247cbbafe1dafc1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab848e2fb5cce507247cbbafe1dafc1bf">&#9670;&#160;</a></span>CPLRecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLRecode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrcEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDstEncoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string from a source encoding to a destination encoding. </p>
<p>The only guaranteed supported encodings are CPL_ENC_UTF8, CPL_ENC_ASCII and CPL_ENC_ISO8859_1. Currently, the following conversions are supported : </p><ul>
<li>
CPL_ENC_ASCII -&gt; CPL_ENC_UTF8 or CPL_ENC_ISO8859_1 (no conversion in fact) </li>
<li>
CPL_ENC_ISO8859_1 -&gt; CPL_ENC_UTF8 </li>
<li>
CPL_ENC_UTF8 -&gt; CPL_ENC_ISO8859_1 </li>
</ul>
<p>If an error occurs an error may, or may not be posted with CPLError().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszSource</td><td>a NULL terminated string. </td></tr>
    <tr><td class="paramname">pszSrcEncoding</td><td>the source encoding. </td></tr>
    <tr><td class="paramname">pszDstEncoding</td><td>the destination encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a NULL terminated string which should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a id="a51398fbf4d8afe5ec8f32177c2a5709e" name="a51398fbf4d8afe5ec8f32177c2a5709e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51398fbf4d8afe5ec8f32177c2a5709e">&#9670;&#160;</a></span>CPLRecodeFromWChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLRecodeFromWChar </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>pwszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrcEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDstEncoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert wchar_t string to UTF-8. </p>
<p>Convert a wchar_t string into a multibyte utf-8 string. The only guaranteed supported source encoding is CPL_ENC_UCS2, and the only guaranteed supported destination encodings are CPL_ENC_UTF8, CPL_ENC_ASCII and CPL_ENC_ISO8859_1. In some cases (i.e. using iconv()) other encodings may also be supported.</p>
<p>Note that the wchar_t type varies in size on different systems. On win32 it is normally 2 bytes, and on UNIX 4 bytes.</p>
<p>If an error occurs an error may, or may not be posted with CPLError().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pwszSource</td><td>the source wchar_t string, terminated with a 0 wchar_t. </td></tr>
    <tr><td class="paramname">pszSrcEncoding</td><td>the source encoding, typically CPL_ENC_UCS2. </td></tr>
    <tr><td class="paramname">pszDstEncoding</td><td>the destination encoding, typically CPL_ENC_UTF8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a zero terminated multi-byte string which should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>, or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a id="afe6413c61c9b78f1e0b8a9ecc954a14f" name="afe6413c61c9b78f1e0b8a9ecc954a14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6413c61c9b78f1e0b8a9ecc954a14f">&#9670;&#160;</a></span>CPLRecodeToWChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t * CPLRecodeToWChar </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrcEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDstEncoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert UTF-8 string to a wchar_t string. </p>
<p>Convert a 8bit, multi-byte per character input string into a wide character (wchar_t) string. The only guaranteed supported source encodings are CPL_ENC_UTF8, CPL_ENC_ASCII and CPL_ENC_ISO8869_1 (LATIN1). The only guaranteed supported destination encoding is CPL_ENC_UCS2. Other source and destination encodings may be supported depending on the underlying implementation.</p>
<p>Note that the wchar_t type varies in size on different systems. On win32 it is normally 2 bytes, and on UNIX 4 bytes.</p>
<p>If an error occurs an error may, or may not be posted with CPLError().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszSource</td><td>input multi-byte character string. </td></tr>
    <tr><td class="paramname">pszSrcEncoding</td><td>source encoding, typically CPL_ENC_UTF8. </td></tr>
    <tr><td class="paramname">pszDstEncoding</td><td>destination encoding, typically CPL_ENC_UCS2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the zero terminated wchar_t string (to be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>) or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a id="a52bc998139a3664bb33f03848e1cf08a" name="a52bc998139a3664bb33f03848e1cf08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bc998139a3664bb33f03848e1cf08a">&#9670;&#160;</a></span>CPLsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>snprintf() wrapper that is not sensitive to LC_NUMERIC settings. </p>
<p>This function has the same contract as standard snprintf(), except that formatting of floating-point numbers will use decimal point, whatever the current locale is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>output buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the output buffer (including space for terminating nul) </td></tr>
    <tr><td class="paramname">fmt</td><td>formatting string </td></tr>
    <tr><td class="paramname">...</td><td>arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters (excluding terminating nul) that would be written if size is big enough. Or potentially -1 with Microsoft C runtime for Visual Studio &lt; 2015. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="adbfcfa28b741e1e8fb266d47a9b2b944" name="adbfcfa28b741e1e8fb266d47a9b2b944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfcfa28b741e1e8fb266d47a9b2b944">&#9670;&#160;</a></span>CPLSPrintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLSPrintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CPLSPrintf() that works with 10 static buffer. </p>
<p>It returns a ref. to a static buffer that should not be freed and is valid only until the next call to CPLSPrintf(). </p>

</div>
</div>
<a id="a35417428994b5306ca08df7899f9703c" name="a35417428994b5306ca08df7899f9703c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35417428994b5306ca08df7899f9703c">&#9670;&#160;</a></span>CPLStrlcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLStrlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDestSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a source string to a destination buffer. </p>
<p>This function ensures that the destination buffer is always NUL terminated (provided that its length is at least 1 and that there is at least one byte free in pszDest, that is to say strlen(pszDest_before) &lt; nDestSize)</p>
<p>This function is designed to be a safer, more consistent, and less error prone replacement for strncat. Its contract is identical to libbsd's strlcat.</p>
<p>Truncation can be detected by testing if the return value of CPLStrlcat is greater or equal to nDestSize.</p>
<pre class="fragment">char szDest[5] = {};
CPLStrlcpy(szDest, "ab", sizeof(szDest));
if( CPLStrlcat(szDest, "cde", sizeof(szDest)) &gt;= sizeof(szDest) )
    fprintf(stderr, "truncation occurred !\n");
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDest</td><td>destination buffer. Must be NUL terminated before running CPLStrlcat </td></tr>
    <tr><td class="paramname">pszSrc</td><td>source string. Must be NUL terminated </td></tr>
    <tr><td class="paramname">nDestSize</td><td>size of destination buffer (including space for the NUL terminator character)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the theoretical length of the destination string after concatenation (=strlen(pszDest_before) + strlen(pszSrc)). If strlen(pszDest_before) &gt;= nDestSize, then it returns nDestSize + strlen(pszSrc)</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a id="a4dee6db43b3ce18912ee45fbfc83e747" name="a4dee6db43b3ce18912ee45fbfc83e747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dee6db43b3ce18912ee45fbfc83e747">&#9670;&#160;</a></span>CPLStrlcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLStrlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDestSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy source string to a destination buffer. </p>
<p>This function ensures that the destination buffer is always NUL terminated (provided that its length is at least 1).</p>
<p>This function is designed to be a safer, more consistent, and less error prone replacement for strncpy. Its contract is identical to libbsd's strlcpy.</p>
<p>Truncation can be detected by testing if the return value of CPLStrlcpy is greater or equal to nDestSize.</p>
<pre class="fragment">char szDest[5] = {};
if( CPLStrlcpy(szDest, "abcde", sizeof(szDest)) &gt;= sizeof(szDest) )
    fprintf(stderr, "truncation occurred !\n");
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDest</td><td>destination buffer </td></tr>
    <tr><td class="paramname">pszSrc</td><td>source string. Must be NUL terminated </td></tr>
    <tr><td class="paramname">nDestSize</td><td>size of destination buffer (including space for the NUL terminator character)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the source string (=strlen(pszSrc))</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a id="acc8e4b09f4437d7ef0cc09b5e3ab93cb" name="acc8e4b09f4437d7ef0cc09b5e3ab93cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8e4b09f4437d7ef0cc09b5e3ab93cb">&#9670;&#160;</a></span>CPLStrlenUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLStrlenUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUTF8Str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of UTF-8 characters of a nul-terminated string. </p>
<p>This is different from strlen() which returns the number of bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszUTF8Str</td><td>a nul-terminated UTF-8 string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of UTF-8 characters. </dd></dl>

</div>
</div>
<a id="a8d45dc0510e8e8f4e58f3cb70e341732" name="a8d45dc0510e8e8f4e58f3cb70e341732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d45dc0510e8e8f4e58f3cb70e341732">&#9670;&#160;</a></span>CPLStrnlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLStrnlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of a NUL terminated string by reading at most the specified number of bytes. </p>
<p>The CPLStrnlen() function returns min(strlen(pszStr), nMaxLen). Only the first nMaxLen bytes of the string will be read. Useful to test if a string contains at least nMaxLen characters without reading the full string up to the NUL terminating character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszStr</td><td>a NUL terminated string </td></tr>
    <tr><td class="paramname">nMaxLen</td><td>maximum number of bytes to read in pszStr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>strlen(pszStr) if the length is lesser than nMaxLen, otherwise nMaxLen if the NUL character has not been found in the first nMaxLen bytes.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a id="a7e6873dfd5c12d0b24e561ce65b4266d" name="a7e6873dfd5c12d0b24e561ce65b4266d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6873dfd5c12d0b24e561ce65b4266d">&#9670;&#160;</a></span>CPLTestBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CPLTestBool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test what boolean value contained in the string. </p>
<p>If pszValue is "NO", "FALSE", "OFF" or "0" will be returned false. Otherwise, true will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszValue</td><td>the string should be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false. </dd></dl>

</div>
</div>
<a id="af8206b42cbbc7d96b2c3aaf093a00de1" name="af8206b42cbbc7d96b2c3aaf093a00de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8206b42cbbc7d96b2c3aaf093a00de1">&#9670;&#160;</a></span>CPLTestBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLTestBoolean </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test what boolean value contained in the string. </p>
<p>If pszValue is "NO", "FALSE", "OFF" or "0" will be returned FALSE. Otherwise, TRUE will be returned.</p>
<p>Use this only in C code. In C++, prefer CPLTestBool().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszValue</td><td>the string should be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE. </dd></dl>

</div>
</div>
<a id="a6b41a4419b0710245e8cdfa655823b4e" name="a6b41a4419b0710245e8cdfa655823b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b41a4419b0710245e8cdfa655823b4e">&#9670;&#160;</a></span>CPLTolower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLTolower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a (ASCII) uppercase character to lowercase. </p>
<p>Same as standard tolower(), except that it is not locale sensitive.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="adea84812431610a8f65dcfd09ec3ea7c" name="adea84812431610a8f65dcfd09ec3ea7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea84812431610a8f65dcfd09ec3ea7c">&#9670;&#160;</a></span>CPLToupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLToupper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a (ASCII) lowercase character to uppercase. </p>
<p>Same as standard toupper(), except that it is not locale sensitive.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="af066b55bb33e580b6d86904828daee31" name="af066b55bb33e580b6d86904828daee31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af066b55bb33e580b6d86904828daee31">&#9670;&#160;</a></span>CPLUnescapeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLUnescapeString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nScheme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unescape a string. </p>
<p>This function does the opposite of CPLEscapeString(). Given a string with special values escaped according to some scheme, it will return a new copy of the string returned to its original form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszInput</td><td>the input string. This is a zero terminated string. </td></tr>
    <tr><td class="paramname">pnLength</td><td>location to return the length of the unescaped string, which may in some cases include embedded '\0' characters. </td></tr>
    <tr><td class="paramname">nScheme</td><td>the escaped scheme to undo (see CPLEscapeString() for a list). Does not yet support CSV.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the unescaped string that should be freed by the application using <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer needed. </dd></dl>

</div>
</div>
<a id="ac45405998f4df728887be28a1a6d4b6e" name="ac45405998f4df728887be28a1a6d4b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45405998f4df728887be28a1a6d4b6e">&#9670;&#160;</a></span>CPLURLAddKVP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCPLString.html">CPLString</a> CPLURLAddKVP </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new URL with a new key=value pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszURL</td><td>the URL. </td></tr>
    <tr><td class="paramname">pszKey</td><td>the key to find. </td></tr>
    <tr><td class="paramname">pszValue</td><td>the value of the key (may be NULL to unset an existing KVP). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the modified URL. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a id="a49550245214ac079518c5fcd5084ecd0" name="a49550245214ac079518c5fcd5084ecd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49550245214ac079518c5fcd5084ecd0">&#9670;&#160;</a></span>CPLURLGetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCPLString.html">CPLString</a> CPLURLGetValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value matching a key from a key=value pair in a URL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszURL</td><td>the URL. </td></tr>
    <tr><td class="paramname">pszKey</td><td>the key to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of empty string if not found. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a id="a94da8e06c5bc7d7decce57e245551d13" name="a94da8e06c5bc7d7decce57e245551d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94da8e06c5bc7d7decce57e245551d13">&#9670;&#160;</a></span>CPLUTF8ForceToASCII()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CPLUTF8ForceToASCII </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>chReplacementChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new string that is made only of ASCII characters. </p>
<p>If non-ASCII characters are found in the input string, for which an "equivalent" ASCII character is not found, they will be replaced by the provided replacement character.</p>
<p>This function is aware of <a href="https://en.wikipedia.org/wiki/Latin-1_Supplement">https://en.wikipedia.org/wiki/Latin-1_Supplement</a> and <a href="https://en.wikipedia.org/wiki/Latin_Extended-A">https://en.wikipedia.org/wiki/Latin_Extended-A</a> to provide sensible replacements for accented characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszStr</td><td>NUL-terminated UTF-8 string. </td></tr>
    <tr><td class="paramname">chReplacementChar</td><td>character which will be used when the input stream contains a non ASCII character that cannot be substituted with an equivalent ASCII character. Must be valid ASCII!</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string that must be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a6394d3ee8e57452cd7d4207b031e75bd" name="a6394d3ee8e57452cd7d4207b031e75bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6394d3ee8e57452cd7d4207b031e75bd">&#9670;&#160;</a></span>CPLVASPrintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLVASPrintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is intended to serve as an easy to use C callable vasprintf() alternative. </p>
<p>Used in the GeoJSON library for instance </p>

</div>
</div>
<a id="a07bbf9c41f4ae994e2bd4e1466d4ed0b" name="a07bbf9c41f4ae994e2bd4e1466d4ed0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bbf9c41f4ae994e2bd4e1466d4ed0b">&#9670;&#160;</a></span>CPLvsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLvsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vsnprintf() wrapper that is not sensitive to LC_NUMERIC settings. </p>
<p>This function has the same contract as standard vsnprintf(), except that formatting of floating-point numbers will use decimal point, whatever the current locale is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>output buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the output buffer (including space for terminating nul) </td></tr>
    <tr><td class="paramname">fmt</td><td>formatting string </td></tr>
    <tr><td class="paramname">args</td><td>arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters (excluding terminating nul) that would be written if size is big enough. Or potentially -1 with Microsoft C runtime for Visual Studio &lt; 2015. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a260bac64c376e2fe723a158569ccbb24" name="a260bac64c376e2fe723a158569ccbb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260bac64c376e2fe723a158569ccbb24">&#9670;&#160;</a></span>CSLAddNameValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLAddNameValue </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new entry to a StringList of "Name=Value" pairs, ("Name:Value" pairs are also supported for backward compatibility with older stuff.) </p>
<p>This function does not check if a "Name=Value" pair already exists for that name and can generate multiple entries for the same name. Use CSLSetNameValue() if you want each name to have only one value.</p>
<p>Returns the modified StringList. </p>

</div>
</div>
<a id="a8445a2b9a14142387cdd35856224c736" name="a8445a2b9a14142387cdd35856224c736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8445a2b9a14142387cdd35856224c736">&#9670;&#160;</a></span>CSLAddString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLAddString </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a string to a StringList and return a pointer to the modified StringList. </p>
<p>If the input StringList is NULL, then a new StringList is created. Note that CSLAddString performance when building a list is in O(n^2) which can cause noticeable slow down when n &gt; 10000. </p>

</div>
</div>
<a id="acf82ba646903716247a341e95b478288" name="acf82ba646903716247a341e95b478288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82ba646903716247a341e95b478288">&#9670;&#160;</a></span>CSLAppendPrintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLAppendPrintf </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use CPLSPrintf() to append a new line at the end of a StringList. </p>
<p>Returns the modified StringList. </p>

</div>
</div>
<a id="a827f21b7a67d16059c131d0946482bb1" name="a827f21b7a67d16059c131d0946482bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827f21b7a67d16059c131d0946482bb1">&#9670;&#160;</a></span>CSLCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of items in a string list. </p>
<p>Returns the number of items in a string list, not counting the terminating NULL. Passing in NULL is safe, and will result in a count of zero.</p>
<p>Lists are counted by iterating through them so long lists will take more time than short lists. Care should be taken to avoid using CSLCount() as an end condition for loops as it will result in O(n^2) behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszStrList</td><td>the string list to count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of entries. </dd></dl>

</div>
</div>
<a id="a5a39b9c5896a273cc6f06c1d5be93238" name="a5a39b9c5896a273cc6f06c1d5be93238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a39b9c5896a273cc6f06c1d5be93238">&#9670;&#160;</a></span>CSLDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSLDestroy </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszStrList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free string list. </p>
<p>Frees the passed string list (null terminated array of strings). It is safe to pass NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszStrList</td><td>the list to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad88bb0ccd4baa3c6d974e99ffde6d6a9" name="ad88bb0ccd4baa3c6d974e99ffde6d6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88bb0ccd4baa3c6d974e99ffde6d6a9">&#9670;&#160;</a></span>CSLDuplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLDuplicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone a string list. </p>
<p>Efficiently allocates a copy of a string list. The returned list is owned by the caller and should be freed with CSLDestroy().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszStrList</td><td>the input string list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly allocated copy. </dd></dl>

</div>
</div>
<a id="ac8d4157385a06d3d1cc905fda008cd75" name="ac8d4157385a06d3d1cc905fda008cd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d4157385a06d3d1cc905fda008cd75">&#9670;&#160;</a></span>CSLFetchBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLFetchBoolean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED. </p>
<p>Check for boolean key value.</p>
<p>In a StringList of "Name=Value" pairs, look to see if there is a key with the given name, and if it can be interpreted as being TRUE. If the key appears without any "=Value" portion it will be considered true. If the value is NO, FALSE or 0 it will be considered FALSE otherwise if the key appears in the list it will be considered TRUE. If the key doesn't appear at all, the indicated default value will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszStrList</td><td>the string list to search. </td></tr>
    <tr><td class="paramname">pszKey</td><td>the key value to look for (case insensitive). </td></tr>
    <tr><td class="paramname">bDefault</td><td>the value to return if the key isn't found at all.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE </dd></dl>

</div>
</div>
<a id="a4f23675f8b6f015ed23d9928048361a1" name="a4f23675f8b6f015ed23d9928048361a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f23675f8b6f015ed23d9928048361a1">&#9670;&#160;</a></span>CSLFetchNameValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CSLFetchNameValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In a StringList of "Name=Value" pairs, look for the first value associated with the specified name. </p>
<p>The search is not case sensitive. ("Name:Value" pairs are also supported for backward compatibility with older stuff.)</p>
<p>Returns a reference to the value in the StringList that the caller should not attempt to free.</p>
<p>Returns NULL if the name is not found. </p>

</div>
</div>
<a id="aa868f5db129cbabe130bbfd03d1d4839" name="aa868f5db129cbabe130bbfd03d1d4839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa868f5db129cbabe130bbfd03d1d4839">&#9670;&#160;</a></span>CSLFetchNameValueMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLFetchNameValueMultiple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In a StringList of "Name=Value" pairs, look for all the values with the specified name. </p>
<p>The search is not case sensitive. ("Name:Value" pairs are also supported for backward compatibility with older stuff.)</p>
<p>Returns StringList with one entry for each occurrence of the specified name. The StringList should eventually be destroyed by calling CSLDestroy().</p>
<p>Returns NULL if the name is not found. </p>

</div>
</div>
<a id="a5ba908f3bf572c87dadeade7e8cbc260" name="a5ba908f3bf572c87dadeade7e8cbc260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba908f3bf572c87dadeade7e8cbc260">&#9670;&#160;</a></span>CSLFindName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLFindName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find StringList entry with given key name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszStrList</td><td>the string list to search. </td></tr>
    <tr><td class="paramname">pszName</td><td>the key value to look for (case insensitive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on failure or the list index of the first occurrence matching the given key. </dd></dl>

</div>
</div>
<a id="a74e2f4bc3bbf2cca1a8bf9954fae5174" name="a74e2f4bc3bbf2cca1a8bf9954fae5174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e2f4bc3bbf2cca1a8bf9954fae5174">&#9670;&#160;</a></span>CSLFindString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLFindString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTarget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a string within a string list (case insensitive). </p>
<p>Returns the index of the entry in the string list that contains the target string. The string in the string list must be a full match for the target, but the search is case insensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszList</td><td>the string list to be searched. </td></tr>
    <tr><td class="paramname">pszTarget</td><td>the string to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the string within the list or -1 on failure. </dd></dl>

</div>
</div>
<a id="a0716feff9a1b9f40e14226c8a7a127c5" name="a0716feff9a1b9f40e14226c8a7a127c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0716feff9a1b9f40e14226c8a7a127c5">&#9670;&#160;</a></span>CSLFindStringCaseSensitive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLFindStringCaseSensitive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTarget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a string within a string list(case sensitive) </p>
<p>Returns the index of the entry in the string list that contains the target string. The string in the string list must be a full match for the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszList</td><td>the string list to be searched. </td></tr>
    <tr><td class="paramname">pszTarget</td><td>the string to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the string within the list or -1 on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a730ac2e48a15ebfdd23b558b82a43ebe" name="a730ac2e48a15ebfdd23b558b82a43ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730ac2e48a15ebfdd23b558b82a43ebe">&#9670;&#160;</a></span>CSLGetField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CSLGetField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches the indicated field, being careful not to crash if the field doesn't exist within this string list. </p>
<p>The returned pointer should not be freed, and doesn't necessarily last long. </p>

</div>
</div>
<a id="a956390f5a48f1019d6e0374530604edf" name="a956390f5a48f1019d6e0374530604edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956390f5a48f1019d6e0374530604edf">&#9670;&#160;</a></span>CSLInsertString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLInsertString </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nInsertAtLineNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewLine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a string at a given line number inside a StringList. </p>
<p>nInsertAtLineNo is a 0-based line index before which the new string should be inserted. If this value is -1 or is larger than the actual number of strings in the list then the string is added at the end of the source StringList.</p>
<p>Returns the modified StringList. </p>

</div>
</div>
<a id="ad1bf8a17b5b3305f2711a01b7d778113" name="ad1bf8a17b5b3305f2711a01b7d778113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bf8a17b5b3305f2711a01b7d778113">&#9670;&#160;</a></span>CSLInsertStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLInsertStrings </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nInsertAtLineNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszNewLines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the contents of a StringList inside another StringList before the specified line. </p>
<p>nInsertAtLineNo is a 0-based line index before which the new strings should be inserted. If this value is -1 or is larger than the actual number of strings in the list then the strings are added at the end of the source StringList.</p>
<p>Returns the modified StringList. </p>

</div>
</div>
<a id="ab63d7761b8a380c07b582729dfed2c74" name="ab63d7761b8a380c07b582729dfed2c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63d7761b8a380c07b582729dfed2c74">&#9670;&#160;</a></span>CSLLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLLoad </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a text file into a string list. </p>
<p>The VSI*L API is used, so <a class="el" href="cpl__vsi_8h.html#ab39f3147cdfa16848ed5b81d5293e27f" title="Open file.">VSIFOpenL()</a> supported objects that aren't physical files can also be accessed. Files are returned as a string list, with one item in the string list per line. End of line markers are stripped (by CPLReadLineL()).</p>
<p>If reading the file fails a CPLError() will be issued and NULL returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFname</td><td>the name of the file to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string list with the files lines, now owned by caller. To be freed with CSLDestroy() </dd></dl>

</div>
</div>
<a id="ab881670cedcdc221394cc35de8c508e6" name="ab881670cedcdc221394cc35de8c508e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab881670cedcdc221394cc35de8c508e6">&#9670;&#160;</a></span>CSLLoad2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLLoad2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a text file into a string list. </p>
<p>The VSI*L API is used, so <a class="el" href="cpl__vsi_8h.html#ab39f3147cdfa16848ed5b81d5293e27f" title="Open file.">VSIFOpenL()</a> supported objects that aren't physical files can also be accessed. Files are returned as a string list, with one item in the string list per line. End of line markers are stripped (by CPLReadLineL()).</p>
<p>If reading the file fails a CPLError() will be issued and NULL returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFname</td><td>the name of the file to read. </td></tr>
    <tr><td class="paramname">nMaxLines</td><td>maximum number of lines to read before stopping, or -1 for no limit. </td></tr>
    <tr><td class="paramname">nMaxCols</td><td>maximum number of characters in a line before stopping, or -1 for no limit. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated array of options. Unused for now.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string list with the files lines, now owned by caller. To be freed with CSLDestroy()</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a id="ae8f338c7010d3f367f64eb094bbc29eb" name="ae8f338c7010d3f367f64eb094bbc29eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f338c7010d3f367f64eb094bbc29eb">&#9670;&#160;</a></span>CSLMerge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLMerge </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOrig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOverride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two lists. </p>
<p>The two lists are merged, ensuring that if any keys appear in both that the value from the second (papszOverride) list take precedence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOrig</td><td>the original list, being modified. </td></tr>
    <tr><td class="paramname">papszOverride</td><td>the list of items being merged in. This list is unaltered and remains owned by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated list. </dd></dl>

</div>
</div>
<a id="a80da7e2cabe09e999eb4e597f4df0ba9" name="a80da7e2cabe09e999eb4e597f4df0ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80da7e2cabe09e999eb4e597f4df0ba9">&#9670;&#160;</a></span>CSLParseCommandLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLParseCommandLine </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCommandLine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokenize command line arguments in a list of strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszCommandLine</td><td>command line</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL terminated list of strings to free with CSLDestroy()</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a9f36efd8180e51959d075fe759d8c7be" name="a9f36efd8180e51959d075fe759d8c7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f36efd8180e51959d075fe759d8c7be">&#9670;&#160;</a></span>CSLPartialFindString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLPartialFindString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszHaystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNeedle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a substring within a string list. </p>
<p>Returns the index of the entry in the string list that contains the target string as a substring. The search is case sensitive (unlike CSLFindString()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszHaystack</td><td>the string list to be searched. </td></tr>
    <tr><td class="paramname">pszNeedle</td><td>the substring to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the string within the list or -1 on failure. </dd></dl>

</div>
</div>
<a id="a3baf50b494941fe28c65b4d43d2ce36f" name="a3baf50b494941fe28c65b4d43d2ce36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3baf50b494941fe28c65b4d43d2ce36f">&#9670;&#160;</a></span>CSLPrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLPrint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fpOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a StringList to fpOut. </p>
<p>If fpOut==NULL, then output is sent to stdout.</p>
<p>Returns the number of lines printed. </p>

</div>
</div>
<a id="ab539fd5cef8ad875d12fba3ef104f6ca" name="ab539fd5cef8ad875d12fba3ef104f6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab539fd5cef8ad875d12fba3ef104f6ca">&#9670;&#160;</a></span>CSLRemoveStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLRemoveStrings </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFirstLineToDelete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNumToRemove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>ppapszRetStrings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove strings inside a StringList. </p>
<p>nFirstLineToDelete is the 0-based line index of the first line to remove. If this value is -1 or is larger than the actual number of strings in list then the nNumToRemove last strings are removed.</p>
<p>If ppapszRetStrings != NULL then the deleted strings won't be free'd, they will be stored in a new StringList and the pointer to this new list will be returned in *ppapszRetStrings.</p>
<p>Returns the modified StringList. </p>

</div>
</div>
<a id="a75750c97bdcf1ccf13ffaae6a30a07a6" name="a75750c97bdcf1ccf13ffaae6a30a07a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75750c97bdcf1ccf13ffaae6a30a07a6">&#9670;&#160;</a></span>CSLSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLSave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a StringList to a text file. </p>
<p>Returns the number of lines written, or 0 if the file could not be written. </p>

</div>
</div>
<a id="ab0e0ecf12c50f0e9b69db4643f96d004" name="ab0e0ecf12c50f0e9b69db4643f96d004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e0ecf12c50f0e9b69db4643f96d004">&#9670;&#160;</a></span>CSLSetNameValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLSetNameValue </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign value to name in StringList. </p>
<p>Set the value for a given name in a StringList of "Name=Value" pairs ("Name:Value" pairs are also supported for backward compatibility with older stuff.)</p>
<p>If there is already a value for that name in the list then the value is changed, otherwise a new "Name=Value" pair is added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszList</td><td>the original list, the modified version is returned. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name to be assigned a value. This should be a well formed token (no spaces or very special characters). </td></tr>
    <tr><td class="paramname">pszValue</td><td>the value to assign to the name. This should not contain any newlines (CR or LF) but is otherwise pretty much unconstrained. If NULL any corresponding value will be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>modified StringList. </dd></dl>

</div>
</div>
<a id="a97b38f55a35f3c1d66ba343692ab9ec0" name="a97b38f55a35f3c1d66ba343692ab9ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b38f55a35f3c1d66ba343692ab9ec0">&#9670;&#160;</a></span>CSLSetNameValueSeparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSLSetNameValueSeparator </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSeparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the default separator (":" or "=") with the passed separator in the given name/value list. </p>
<p>Note that if a separator other than ":" or "=" is used, the resulting list will not be manipulable by the CSL name/value functions any more.</p>
<p>The CPLParseNameValue() function is used to break the existing lines, and it also strips white space from around the existing delimiter, thus the old separator, and any white space will be replaced by the new separator. For formatting purposes it may be desirable to include some white space in the new separator. e.g. ": " or " = ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszList</td><td>the list to update. Component strings may be freed but the list array will remain at the same location.</td></tr>
    <tr><td class="paramname">pszSeparator</td><td>the new separator string to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada798bb0fafd08c7908d0f3716f341b3" name="ada798bb0fafd08c7908d0f3716f341b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada798bb0fafd08c7908d0f3716f341b3">&#9670;&#160;</a></span>CSLTestBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLTestBoolean </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test what boolean value contained in the string. </p>
<p>If pszValue is "NO", "FALSE", "OFF" or "0" will be returned FALSE. Otherwise, TRUE will be returned.</p>
<p>Deprecated. Removed in GDAL 3.x.</p>
<p>Use CPLTestBoolean() for C and CPLTestBool() for C++.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszValue</td><td>the string should be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE. </dd></dl>

</div>
</div>
<a id="a48cef19d299caab18a426a30816bf4e8" name="a48cef19d299caab18a426a30816bf4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cef19d299caab18a426a30816bf4e8">&#9670;&#160;</a></span>CSLTokenizeString2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLTokenizeString2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDelimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCSLTFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokenize a string. </p>
<p>This function will split a string into tokens based on specified' delimiter(s) with a variety of options. The returned result is a string list that should be freed with CSLDestroy() when no longer needed.</p>
<p>The available parsing options are:</p>
<ul>
<li>CSLT_ALLOWEMPTYTOKENS: allow the return of empty tokens when two delimiters in a row occur with no other text between them. If not set, empty tokens will be discarded;</li>
<li>CSLT_STRIPLEADSPACES: strip leading space characters from the token (as reported by isspace());</li>
<li>CSLT_STRIPENDSPACES: strip ending space characters from the token (as reported by isspace());</li>
<li>CSLT_HONOURSTRINGS: double quotes can be used to hold values that should not be broken into multiple tokens;</li>
<li>CSLT_PRESERVEQUOTES: string quotes are carried into the tokens when this is set, otherwise they are removed;</li>
<li>CSLT_PRESERVEESCAPES: if set backslash escapes (for backslash itself, and for literal double quotes) will be preserved in the tokens, otherwise the backslashes will be removed in processing.</li>
</ul>
<p><b>Example:</b> </p>
<p>Parse a string into tokens based on various white space (space, newline, tab) and then print out results and cleanup. Quotes may be used to hold white space in tokens.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> **papszTokens =</div>
<div class="line">    CSLTokenizeString2( pszCommand, <span class="stringliteral">&quot; \t\n&quot;</span>,</div>
<div class="line">                        <a class="code hl_define" href="cpl__string_8h.html#a2338aada58f9282979f68e527f5aeb03">CSLT_HONOURSTRINGS</a> | <a class="code hl_define" href="cpl__string_8h.html#a2cf4a54c9dc07fb312ff0f0d143048cc">CSLT_ALLOWEMPTYTOKENS</a> );</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; papszTokens != NULL &amp;&amp; papszTokens[i] != NULL; ++i )</div>
<div class="line">    printf( <span class="stringliteral">&quot;arg %d: &#39;%s&#39;&quot;</span>, papszTokens[i] );  <span class="comment">// ok</span></div>
<div class="line"> </div>
<div class="line">CSLDestroy( papszTokens );</div>
<div class="ttc" id="acpl__string_8h_html_a2338aada58f9282979f68e527f5aeb03"><div class="ttname"><a href="cpl__string_8h.html#a2338aada58f9282979f68e527f5aeb03">CSLT_HONOURSTRINGS</a></div><div class="ttdeci">#define CSLT_HONOURSTRINGS</div><div class="ttdoc">Flag for CSLTokenizeString2() to honour strings.</div><div class="ttdef"><b>Definition</b> cpl_string.h:87</div></div>
<div class="ttc" id="acpl__string_8h_html_a2cf4a54c9dc07fb312ff0f0d143048cc"><div class="ttname"><a href="cpl__string_8h.html#a2cf4a54c9dc07fb312ff0f0d143048cc">CSLT_ALLOWEMPTYTOKENS</a></div><div class="ttdeci">#define CSLT_ALLOWEMPTYTOKENS</div><div class="ttdoc">Flag for CSLTokenizeString2() to allow empty tokens.</div><div class="ttdef"><b>Definition</b> cpl_string.h:89</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>the string to be split into tokens. </td></tr>
    <tr><td class="paramname">pszDelimiters</td><td>one or more characters to be used as token delimiters. </td></tr>
    <tr><td class="paramname">nCSLTFlags</td><td>an ORing of one or more of the CSLT_ flag values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string list of tokens owned by the caller. </dd></dl>

</div>
</div>
<a id="a11722f741f5f766b4b4c537e3129e21c" name="a11722f741f5f766b4b4c537e3129e21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11722f741f5f766b4b4c537e3129e21c">&#9670;&#160;</a></span>CSLTokenizeStringComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** CSLTokenizeStringComplex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDelimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bHonourStrings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bAllowEmptyTokens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obsolete tokenizing api. </p>
<p>Use CSLTokenizeString2() </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
